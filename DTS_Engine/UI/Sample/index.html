<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CTCI BLOCKPILE Input v1.1 - Developed by Titanium 21005784</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            eng: { dark: '#0f172a', blue: '#3b82f6', amber: '#f59e0b', magenta: '#d946ef' }
          },
          cursor: { 'ew-resize': 'ew-resize', 'ns-resize': 'ns-resize', 'grab': 'grab', 'grabbing': 'grabbing' },
          fontSize: { 'xxs': '0.65rem' }
        }
      }
    }
  </script>
  <style>
    body {
      overflow: hidden;
    }

    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }

    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      background: transparent;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 12px;
      width: 12px;
      border-radius: 50%;
      background: #3b82f6;
      cursor: pointer;
      margin-top: -4px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      cursor: pointer;
      background: #cbd5e1;
      border-radius: 2px;
    }

    .tab-btn.active {
      color: #2563eb;
      border-bottom-color: #2563eb;
      background-color: #eff6ff;
    }

    .tab-btn {
      color: #64748b;
      border-bottom-color: transparent;
    }

    .modal {
      transition: opacity 0.2s ease;
    }
  </style>
</head>

<body class="bg-slate-100 text-slate-800 font-sans text-sm h-screen flex flex-col">

  <!-- HEADER -->
  <header class="flex-none bg-slate-900 text-white shadow-md z-50">
    <div class="px-4 py-2 flex justify-between items-center">
      <div class="flex items-center space-x-3 flex-shrink-0">
        <i class="fa-solid fa-layer-group text-amber-500 text-xl"></i>
        <h1 class="text-lg font-bold tracking-wide">CTCI BLOCKPILE<span
            class="text-amber-400 font-light text-[10px] ml-1">rev1.1 - Developed by Titanium 21005784</span>
        </h1>
      </div>
      <!-- Centered Job Name Input -->
      <div class="flex-1 flex justify-center px-4 min-w-0">
        <input id="header-jobName" type="text" placeholder="Enter Job Name..."
          class="bg-slate-800 border border-slate-600 text-white text-center px-4 py-1 rounded font-bold text-base w-full max-w-xs"
          onchange="App.State.projectInfo = App.State.projectInfo || {}; App.State.projectInfo.jobName = this.value; App.State.notify();">
      </div>
      <div class="flex items-center space-x-3">
        <!-- HELP -->
        <div class="relative group mr-2">
          <div class="flex bg-slate-700 rounded p-1">
            <button onclick="document.getElementById('help-popup').classList.toggle('hidden')"
              class="px-2 py-1 text-[11px] font-bold text-slate-300 hover:text-white rounded"
              title="Help & Documentation"><i class="fa-solid fa-circle-question mr-1"></i>HELP</button>
          </div>
          <!-- TOC Popup -->
          <div id="help-popup"
            class="hidden absolute top-full left-0 mt-1 w-48 bg-slate-800 border border-slate-600 rounded shadow-xl z-50 py-1">
            <a href="help.html#manual" target="_blank"
              onclick="document.getElementById('help-popup').classList.add('hidden')"
              class="block px-4 py-2 text-xs text-slate-300 hover:bg-slate-700 hover:text-white border-b border-slate-700"><i
                class="fa-solid fa-user-gear mr-2 text-indigo-400"></i>User Manual</a>
            <a href="help.html#assembly" target="_blank"
              onclick="document.getElementById('help-popup').classList.add('hidden')"
              class="block px-4 py-2 text-xs text-slate-300 hover:bg-slate-700 hover:text-white border-b border-slate-700"><i
                class="fa-solid fa-cogs mr-2 text-green-400"></i>Assembly Guide</a>
            <a href="help.html#specs" target="_blank"
              onclick="document.getElementById('help-popup').classList.add('hidden')"
              class="block px-4 py-2 text-xs text-slate-300 hover:bg-slate-700 hover:text-white"><i
                class="fa-solid fa-file-code mr-2 text-cyan-400"></i>System Specs</a>
          </div>
        </div>

        <div class="flex bg-slate-700 rounded p-1 space-x-1">
          <button onclick="App.IO.save()"
            class="px-2 py-1 text-[11px] font-bold text-slate-300 hover:bg-slate-600 hover:text-white rounded"
            title="Save Project (.dts)"><i class="fa-solid fa-save"></i></button>
          <button onclick="document.getElementById('fileIn').click()"
            class="px-2 py-1 text-[11px] font-bold text-slate-300 hover:bg-slate-600 hover:text-white rounded"
            title="Load Project (.dts)"><i class="fa-solid fa-folder-open"></i></button>
          <input type="file" id="fileIn" class="hidden" accept=".dts" onchange="App.IO.load(this)">
          <div class="w-px h-4 bg-slate-600 mx-1"></div>
          <button onclick="App.Import.openSimple()"
            class="px-2 py-1 text-[11px] font-bold text-cyan-400 hover:bg-cyan-600 hover:text-white rounded"
            title="Import Data"><i class="fa-solid fa-file-import mr-1"></i>IMPORT</button>
          <button onclick="App.Export.openSimple()"
            class="px-2 py-1 text-[11px] font-bold text-green-400 hover:bg-green-600 hover:text-white rounded"
            title="Export Data"><i class="fa-solid fa-file-export mr-1"></i>EXPORT</button>
        </div>
        <!-- Analysis Tools -->
        <div class="flex bg-indigo-700 rounded p-1 space-x-1">
          <button id="btn-run" onclick="App.UI.toggleRunMode(true)"
            class="px-3 py-1 text-[11px] font-bold bg-indigo-500 hover:bg-indigo-400 text-white rounded shadow-sm transition-colors uppercase tracking-wider"
            title="Run Analysis"><i class="fa-solid fa-play mr-1"></i>RUN</button>
          <button id="btn-settings" onclick="App.UI.openCheckSettings()"
            class="px-2 py-1 text-[11px] font-bold text-indigo-200 hover:bg-indigo-600 hover:text-white rounded"
            title="Check Settings"><i class="fa-solid fa-cog"></i></button>
        </div>
        <div class="flex bg-slate-700 rounded p-1 space-x-1">
          <button onclick="App.History.undo()"
            class="px-2 py-1 text-[11px] font-bold text-slate-300 hover:bg-slate-600 hover:text-white rounded"
            title="Undo (Ctrl+Z)"><i class="fa-solid fa-undo"></i></button>
          <button onclick="App.History.redo()"
            class="px-2 py-1 text-[11px] font-bold text-slate-300 hover:bg-slate-600 hover:text-white rounded"
            title="Redo (Ctrl+Y)"><i class="fa-solid fa-redo"></i></button>
          <div class="w-px h-4 bg-slate-600 mx-1"></div>
          <button onclick="App.Actions.copy()"
            class="px-2 py-1 text-[11px] font-bold text-slate-300 hover:bg-slate-600 hover:text-white rounded"
            title="Copy (Ctrl+C)"><i class="fa-solid fa-copy"></i></button>
          <button onclick="App.Actions.paste()"
            class="px-2 py-1 text-[11px] font-bold text-slate-300 hover:bg-slate-600 hover:text-white rounded"
            title="Paste (Ctrl+V)"><i class="fa-solid fa-paste"></i></button>
          <button onclick="App.Actions.deleteSelected()"
            class="px-2 py-1 text-[11px] font-bold text-slate-300 hover:text-red-400 rounded" title="Delete (Del)"><i
              class="fa-solid fa-trash"></i></button>
        </div>
        <div class="flex items-center space-x-2 bg-slate-800 px-2 py-1 rounded border border-slate-600">
          <span class="text-xs text-slate-400">g:</span>
          <input type="number" id="inpG" value="9.81" onchange="App.Actions.updateGravity(this.value)"
            class="w-12 bg-transparent border-b border-slate-500 text-center text-xs focus:outline-none text-white">
          <select id="inpUnit" onchange="App.Actions.updateUnit(this.value)"
            class="bg-slate-700 text-white text-xs px-1 py-0.5 rounded border border-slate-600 focus:outline-none">
            <option value="M">M (Metric)</option>
            <option value="E">E (English)</option>
          </select>
        </div>
      </div>
    </div>
  </header>

  <!-- MAIN -->
  <div class="flex-grow relative overflow-hidden">

    <!-- SIDEBAR (Floating Overlay) -->
    <div id="sidebar"
      class="absolute left-0 top-0 bottom-0 w-80 bg-white border-r border-slate-200 flex flex-col z-40 shadow-lg transition-all duration-300">

      <!-- Toggle Button (Outside sidebar flow, positioned absolutely relative to sidebar container) -->
      <button onclick="App.UI.toggleSidebar()" id="sidebar-toggle-btn"
        class="absolute -right-3 top-1/2 -translate-y-1/2 bg-white border border-slate-300 rounded-full w-6 h-6 flex items-center justify-center hover:bg-slate-100 shadow-md z-50 transition-transform duration-300">
        <i id="collapse-icon" class="fa-solid fa-chevron-left text-xs text-slate-600"></i>
      </button>

      <!-- Header with Scrollable Tabs -->
      <div class="flex border-b border-slate-200 overflow-x-auto overflow-y-hidden whitespace-nowrap scrollbar-hide">
        <button onclick="App.UI.switchTab('blocks')" id="tab-blocks"
          class="tab-btn active px-4 py-2 font-bold border-b-2 text-xs flex-none">Blocks</button>
        <button onclick="App.UI.switchTab('points')" id="tab-points"
          class="tab-btn px-4 py-2 font-bold border-b-2 text-xs flex-none">Points</button>
        <button onclick="App.UI.switchTab('piles')" id="tab-piles"
          class="tab-btn px-4 py-2 font-bold border-b-2 text-xs flex-none">Piles</button>
        <button onclick="App.UI.switchTab('machines')" id="tab-machines"
          class="tab-btn px-4 py-2 font-bold border-b-2 text-xs flex-none">Machines</button>
        <button onclick="App.UI.switchTab('loads')" id="tab-loads"
          class="tab-btn px-4 py-2 font-bold border-b-2 text-xs flex-none">Loads</button>
        <button onclick="App.UI.switchTab('settings')" id="tab-settings"
          class="tab-btn px-4 py-2 font-bold border-b-2 text-xs flex-none">Settings</button>
      </div>

      <!-- Content -->
      <div class="flex-grow overflow-y-auto p-3 space-y-3" id="panel-container">

        <!-- BLOCKS PANEL -->
        <div id="panel-blocks">
          <div class="bg-slate-50 p-3 rounded border border-slate-200 mb-3">
            <div class="grid grid-cols-3 gap-2 mb-2">
              <div><label class="text-[10px] font-bold text-slate-500">L (m)</label><input id="add-L" type="number"
                  value="5" class="w-full border rounded px-1 text-xs"></div>
              <div><label class="text-[10px] font-bold text-slate-500">W (m)</label><input id="add-W" type="number"
                  value="3" class="w-full border rounded px-1 text-xs"></div>
              <div><label class="text-[10px] font-bold text-slate-500">H (m)</label><input id="add-H" type="number"
                  value="1" class="w-full border rounded px-1 text-xs"></div>
            </div>
            <div class="grid grid-cols-3 gap-2 mb-2">
              <div><label class="text-[10px] font-bold text-slate-500">X (m)</label><input id="add-X" type="number"
                  value="0" class="w-full border rounded px-1 text-xs"></div>
              <div><label class="text-[10px] font-bold text-slate-500">Y (m)</label><input id="add-Y" type="number"
                  value="0" class="w-full border rounded px-1 text-xs"></div>
              <div><label class="text-[10px] font-bold text-slate-500">Z (m)</label><input id="add-Z" type="number"
                  value="0" class="w-full border rounded px-1 text-xs"></div>
            </div>
            <button onclick="App.Actions.addBlock()"
              class="w-full bg-slate-900 text-white py-1.5 rounded text-xs font-bold hover:bg-slate-800"><i
                class="fa-solid fa-plus mr-1"></i> Add Block</button>
          </div>
          <div class="h-64 overflow-y-auto border rounded bg-white">
            <table class="w-full text-xs text-left">
              <thead class="bg-slate-50 sticky top-0">
                <tr>
                  <th class="p-1 text-center">#</th>
                  <th class="p-1">Name</th>
                  <th class="p-1">Pos</th>
                  <th class="p-1">Dims</th>
                  <th class="p-1">Thick</th>
                  <th class="p-1 text-center">Void</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="list-blocks"></tbody>
            </table>
          </div>
        </div>

        <!-- POINTS PANEL (NEW) -->
        <div id="panel-points" class="hidden">
          <div class="bg-slate-50 p-3 rounded border border-slate-200 mb-3">
            <div class="grid grid-cols-2 gap-2 mb-2">
              <button onclick="App.Actions.genPointsFromBlocks()"
                class="w-full bg-slate-200 border border-slate-300 text-slate-700 py-1 rounded text-[10px] font-bold hover:bg-slate-300">
                <i class="fa-solid fa-cube mr-1"></i> From Blocks
              </button>
              <button onclick="App.Actions.genPointsFromPiles()"
                class="w-full bg-slate-200 border border-slate-300 text-slate-700 py-1 rounded text-[10px] font-bold hover:bg-slate-300">
                <i class="fa-solid fa-circle mr-1"></i> From Piles
              </button>
            </div>
            <hr class="border-slate-200 mb-2">
            <div class="grid grid-cols-3 gap-2 mb-2">
              <div><label class="text-[10px] font-bold text-slate-500">X (m)</label><input id="add-point-X"
                  type="number" value="0" class="w-full border rounded px-1 text-xs"></div>
              <div><label class="text-[10px] font-bold text-slate-500">Y (m)</label><input id="add-point-Y"
                  type="number" value="0" class="w-full border rounded px-1 text-xs"></div>
              <div><label class="text-[10px] font-bold text-slate-500">Z (m)</label><input id="add-point-Z"
                  type="number" value="0" class="w-full border rounded px-1 text-xs"></div>
            </div>
            <button onclick="App.Actions.addPoint()"
              class="w-full bg-red-500 text-white py-1.5 rounded text-xs font-bold hover:bg-red-600"><i
                class="fa-solid fa-crosshairs mr-1"></i> Add Point</button>
          </div>
          <div class="h-64 overflow-y-auto border rounded bg-white">
            <table class="w-full text-xs text-left">
              <thead class="bg-slate-50 sticky top-0">
                <tr>
                  <th class="p-1 text-center">#</th>
                  <th class="p-1">Label</th>
                  <th class="p-1">Pos</th>
                  <th class="p-1">Host</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="list-points"></tbody>
            </table>
          </div>
        </div>

        <!-- PILES PANEL (UPDATED) -->
        <div id="panel-piles" class="hidden">
          <!-- Global Pile Stiffness (Legacy Mode) -->
          <div class="bg-emerald-50 p-3 rounded border border-emerald-300 mb-3">
            <h3 class="font-bold text-xs uppercase mb-2 text-emerald-700">
              <i class="fa-solid fa-layer-group mr-1"></i>Global Pile Stiffness (Legacy)
            </h3>
            <p class="text-[9px] text-slate-500 mb-2">Legacy engine uses single Kv/Kh for all piles</p>
            <div class="grid grid-cols-2 gap-2 mb-2">
              <div><label class="text-[10px] font-bold text-slate-500">Kv (kN/m)</label>
                <input id="global-Kv" type="number" value="0" step="1000"
                  class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.params.globalKv = parseFloat(this.value); App.State.notify();">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Kh (kN/m)</label>
                <input id="global-Kh" type="number" value="0" step="1000"
                  class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.params.globalKh = parseFloat(this.value); App.State.notify();">
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <div><label class="text-[10px] font-bold text-slate-500">Strategy (if piles differ)</label>
                <select id="stiffness-strategy" class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.params.stiffnessStrategy = this.value; App.State.notify();">
                  <option value="global">Use Global Values</option>
                  <option value="first">Use First Pile</option>
                  <option value="average">Average of All Piles</option>
                  <option value="max">Maximum Value</option>
                  <option value="min">Minimum Value</option>
                </select>
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">zBottom Override</label>
                <input id="zBottom-override" type="number" placeholder="Auto" step="0.1"
                  class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.params.zBottomOverride = this.value ? parseFloat(this.value) : null; App.State.notify();">
              </div>
            </div>
          </div>
          <!-- Pile Capacity Limits -->
          <div class="bg-orange-50 p-3 rounded border border-orange-200 mb-3">
            <h3 class="font-bold text-xs uppercase mb-2 text-orange-700">
              <i class="fa-solid fa-arrow-down mr-1"></i>Pile Capacity Limits (Geotech)
            </h3>
            <div class="grid grid-cols-3 gap-2">
              <div><label class="text-[10px] font-bold text-slate-500">Comp (kN)</label>
                <input id="pile-cap-comp" type="number" value="2500" step="100"
                  class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.params.pileCapacity.compression = parseFloat(this.value); App.State.notify();">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Tens (kN)</label>
                <input id="pile-cap-tens" type="number" value="500" step="50"
                  class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.params.pileCapacity.tension = parseFloat(this.value); App.State.notify();">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Lat (kN)</label>
                <input id="pile-cap-lat" type="number" value="100" step="10"
                  class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.params.pileCapacity.lateral = parseFloat(this.value); App.State.notify();">
              </div>
            </div>
          </div>
          <!-- Single Pile Creation -->
          <div class="bg-green-50 p-3 rounded border border-green-200 mb-3">
            <h3 class="font-bold text-xs uppercase mb-2 text-green-700">Add Single Pile</h3>
            <div class="grid grid-cols-3 gap-2 mb-2">
              <div><label class="text-[10px] font-bold text-slate-500">X (m)</label>
                <input id="add-pile-X" type="number" value="0" step="0.5" class="w-full border rounded px-1 text-xs">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Y (m)</label>
                <input id="add-pile-Y" type="number" value="0" step="0.5" class="w-full border rounded px-1 text-xs">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Name</label>
                <input id="add-pile-name" type="text" placeholder="P1" class="w-full border rounded px-1 text-xs">
              </div>
            </div>
            <button onclick="App.Actions.addSinglePile()"
              class="w-full bg-green-600 text-white py-1 rounded text-xs font-bold hover:bg-green-700">
              <i class="fa-solid fa-plus mr-1"></i>Add Pile
            </button>
          </div>
          <!-- Grid Generation -->
          <div class="bg-slate-50 p-3 rounded border border-slate-200 mb-3">
            <h3 class="font-bold text-xs uppercase mb-2 text-slate-700">Grid Generation</h3>
            <div class="grid grid-cols-2 gap-2 mb-2">
              <div><label class="text-[10px] font-bold text-slate-500">Shape</label>
                <select id="gen-shape" class="w-full border rounded px-1 py-0.5 text-xs bg-white">
                  <option value="round">Round (Cylinder)</option>
                  <option value="square">Square (Prism)</option>
                </select>
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Size (m)</label>
                <input id="gen-size" type="number" value="0.4" step="0.1" class="w-full border rounded px-1 text-xs">
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2 mb-2">
              <div><label class="text-[10px] font-bold text-slate-500">Length (m)</label>
                <input id="gen-len" type="number" value="15" step="1" class="w-full border rounded px-1 text-xs">
              </div>
              <div></div>
            </div>
            <div class="grid grid-cols-2 gap-2 mb-2">
              <div><label class="text-[10px] font-bold text-slate-500">Rows</label><input id="gen-rows" type="number"
                  value="2" class="w-full border rounded px-1 text-xs"></div>
              <div><label class="text-[10px] font-bold text-slate-500">Cols</label><input id="gen-cols" type="number"
                  value="2" class="w-full border rounded px-1 text-xs"></div>
              <div><label class="text-[10px] font-bold text-slate-500">Sp X</label><input id="gen-sx" type="number"
                  value="2.5" class="w-full border rounded px-1 text-xs"></div>
              <div><label class="text-[10px] font-bold text-slate-500">Sp Y</label><input id="gen-sy" type="number"
                  value="1.5" class="w-full border rounded px-1 text-xs"></div>
            </div>
            <button onclick="App.Actions.genPiles()"
              class="w-full bg-blue-600 text-white py-1.5 rounded text-xs font-bold hover:bg-blue-700">Generate
              Piles</button>
          </div>
          <div class="h-64 overflow-y-auto border rounded bg-white">
            <table class="w-full text-xs text-left">
              <thead class="bg-slate-50 sticky top-0">
                <tr>
                  <th class="p-1 text-center">#</th>
                  <th class="p-1">Name</th>
                  <th class="p-1">Pos</th>
                  <th class="p-1">Shape</th>
                  <th class="p-1">L</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="list-piles"></tbody>
            </table>
          </div>
        </div>

        <!-- LOADS PANEL -->
        <div id="panel-loads" class="hidden">
          <div class="bg-red-50 p-3 rounded border border-red-200 mb-3">
            <h3 class="font-bold text-xs uppercase mb-2 text-red-700">Add Load Point</h3>
            <div class="grid grid-cols-4 gap-1 mb-2">
              <div><label class="text-[10px] font-bold text-slate-500">X (m)</label>
                <input id="add-load-X" type="number" value="0" step="0.01" class="w-full border rounded px-1 text-xs">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Y (m)</label>
                <input id="add-load-Y" type="number" value="0" step="0.01" class="w-full border rounded px-1 text-xs">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Z (m)</label>
                <input id="add-load-Z" type="number" value="1.0" step="0.01" class="w-full border rounded px-1 text-xs">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Name</label>
                <input id="add-load-name" type="text" value="Load 1" class="w-full border rounded px-1 text-xs">
              </div>
            </div>
            <div class="text-[10px] text-red-600 font-bold mb-1">Primary Forces</div>
            <div class="grid grid-cols-6 gap-1 mb-2">
              <div><label class="text-[9px] text-red-500">Fx</label>
                <input id="add-load-Fx" type="number" value="0" step="0.1"
                  class="w-full border rounded px-1 text-xs border-red-200">
              </div>
              <div><label class="text-[9px] text-green-500">Fy</label>
                <input id="add-load-Fy" type="number" value="0" step="0.1"
                  class="w-full border rounded px-1 text-xs border-green-200">
              </div>
              <div><label class="text-[9px] text-blue-500">Fz</label>
                <input id="add-load-Fz" type="number" value="0" step="0.1"
                  class="w-full border rounded px-1 text-xs border-blue-200">
              </div>
              <div><label class="text-[9px] text-slate-500">Mx</label>
                <input id="add-load-Mx" type="number" value="0" step="0.1" class="w-full border rounded px-1 text-xs">
              </div>
              <div><label class="text-[9px] text-slate-500">My</label>
                <input id="add-load-My" type="number" value="0" step="0.1" class="w-full border rounded px-1 text-xs">
              </div>
              <div><label class="text-[9px] text-slate-500">Mz</label>
                <input id="add-load-Mz" type="number" value="0" step="0.1" class="w-full border rounded px-1 text-xs">
              </div>
            </div>
            <div class="flex space-x-1">
              <button onclick="App.Actions.addLoadPoint()"
                class="flex-1 bg-red-600 text-white py-1 rounded text-xs font-bold hover:bg-red-700">
                <i class="fa-solid fa-plus mr-1"></i>Add Load
              </button>
              <button onclick="App.Actions.addLoadFromBlocks()"
                class="flex-1 bg-slate-500 text-white py-1 rounded text-xs font-bold hover:bg-slate-600"
                title="Add at top center of selected blocks">
                <i class="fa-solid fa-cube mr-1"></i>From Blocks
              </button>
              <button onclick="App.Actions.addLoadFromMachines()"
                class="flex-1 bg-purple-500 text-white py-1 rounded text-xs font-bold hover:bg-purple-600"
                title="Add at machine location (hosted)">
                <i class="fa-solid fa-cog mr-1"></i>From Machines
              </button>
            </div>
          </div>
          <!-- Wind Loads (Static) -->
          <div class="bg-cyan-50 p-3 rounded border border-cyan-200 mb-3">
            <h3 class="font-bold text-xs uppercase mb-2 text-cyan-700">
              <i class="fa-solid fa-wind mr-1"></i>Wind Loads (Static)
            </h3>
            <div class="grid grid-cols-3 gap-2">
              <div><label class="text-[10px] font-bold text-slate-500">Wind Fx (kN)</label>
                <input id="wind-fx" type="number" value="0" step="1" class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.staticLoads.WindX = parseFloat(this.value); App.State.notify();">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Wind Fy (kN)</label>
                <input id="wind-fy" type="number" value="0" step="1" class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.staticLoads.WindY = parseFloat(this.value); App.State.notify();">
              </div>
              <div><label class="text-[10px] font-bold text-slate-500">Arm Z (m)</label>
                <input id="wind-arm-z" type="number" value="0" step="0.1"
                  class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.staticLoads.WindArmZ = parseFloat(this.value); App.State.notify();">
              </div>
            </div>
            <p class="text-[8px] text-slate-500 mt-1">Used for pile reaction calculations</p>
          </div>
          <div class="text-[10px] text-slate-500 mb-1">Double-click to edit forces</div>
          <div class="h-52 overflow-y-auto border rounded bg-white">
            <table class="w-full text-xs text-left">
              <thead class="bg-red-50 sticky top-0">
                <tr>
                  <th class="p-1">#</th>
                  <th class="p-1">Label</th>
                  <th class="p-1">Position</th>
                  <th class="p-1">Host</th>
                  <th class="p-1">Forces</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="list-loadPoints"></tbody>
            </table>
          </div>
        </div>

        <div id="panel-machines" class="hidden">
          <!-- Machine Assembly Buttons -->
          <div class="flex space-x-1 mb-2">
            <button
              onclick="document.getElementById('assemblyWizard').classList.remove('hidden'); App.Assembly.initWizard();"
              class="flex-1 bg-purple-600 text-white py-1.5 rounded text-xs font-bold hover:bg-purple-700">
              <i class="fa-solid fa-layer-group mr-1"></i>Define Assembly
            </button>
            <button onclick="App.Assembly.generateAll();"
              class="flex-1 bg-fuchsia-500 text-white py-1.5 rounded text-xs font-bold hover:bg-fuchsia-600">
              <i class="fa-solid fa-cogs mr-1"></i>Generate Machines
            </button>
          </div>
          <div class="flex items-center mb-2 text-xs">
            <input type="checkbox" id="toggle-assemblies" checked
              onchange="App.State.showAssemblies = this.checked; App.State.notify();"
              class="w-3.5 h-3.5 mr-1.5 accent-purple-500">
            <label for="toggle-assemblies" class="text-slate-600">Show Assembly Wireframes</label>
            <span class="ml-auto text-[10px] text-purple-600 font-bold" id="asm-count">0 assemblies</span>
          </div>
          <!-- Assembly List -->
          <div class="border rounded mb-2 max-h-32 overflow-y-auto" id="assembly-list-container">
            <table class="w-full text-xs">
              <thead class="bg-purple-50 sticky top-0">
                <tr>
                  <th class="p-1 text-left">#</th>
                  <th class="p-1 text-left">Name</th>
                  <th class="p-1 text-left">X,Y</th>
                  <th class="p-1 text-left">Parts</th>
                  <th class="p-1 w-8"></th>
                </tr>
              </thead>
              <tbody id="list-assemblies"></tbody>
            </table>
          </div>
          <!-- Machine Settings Header -->
          <div class="bg-purple-50 p-2 rounded border border-purple-200 mb-2">
            <div class="grid grid-cols-2 gap-2">
              <div><label class="text-[10px] font-bold text-purple-600">Machine Type</label>
                <select id="machine-type" class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.projectInfo = App.State.projectInfo || {}; App.State.projectInfo.machineType = this.value; App.State.notify();">
                  <option value="C">C - Centrifugal</option>
                  <option value="R">R - Reciprocating</option>
                </select>
              </div>
              <div><label class="text-[10px] font-bold text-purple-600">Operating RPM</label>
                <input id="machine-freq" type="number" value="8800" step="100"
                  class="w-full border rounded px-1 text-xs bg-white"
                  onchange="App.State.loadsConfig.freq = parseFloat(this.value); App.State.notify();">
              </div>
            </div>
          </div>
          <div class="bg-slate-50 p-3 rounded border border-slate-200 mb-3">
            <h3 class="font-bold text-xs uppercase mb-2 text-slate-700">Add Machine (Mass Point)</h3>
            <div class="space-y-2">
              <div class="grid grid-cols-2 gap-2">
                <div><label class="text-[10px] font-bold text-slate-500">Name</label>
                  <input id="add-machine-name" type="text" value="Machine 1" class="w-full border rounded px-1 text-xs">
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">Weight W (kN)</label>
                  <input id="add-machine-W" type="number" value="34.335" step="0.001"
                    class="w-full border rounded px-1 text-xs">
                </div>
              </div>
              <div class="grid grid-cols-4 gap-1">
                <div><label class="text-[10px] font-bold text-slate-500">X (m)</label>
                  <input id="add-machine-X" type="number" value="0" step="0.01"
                    class="w-full border rounded px-1 text-xs">
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">Y (m)</label>
                  <input id="add-machine-Y" type="number" value="0" step="0.01"
                    class="w-full border rounded px-1 text-xs">
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">Z (m)</label>
                  <input id="add-machine-Z" type="number" value="1.125" step="0.01"
                    class="w-full border rounded px-1 text-xs">
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">Rot (°)</label>
                  <input id="add-machine-rot" type="number" value="0" step="15"
                    class="w-full border rounded px-1 text-xs">
                </div>
              </div>
              <details class="text-xs">
                <summary class="text-slate-500 cursor-pointer">Mass Moment of Inertia (optional)</summary>
                <div class="grid grid-cols-3 gap-1 mt-1">
                  <div><label class="text-[10px] font-bold text-slate-400">Ix</label>
                    <input id="add-machine-Ix" type="number" value="0" class="w-full border rounded px-1 text-xs">
                  </div>
                  <div><label class="text-[10px] font-bold text-slate-400">Iy</label>
                    <input id="add-machine-Iy" type="number" value="0" class="w-full border rounded px-1 text-xs">
                  </div>
                  <div><label class="text-[10px] font-bold text-slate-400">Iz</label>
                    <input id="add-machine-Iz" type="number" value="0" class="w-full border rounded px-1 text-xs">
                  </div>
                </div>
              </details>
              <button onclick="App.Actions.addMachine()"
                class="w-full bg-purple-600 text-white py-1.5 rounded text-xs font-bold hover:bg-purple-700">
                <i class="fa-solid fa-cogs mr-1"></i> Add Machine
              </button>
            </div>
          </div>
          <div class="text-[10px] text-slate-500 mb-1">Double-click to edit rotation</div>
          <div class="h-52 overflow-y-auto border rounded bg-white">
            <table class="w-full text-xs text-left">
              <thead class="bg-slate-50 sticky top-0">
                <tr>
                  <th class="p-1 text-center">#</th>
                  <th class="p-1">Name</th>
                  <th class="p-1">W</th>
                  <th class="p-1">X,Y,Z</th>
                  <th class="p-1">Rot</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="list-machines"></tbody>
            </table>
          </div>
        </div>

        <!-- SETTINGS PANEL -->
        <div id="panel-settings" class="hidden">
          <div class="bg-white p-3 rounded border space-y-3">
            <!-- PROJECT INFO (NEW) -->
            <div class="border-b pb-2 mb-2">
              <h3 class="font-bold text-xs uppercase border-b mb-2 text-blue-600"><i
                  class="fa-solid fa-folder-open mr-1"></i>Project Info</h3>
              <div class="grid grid-cols-2 gap-2 mt-2">
                <div><label class="text-[10px] font-bold text-slate-500">Foundation Type</label>
                  <select id="project-capType" class="w-full border rounded px-1 text-xs bg-slate-50"
                    onchange="App.State.projectInfo.capType = this.value; App.State.notify();">
                    <option value="C">C - Composited</option>
                    <option value="R">R - Rectangular</option>
                    <option value="A">A - Arbitrary</option>
                  </select>
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">Pile Arrangement</label>
                  <select id="project-arrangement" class="w-full border rounded px-1 text-xs bg-slate-50"
                    onchange="App.State.projectInfo.arrangement = this.value; App.State.notify();">
                    <option value="A">A - Array (Manual XY)</option>
                    <option value="R">R - Rectangular Grid</option>
                  </select>
                </div>
              </div>
              <!-- Cap Type A Button (only visible when capType=A) -->
              <div id="capA-params-row" class="hidden mt-2">
                <button onclick="document.getElementById('capAModal').classList.remove('hidden')"
                  class="w-full bg-amber-500 text-white py-1.5 rounded text-xs font-bold hover:bg-amber-600">
                  <i class="fa-solid fa-sliders mr-1"></i>Configure Arbitrary Cap Parameters
                </button>
              </div>
              <div class="grid grid-cols-2 gap-2 mt-1">
                <div><label class="text-[10px] font-bold text-slate-500">Stiffness Input</label>
                  <select id="project-stiffness" class="w-full border rounded px-1 text-xs bg-slate-50"
                    onchange="App.State.projectInfo.stiffness = this.value; App.State.notify();">
                    <option value="I">I - Input Values</option>
                    <option value="C">C - Computed</option>
                  </select>
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">Pile Head</label>
                  <select id="project-pileHead" class="w-full border rounded px-1 text-xs bg-slate-50"
                    onchange="App.State.projectInfo.pileHead = this.value; App.State.notify();">
                    <option value=" ">Fixed</option>
                    <option value="H">H - Hinged</option>
                  </select>
                </div>
              </div>
              <!-- Stiffness C Button (only visible when stiffness=C) -->
              <div id="stiffC-params-row" class="hidden mt-2">
                <button onclick="document.getElementById('stiffCModal').classList.remove('hidden')"
                  class="w-full bg-teal-500 text-white py-1.5 rounded text-xs font-bold hover:bg-teal-600">
                  <i class="fa-solid fa-calculator mr-1"></i>Configure Computed Stiffness Parameters
                </button>
              </div>
              <div class="grid grid-cols-2 gap-2 mt-1">
                <div><label class="text-[10px] font-bold text-slate-500">Units</label>
                  <select id="project-unit" class="w-full border rounded px-1 text-xs bg-slate-50"
                    onchange="App.State.projectInfo.unit = this.value; App.State.notify();">
                    <option value="M">M - Metric (kN, m)</option>
                    <option value="E">E - English (kips, ft)</option>
                  </select>
                </div>
                <div></div>
              </div>
            </div>

            <div>
              <h3 class="font-bold text-xs uppercase border-b mb-2">Display Settings</h3>
              <div><label class="text-[10px] font-bold text-slate-500">Pile Visualization</label>
                <select id="set-pileDraw" onchange="App.Actions.updateSettings('pileDrawMode', this.value)"
                  class="w-full border rounded px-1 text-xs bg-slate-50">
                  <option value="representative">Representative (2x Max Block Height)</option>
                  <option value="actual">Actual Length</option>
                </select>
              </div>
            </div>
            <div>
              <h3 class="font-bold text-xs uppercase border-b mb-2">Material Properties</h3>
              <div class="space-y-2">
                <div><label class="text-[10px] font-bold text-slate-500">Concrete Density (kN/m³)</label>
                  <input id="set-density" type="number" value="23.544" step="0.001"
                    class="w-full border rounded px-1 text-xs"
                    onchange="App.Actions.updateSettings('concreteDensity', this.value)">
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">Gravity (m/s²)</label>
                  <input id="set-gravity" type="number" value="9.81" step="0.01"
                    class="w-full border rounded px-1 text-xs" onchange="App.Actions.updateGravity(this.value)">
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">Concrete Strength (kg/cm²)</label>
                  <input id="set-strength" type="number" value="280" step="1" class="w-full border rounded px-1 text-xs"
                    onchange="App.Actions.updateSettings('concreteStrength', this.value)">
                </div>
              </div>
            </div>
            <div>
              <h3 class="font-bold text-xs uppercase border-b mb-2">Damping Ratios (ξ)</h3>
              <div class="grid grid-cols-2 gap-2">
                <div><label class="text-[10px] font-bold text-slate-500">ξz (Vertical)</label>
                  <input id="set-dampZ" type="number" value="0.25" step="0.01" min="0" max="1"
                    class="w-full border rounded px-1 text-xs"
                    onchange="App.Actions.updateSettings('dampingZ', this.value)">
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">ξx (Horizontal)</label>
                  <input id="set-dampX" type="number" value="0.25" step="0.01" min="0" max="1"
                    class="w-full border rounded px-1 text-xs"
                    onchange="App.Actions.updateSettings('dampingX', this.value)">
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">ξ Rock (Rocking)</label>
                  <input id="set-dampRock" type="number" value="0.25" step="0.01" min="0" max="1"
                    class="w-full border rounded px-1 text-xs"
                    onchange="App.Actions.updateSettings('dampingRock', this.value)">
                </div>
                <div><label class="text-[10px] font-bold text-slate-500">ξ Tor (Torsion)</label>
                  <input id="set-dampTor" type="number" value="0.25" step="0.01" min="0" max="1"
                    class="w-full border rounded px-1 text-xs"
                    onchange="App.Actions.updateSettings('dampingTor', this.value)">
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- RESULT SIDEBAR (Fixed to viewport for proper expansion) -->
      <div id="result-sidebar"
        class="fixed top-[56px] bottom-0 right-0 bg-white z-[60] flex flex-col hidden transition-all duration-200 shadow-xl border-l border-slate-300"
        style="width:320px;">
        <!-- Header -->
        <div class="flex-none p-3 border-b border-slate-200 bg-indigo-50 flex justify-between items-center">
          <button onclick="App.UI.toggleRunMode(false)"
            class="text-xs font-bold text-slate-600 hover:text-slate-900 flex items-center">
            <i class="fa-solid fa-arrow-left mr-1"></i> Close
          </button>
          <span class="font-bold text-indigo-700 text-sm uppercase tracking-wide">Analysis Results</span>
          <span id="res-status-badge"
            class="text-[10px] bg-amber-100 text-amber-700 px-2 py-0.5 rounded-full font-bold">Need run sweeps</span>
        </div>
        <!-- Tabs -->
        <div class="flex border-b border-slate-200 bg-white">
          <button onclick="App.UI.switchResTab('summary')" id="rtab-summary"
            class="rtab-btn flex-1 py-2 text-xs font-bold text-indigo-600 border-b-2 border-indigo-600">Summary</button>
          <button onclick="App.UI.switchResTab('vertical')" id="rtab-vertical"
            class="rtab-btn flex-1 py-2 text-xs font-bold text-slate-500 hover:text-indigo-600 border-b-2 border-transparent">Vertical</button>
          <button onclick="App.UI.switchResTab('coupled')" id="rtab-coupled"
            class="rtab-btn flex-1 py-2 text-xs font-bold text-slate-500 hover:text-indigo-600 border-b-2 border-transparent">Coupled</button>
          <button onclick="App.UI.switchResTab('graphs')" id="rtab-graphs"
            class="rtab-btn flex-1 py-2 text-xs font-bold text-slate-500 hover:text-indigo-600 border-b-2 border-transparent">Graphs</button>
          <button onclick="App.UI.switchResTab('report')" id="rtab-report"
            class="rtab-btn flex-1 py-2 text-xs font-bold text-slate-500 hover:text-indigo-600 border-b-2 border-transparent">Report</button>
        </div>
        <!-- Content Area -->
        <div id="res-content" class="flex-grow overflow-y-auto p-3 space-y-3 text-xs">
          <!-- Content injected by JS -->
          <div class="text-center text-slate-400 py-8"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Running
            analysis...</div>
        </div>
        <!-- Footer -->
        <div class="flex-none p-2 border-t border-slate-200 bg-slate-50 flex justify-end space-x-2">
          <button onclick="App.UI.exportReport()"
            class="px-3 py-1 text-[10px] font-bold bg-slate-600 text-white rounded hover:bg-slate-500">
            <i class="fa-solid fa-file-alt mr-1"></i>Export Report
          </button>
        </div>
      </div>

      <div
        class="p-2 border-t border-slate-200 bg-slate-50 text-[10px] flex justify-between items-center text-slate-600 font-mono">
        <div>Mass: <span id="res-mass" class="font-bold text-slate-900">0.0</span> t</div>
        <div>CG: <span id="res-cg" class="font-bold text-slate-900">0,0,0</span></div>
        <div>FnZ: <span id="res-fnz" class="font-bold text-blue-700">0</span></div>
        <div>FnC: <span id="res-fnc" class="font-bold text-amber-700">0</span></div>
      </div>
    </div>

    <!-- CANVAS (Full-Screen Background) -->
    <div class="absolute inset-0 flex flex-col bg-slate-100 overflow-hidden">
      <!-- View Tools (moved to account for sidebar) -->
      <div id="ui-view-tools"
        class="absolute top-2 left-[330px] z-10 bg-white p-1 rounded shadow border flex items-center space-x-1 transition-all duration-300">
        <button onclick="App.Renderer.setView('XY')"
          class="px-2 py-0.5 text-[10px] font-bold rounded bg-blue-500 text-white" id="view-XY">XY (Plan)</button>
        <button onclick="App.Renderer.setView('XZ')"
          class="px-2 py-0.5 text-[10px] font-bold rounded text-slate-500 hover:bg-slate-50" id="view-XZ">XZ
          (Front)</button>
        <button onclick="App.Renderer.setView('YZ')"
          class="px-2 py-0.5 text-[10px] font-bold rounded text-slate-500 hover:bg-slate-50" id="view-YZ">YZ
          (Side)</button>
        <div class="w-px h-4 bg-slate-300 mx-1"></div>
        <button onclick="App.Renderer.setView('ISO_SE')"
          class="px-2 py-0.5 text-[10px] font-bold rounded text-slate-500 hover:bg-slate-50" id="view-ISO_SE">3D
          SE</button>
        <button onclick="App.Renderer.setView('ISO_SW')"
          class="px-2 py-0.5 text-[10px] font-bold rounded text-slate-500 hover:bg-slate-50"
          id="view-ISO_SW">SW</button>
        <button onclick="App.Renderer.setView('ISO_NE')"
          class="px-2 py-0.5 text-[10px] font-bold rounded text-slate-500 hover:bg-slate-50"
          id="view-ISO_NE">NE</button>
        <button onclick="App.Renderer.setView('ISO_NW')"
          class="px-2 py-0.5 text-[10px] font-bold rounded text-slate-500 hover:bg-slate-50"
          id="view-ISO_NW">NW</button>
      </div>

      <!-- AUDIT PANEL (Center-Top of Canvas) -->
      <div id="audit-panel-top"
        class="absolute top-2 left-1/2 -translate-x-1/2 z-10 text-sm font-bold pointer-events-none max-w-lg text-center transition-all duration-300">
        <div id="audit-errors-top" class="text-red-600 whitespace-pre-line mb-1"></div>
        <div id="audit-warnings-top" class="text-amber-500 whitespace-pre-line"></div>
      </div>

      <canvas id="mainCanvas" class="w-full h-full block cursor-crosshair"></canvas>

      <!-- SIMPLE EXPORT POPUP (in canvas wrapper) -->
      <div id="simpleExportPopup" class="hidden absolute inset-0 bg-black/40 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-[600px] max-h-[80vh] overflow-auto">
          <div class="bg-fuchsia-600 text-white px-4 py-2 font-bold flex justify-between">
            <span><i class="fa-solid fa-file-export mr-2"></i>Export Data</span>
            <button onclick="document.getElementById('simpleExportPopup').classList.add('hidden')"
              class="hover:text-fuchsia-200"><i class="fa-solid fa-times"></i></button>
          </div>
          <div class="p-4" id="simpleExportContent">
            <!-- Content populated by JS -->
          </div>
        </div>
      </div>

      <!-- CAL SETTINGS POPUP -->
      <div id="calSettingsPopup" class="hidden absolute inset-0 bg-black/40 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-[400px]">
          <div class="bg-indigo-600 text-white px-4 py-2 font-bold flex justify-between">
            <span><i class="fa-solid fa-cog mr-2"></i>Calculation Settings</span>
            <button onclick="document.getElementById('calSettingsPopup').classList.add('hidden')"
              class="hover:text-indigo-200"><i class="fa-solid fa-times"></i></button>
          </div>
          <div class="p-4 space-y-4">
            <!-- Frequency Sweep -->
            <div class="bg-indigo-50 p-3 rounded border border-indigo-200">
              <h3 class="font-bold text-indigo-700 text-xs uppercase mb-2"><i
                  class="fa-solid fa-wave-square mr-1"></i>Frequency Sweep</h3>
              <div class="grid grid-cols-3 gap-2">
                <div>
                  <label class="text-[10px] font-bold text-slate-500">Start (RPM)</label>
                  <input id="cal-freqStart" type="number" value="0" step="100"
                    class="w-full border rounded px-2 py-1 text-xs">
                </div>
                <div>
                  <label class="text-[10px] font-bold text-slate-500">End (RPM)</label>
                  <input id="cal-freqEnd" type="number" value="12000" step="100"
                    class="w-full border rounded px-2 py-1 text-xs">
                </div>
                <div>
                  <label class="text-[10px] font-bold text-slate-500">Step (RPM)</label>
                  <input id="cal-freqStep" type="number" value="100" step="10"
                    class="w-full border rounded px-2 py-1 text-xs">
                </div>
              </div>
            </div>
            <!-- Damping Override -->
            <div class="bg-slate-50 p-3 rounded border">
              <h3 class="font-bold text-slate-700 text-xs uppercase mb-2"><i class="fa-solid fa-gauge mr-1"></i>Damping
                Ratios</h3>
              <div class="grid grid-cols-2 gap-2">
                <div>
                  <label class="text-[10px] font-bold text-slate-500">ξ Vertical</label>
                  <input id="cal-dampZ" type="number" value="0.25" step="0.01" min="0" max="1"
                    class="w-full border rounded px-2 py-1 text-xs">
                </div>
                <div>
                  <label class="text-[10px] font-bold text-slate-500">ξ Horizontal</label>
                  <input id="cal-dampX" type="number" value="0.25" step="0.01" min="0" max="1"
                    class="w-full border rounded px-2 py-1 text-xs">
                </div>
                <div>
                  <label class="text-[10px] font-bold text-slate-500">ξ Rocking</label>
                  <input id="cal-dampRock" type="number" value="0.25" step="0.01" min="0" max="1"
                    class="w-full border rounded px-2 py-1 text-xs">
                </div>
                <div>
                  <label class="text-[10px] font-bold text-slate-500">ξ Torsion</label>
                  <input id="cal-dampTor" type="number" value="0.25" step="0.01" min="0" max="1"
                    class="w-full border rounded px-2 py-1 text-xs">
                </div>
              </div>
            </div>
            <!-- Buttons -->
            <div class="flex justify-end space-x-2">
              <button onclick="document.getElementById('calSettingsPopup').classList.add('hidden')"
                class="px-4 py-2 bg-slate-300 rounded font-bold text-xs">Cancel</button>
              <button onclick="App.UI.applyCalSettings()"
                class="px-4 py-2 bg-indigo-600 text-white rounded font-bold text-xs hover:bg-indigo-700">
                <i class="fa-solid fa-check mr-1"></i>Apply & Run</button>
            </div>
          </div>
        </div>
      </div>

      <!-- CHECK SETTINGS POPUP (for btn-settings in header) -->
      <div id="checkSettingsPopup" class="hidden absolute inset-0 bg-black/40 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-[500px] max-h-[90vh] overflow-y-auto">
          <div class="bg-fuchsia-600 text-white px-4 py-2 font-bold sticky top-0 flex justify-between">
            <span><i class="fa-solid fa-clipboard-check mr-2"></i>Check Settings & Standards</span>
            <button onclick="document.getElementById('checkSettingsPopup').classList.add('hidden')"
              class="hover:text-fuchsia-200"><i class="fa-solid fa-times"></i></button>
          </div>
          <div class="p-4 space-y-3">
            <!-- ISO 10816 Section -->
            <div class="bg-blue-50 p-2 rounded border border-blue-200">
              <h3 class="font-bold text-blue-700 text-xs mb-1">
                <i class="fa-solid fa-wave-square mr-1"></i>ISO 10816-1 (Vibration Limits)
              </h3>
              <div class="grid grid-cols-4 gap-2">
                <div>
                  <label class="text-[9px] font-bold">Machine Class</label>
                  <select id="check-iso-class" onchange="App.Standards.applyISOClass(this.value)"
                    class="w-full border rounded px-1 py-0.5 text-xs">
                    <option value="I">Class I (&lt;15kW)</option>
                    <option value="II" selected>Class II (15-75kW)</option>
                    <option value="III">Class III (Large)</option>
                    <option value="IV">Class IV (Turbines)</option>
                  </select>
                </div>
                <div><label class="text-[9px]">Max Vel (mm/s)</label>
                  <input id="check-iso-vel" type="number" value="4.5" step="0.1"
                    class="w-full border rounded px-1 py-0.5 text-xs">
                </div>
                <div><label class="text-[9px]">Max Disp (μm)</label>
                  <input id="check-iso-disp" type="number" value="25" class="w-full border rounded px-1 py-0.5 text-xs">
                </div>
                <div><label class="text-[9px]">Max Acc (m/s²)</label>
                  <input id="check-iso-acc" type="number" value="0.5" step="0.1"
                    class="w-full border rounded px-1 py-0.5 text-xs">
                </div>
              </div>
            </div>

            <!-- DIN 4024 Section -->
            <div class="bg-green-50 p-2 rounded border border-green-200">
              <h3 class="font-bold text-green-700 text-xs mb-1">
                <i class="fa-solid fa-gauge mr-1"></i>DIN 4024 (Frequency Tuning)
              </h3>
              <div class="grid grid-cols-2 gap-2">
                <div><label class="text-[9px]">Avoidance Zone (%)</label>
                  <input id="check-din-zone" type="number" value="20" class="w-full border rounded px-1 py-0.5 text-xs">
                  <span class="text-[8px] text-slate-500">±20% of f_op</span>
                </div>
                <div><label class="text-[9px]">Check 2× Harmonic</label>
                  <input id="check-din-2x" type="checkbox" class="ml-2">
                  <span class="text-[8px] text-slate-500">(Reciprocating)</span>
                </div>
              </div>
            </div>

            <!-- ACI 351.3R Section -->
            <div class="bg-amber-50 p-2 rounded border border-amber-200">
              <h3 class="font-bold text-amber-700 text-xs mb-1">
                <i class="fa-solid fa-balance-scale mr-1"></i>ACI 351.3R (Static Checks)
              </h3>
              <div class="grid grid-cols-2 gap-2">
                <div><label class="text-[9px]">Min Mass Ratio</label>
                  <input id="check-aci-mass" type="number" value="3" step="1"
                    class="w-full border rounded px-1 py-0.5 text-xs">
                  <span class="text-[8px] text-slate-500">≥3 (Centrifugal) or ≥5 (Recip)</span>
                </div>
                <div><label class="text-[9px]">Max Eccentricity (%)</label>
                  <input id="check-aci-ecc" type="number" value="5" step="1"
                    class="w-full border rounded px-1 py-0.5 text-xs">
                  <span class="text-[8px] text-slate-500">&lt; 5% of dimension</span>
                </div>
              </div>
            </div>

            <!-- Pile Capacity Section -->
            <div class="bg-orange-50 p-2 rounded border border-orange-200">
              <h3 class="font-bold text-orange-700 text-xs mb-1">
                <i class="fa-solid fa-arrow-down mr-1"></i>Pile Capacity (from Geotech Report)
              </h3>
              <div class="grid grid-cols-3 gap-2">
                <div><label class="text-[9px]">Compression (kN)</label>
                  <input id="check-pile-comp" type="number" value="2500"
                    class="w-full border rounded px-1 py-0.5 text-xs">
                </div>
                <div><label class="text-[9px]">Tension (kN)</label>
                  <input id="check-pile-tens" type="number" value="500"
                    class="w-full border rounded px-1 py-0.5 text-xs">
                </div>
                <div><label class="text-[9px]">Lateral (kN)</label>
                  <input id="check-pile-lat" type="number" value="100"
                    class="w-full border rounded px-1 py-0.5 text-xs">
                </div>
              </div>
            </div>

            <!-- Buttons -->
            <div class="flex justify-between">
              <button onclick="App.Standards.resetDefaults()" class="text-[10px] text-slate-500 underline">
                Reset to Defaults
              </button>
              <div class="space-x-2">
                <button onclick="document.getElementById('checkSettingsPopup').classList.add('hidden')"
                  class="px-4 py-2 bg-slate-300 rounded font-bold text-xs">Cancel</button>
                <button onclick="App.UI.applyCheckSettings()"
                  class="px-4 py-2 bg-fuchsia-600 text-white rounded font-bold text-xs hover:bg-fuchsia-700">
                  <i class="fa-solid fa-save mr-1"></i>Save
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- SIMPLE IMPORT POPUP (in canvas wrapper) -->
      <div id="simpleImportPopup" class="hidden absolute inset-0 bg-black/40 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-[500px]">
          <div class="bg-blue-600 text-white px-4 py-2 font-bold flex justify-between">
            <span><i class="fa-solid fa-file-import mr-2"></i>Import Data</span>
            <button onclick="document.getElementById('simpleImportPopup').classList.add('hidden')"
              class="hover:text-blue-200"><i class="fa-solid fa-times"></i></button>
          </div>
          <div class="p-4 space-y-3">
            <p class="text-sm text-slate-600">Paste input file content or import from file:</p>
            <div class="flex items-center space-x-2">
              <input type="file" id="importFileInput" class="hidden" accept="*"
                onchange="App.Import.loadFromFile(this)">
              <button onclick="document.getElementById('importFileInput').click()"
                class="px-3 py-1.5 bg-slate-200 text-slate-700 rounded font-bold text-sm hover:bg-slate-300">
                <i class="fa-solid fa-folder-open mr-1"></i>Import from File
              </button>
              <span class="text-xs text-slate-400">(.in, .out, .txt)</span>
            </div>
            <textarea id="simpleImportText" class="w-full h-40 text-xs font-mono bg-slate-50 p-3 rounded border"
              placeholder="PILE&#10;Project_Name&#10;CCAI M&#10;...&#10;&#10;OR paste Output Report starting with:&#10;DYNAMICAL ANALYSIS..."></textarea>
            <div id="simpleImportLog" class="text-xs text-purple-600"></div>
            <div class="flex justify-end space-x-2">
              <button onclick="document.getElementById('simpleImportPopup').classList.add('hidden')"
                class="px-4 py-2 bg-slate-300 rounded font-bold">Cancel</button>
              <button onclick="App.Import.parseAndPreview()"
                class="px-4 py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700"><i
                  class="fa-solid fa-eye mr-1"></i>Preview</button>
            </div>
          </div>
        </div>
      </div>

      <!-- ASSEMBLY WIZARD POPUP -->
      <div id="assemblyWizard" class="hidden absolute inset-0 bg-black/50 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-[720px] max-h-[90vh] overflow-hidden flex flex-col">
          <div
            class="bg-gradient-to-r from-purple-600 to-fuchsia-600 text-white px-4 py-2 font-bold flex justify-between items-center">
            <span><i class="fa-solid fa-layer-group mr-2"></i>Define Machine Assembly</span>
            <button onclick="document.getElementById('assemblyWizard').classList.add('hidden')"
              class="hover:text-purple-200"><i class="fa-solid fa-times text-lg"></i></button>
          </div>
          <!-- Two column layout -->
          <div class="flex flex-1 overflow-hidden">
            <!-- Left: Form -->
            <div class="flex-1 p-3 space-y-2 overflow-y-auto">
              <!-- Anchor Point Section - 2 rows -->
              <div class="bg-purple-50 p-2 rounded border border-purple-200">
                <!-- Row 1: Name, X, Y, Z, Rot -->
                <div class="flex items-center gap-2">
                  <div class="w-24">
                    <label class="text-[9px] font-bold text-purple-600">Name</label>
                    <input id="asm-name" type="text" class="w-full border rounded px-1.5 py-0.5 text-xs"
                      value="Assembly 1">
                  </div>
                  <div class="w-14">
                    <label class="text-[9px] font-bold text-slate-500">X</label>
                    <input id="asm-X" type="number" step="0.01" class="w-full border rounded px-1 py-0.5 text-xs"
                      value="0" oninput="App.Assembly.updatePreview()">
                  </div>
                  <div class="w-14">
                    <label class="text-[9px] font-bold text-slate-500">Y</label>
                    <input id="asm-Y" type="number" step="0.01" class="w-full border rounded px-1 py-0.5 text-xs"
                      value="0" oninput="App.Assembly.updatePreview()">
                  </div>
                  <div class="w-14">
                    <label class="text-[9px] font-bold text-slate-500">Z</label>
                    <input id="asm-Z" type="number" step="0.01" class="w-full border rounded px-1 py-0.5 text-xs"
                      value="1.125">
                  </div>
                  <div class="w-14">
                    <label class="text-[9px] font-bold text-slate-500">Rot°</label>
                    <input id="asm-rotation" type="number" step="15" class="w-full border rounded px-1 py-0.5 text-xs"
                      value="0" oninput="App.Assembly.onRotationChange()">
                  </div>
                </div>
                <!-- Row 2: Total I at anchor -->
                <div class="flex items-center gap-2 mt-1 pt-1 border-t border-purple-200">
                  <div class="w-24 text-[9px] text-blue-600 font-bold">ΣI at Anchor:</div>
                  <div class="w-14">
                    <label class="text-[11px] font-bold text-blue-700">Ix</label>
                    <div id="asm-total-Ix" class="text-[10px] font-mono text-blue-600 bg-blue-50 rounded px-1">0</div>
                  </div>
                  <div class="w-14">
                    <label class="text-[11px] font-bold text-blue-700">Iy</label>
                    <div id="asm-total-Iy" class="text-[10px] font-mono text-blue-600 bg-blue-50 rounded px-1">0</div>
                  </div>
                  <div class="w-14">
                    <label class="text-[11px] font-bold text-blue-700">Iz</label>
                    <div id="asm-total-Iz" class="text-[10px] font-mono text-blue-600 bg-blue-50 rounded px-1">0</div>
                  </div>
                  <div class="w-14 text-[8px] text-slate-400">(kN·m·s²)</div>
                </div>
              </div>
              <!-- Component Section - 2 rows per component -->
              <div class="border rounded flex-1">
                <div class="bg-fuchsia-100 px-2 py-1 flex justify-between items-center">
                  <h4 class="font-bold text-[10px] uppercase text-fuchsia-800">
                    <i class="fa-solid fa-cogs mr-1"></i>Components (Mass Points)
                  </h4>
                  <button onclick="App.Assembly.addComponentRow()"
                    class="bg-fuchsia-600 text-white px-1.5 py-0.5 rounded text-[10px] font-bold hover:bg-fuchsia-700">
                    <i class="fa-solid fa-plus mr-0.5"></i>Add
                  </button>
                </div>
                <!-- Column Headers -->
                <div class="grid gap-0.5 px-1 py-0.5 bg-slate-100 border-b text-[8px] text-slate-500 font-bold"
                  style="grid-template-columns: 20px 96px 56px 50px 50px 50px 22px;">
                  <div></div>
                  <div class="pl-1">Name</div>
                  <div class="text-center">W (kN)</div>
                  <div class="text-center">dx</div>
                  <div class="text-center">dy</div>
                  <div class="text-center">dz</div>
                  <div></div>
                </div>
                <div class="max-h-[220px] overflow-y-auto" id="asm-components-container">
                  <!-- Components are added dynamically as 2-row blocks -->
                  <div id="asm-components" class="divide-y divide-slate-100"></div>
                </div>
              </div>
            </div>
            <!-- Right: XY Preview (expanded) -->
            <div class="w-[340px] p-2 bg-slate-50 border-l flex flex-col">
              <h4 class="font-bold text-[10px] uppercase text-slate-600 mb-1">
                <i class="fa-solid fa-eye mr-1"></i>XY Preview
              </h4>
              <div class="flex-1 bg-white rounded border relative" style="min-height: 280px;">
                <canvas id="asm-preview-canvas" class="w-full h-full block"></canvas>
              </div>
              <div class="text-[12px] text-slate-500 mt-1 text-center font-medium">
                <span class="text-purple-600">●</span> Anchor
                <span class="text-fuchsia-500 ml-2">○</span> Components
              </div>
            </div>
          </div>
          <!-- Footer buttons -->
          <div class="bg-slate-100 px-3 py-2 flex justify-between border-t">
            <button onclick="document.getElementById('assemblyWizard').classList.add('hidden')"
              class="px-3 py-1.5 bg-slate-300 text-slate-700 rounded text-xs font-bold hover:bg-slate-400">Cancel</button>
            <button onclick="App.Assembly.createAssembly()"
              class="px-4 py-1.5 bg-purple-600 text-white rounded text-xs font-bold hover:bg-purple-700">
              <i class="fa-solid fa-check mr-1"></i>Create Assembly
            </button>
          </div>
        </div>
      </div>

      <!-- IMPORT PREVIEW POPUP -->
      <div id="importPreviewPopup" class="hidden absolute inset-0 bg-black/50 z-[55] flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-[850px] max-h-[85vh] overflow-hidden flex flex-col">
          <div
            class="bg-gradient-to-r from-green-600 to-teal-600 text-white px-4 py-2 font-bold flex justify-between items-center">
            <span><i class="fa-solid fa-eye mr-2"></i>Import Preview</span>
            <div class="flex items-center space-x-3">
              <span id="preview-format" class="text-green-200 text-sm"></span>
              <button onclick="App.Import.closePreview()" class="hover:text-green-200"><i
                  class="fa-solid fa-times"></i></button>
            </div>
          </div>
          <div class="p-4 overflow-y-auto flex-grow space-y-4">
            <!-- Summary -->
            <div class="grid grid-cols-5 gap-2 text-xs">
              <div class="bg-blue-50 p-2 rounded border border-blue-200 text-center">
                <div class="text-blue-400 text-[10px]">Unit System</div>
                <div id="preview-unit" class="font-bold text-blue-700">-</div>
              </div>
              <div class="bg-purple-50 p-2 rounded border border-purple-200 text-center">
                <div class="text-purple-400 text-[10px]">Machine Type</div>
                <div id="preview-machType" class="font-bold text-purple-700">-</div>
              </div>
              <div class="bg-slate-50 p-2 rounded border border-slate-200 text-center">
                <div class="text-slate-400 text-[10px]">Blocks</div>
                <div id="preview-blockCount" class="font-bold text-slate-700">0</div>
              </div>
              <div class="bg-green-50 p-2 rounded border border-green-200 text-center">
                <div class="text-green-400 text-[10px]">Piles</div>
                <div id="preview-pileCount" class="font-bold text-green-700">0</div>
              </div>
              <div class="bg-amber-50 p-2 rounded border border-amber-200 text-center">
                <div class="text-amber-400 text-[10px]">Frequency</div>
                <div id="preview-rpm" class="font-bold text-amber-700">-</div>
              </div>
            </div>
            <!-- Warnings -->
            <div id="preview-warnings"
              class="hidden bg-amber-50 border border-amber-300 rounded p-2 text-xs text-amber-700"></div>
            <!-- Machines Table -->
            <details open class="border rounded">
              <summary class="bg-purple-100 px-3 py-1 font-bold text-xs text-purple-700 cursor-pointer">
                <i class="fa-solid fa-cogs mr-1"></i>Machines (<span id="preview-machCount">0</span>)
              </summary>
              <div class="max-h-32 overflow-y-auto">
                <table class="w-full text-xs">
                  <thead class="bg-purple-50 sticky top-0">
                    <tr>
                      <th class="p-1 text-left">#</th>
                      <th class="p-1 text-left">Name</th>
                      <th class="p-1 text-right" id="th-mach-weight">Weight (kN)</th>
                      <th class="p-1 text-right">X</th>
                      <th class="p-1 text-right">Y</th>
                      <th class="p-1 text-right">Z</th>
                    </tr>
                  </thead>
                  <tbody id="preview-machines"></tbody>
                </table>
              </div>
            </details>
            <!-- Forces Table -->
            <details open class="border rounded">
              <summary class="bg-red-100 px-3 py-1 font-bold text-xs text-red-700 cursor-pointer">
                <i class="fa-solid fa-bolt mr-1"></i>Forces
              </summary>
              <div class="max-h-40 overflow-y-auto">
                <table class="w-full text-xs">
                  <thead class="bg-red-50 sticky top-0">
                    <tr>
                      <th class="p-1 text-left">Component</th>
                      <th class="p-1 text-left">Type</th>
                      <th class="p-1 text-right" id="th-force-val">Value (kN)</th>
                      <th class="p-1 text-right">Arm 1</th>
                      <th class="p-1 text-right">Arm 2</th>
                      <th class="p-1 text-left">Detected Location</th>
                    </tr>
                  </thead>
                  <tbody id="preview-forces"></tbody>
                </table>
              </div>
            </details>
            <!-- Blocks Table -->
            <details open class="border rounded">
              <summary class="bg-slate-100 px-3 py-1 font-bold text-xs text-slate-700 cursor-pointer">
                <i class="fa-solid fa-cube mr-1"></i>Blocks (<span id="preview-blockCount2">0</span>)
              </summary>
              <div class="max-h-40 overflow-y-auto">
                <table class="w-full text-xs">
                  <thead class="bg-slate-50 sticky top-0">
                    <tr>
                      <th class="p-1 text-left">#</th>
                      <th class="p-1 text-left">Name</th>
                      <th class="p-1 text-right">L</th>
                      <th class="p-1 text-right">W</th>
                      <th class="p-1 text-right">H</th>
                      <th class="p-1 text-right">X</th>
                      <th class="p-1 text-right">Y</th>
                      <th class="p-1 text-right">Z</th>
                      <th class="p-1 text-center">Factor</th>
                      <th class="p-1"></th>
                    </tr>
                  </thead>
                  <tbody id="preview-blocks"></tbody>
                </table>
              </div>
            </details>
            <!-- Piles Table -->
            <details open class="border rounded">
              <summary class="bg-green-100 px-3 py-1 font-bold text-xs text-green-700 cursor-pointer">
                <i class="fa-solid fa-circle mr-1"></i>Piles (<span id="preview-pileCount2">0</span>)
              </summary>
              <div class="max-h-32 overflow-y-auto">
                <table class="w-full text-xs">
                  <thead class="bg-green-50 sticky top-0">
                    <tr>
                      <th class="p-1 text-left">#</th>
                      <th class="p-1 text-right">X</th>
                      <th class="p-1 text-right">Y</th>
                      <th class="p-1 text-right">Z</th>
                      <th class="p-1 text-right">Kv</th>
                      <th class="p-1 text-right">Kh</th>
                    </tr>
                  </thead>
                  <tbody id="preview-piles"></tbody>
                </table>
              </div>
            </details>
            <!-- Points Table -->
            <details class="border rounded">
              <summary class="bg-cyan-100 px-3 py-1 font-bold text-xs text-cyan-700 cursor-pointer">
                <i class="fa-solid fa-crosshairs mr-1"></i>Check Points (<span id="preview-pointCount">0</span>)
              </summary>
              <div class="max-h-24 overflow-y-auto">
                <table class="w-full text-xs">
                  <thead class="bg-cyan-50 sticky top-0">
                    <tr>
                      <th class="p-1 text-left">#</th>
                      <th class="p-1 text-left">Name</th>
                      <th class="p-1 text-right">X</th>
                      <th class="p-1 text-right">Y</th>
                      <th class="p-1 text-right">Z</th>
                    </tr>
                  </thead>
                  <tbody id="preview-points"></tbody>
                </table>
              </div>
            </details>
          </div>
          <div class="bg-slate-100 px-4 py-3 flex justify-between items-center border-t">
            <div class="text-xs text-slate-500"><i class="fa-solid fa-info-circle mr-1"></i>Review data before importing
            </div>
            <div class="flex space-x-2">
              <button onclick="App.Import.closePreview()"
                class="px-4 py-2 bg-slate-300 rounded font-bold hover:bg-slate-400">Cancel</button>
              <button onclick="App.Import.applyPreview()"
                class="px-4 py-2 bg-green-600 text-white rounded font-bold hover:bg-green-700">
                <i class="fa-solid fa-check mr-1"></i>Confirm Import
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- FIX MISSING NODE MODAL -->
      <div id="fixNodePopup" class="hidden absolute inset-0 bg-black/60 z-[60] flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl w-[500px] max-h-[80vh] overflow-hidden flex flex-col">
          <div
            class="bg-gradient-to-r from-emerald-600 to-green-600 text-white px-4 py-2 font-bold flex justify-between items-center">
            <span><i class="fa-solid fa-wrench mr-2"></i>Fix Missing Nodes</span>
            <button onclick="App.Import.closeFixNode()" class="hover:text-emerald-200"><i
                class="fa-solid fa-times"></i></button>
          </div>
          <div class="p-4 overflow-auto space-y-4">
            <!-- Block Selection (if multiple) -->
            <div id="fix-block-select" class="hidden">
              <label class="text-xs font-bold text-slate-600 block mb-1">Select Block to Fix:</label>
              <select id="fixBlockSelector" onchange="App.Import.onFixBlockSelect()"
                class="w-full border rounded px-2 py-1 text-sm"></select>
            </div>

            <!-- Missing Nodes Info -->
            <div class="bg-amber-50 border border-amber-200 rounded p-3">
              <div class="text-xs font-bold text-amber-700 mb-1"><i
                  class="fa-solid fa-exclamation-triangle mr-1"></i>Missing Node(s):</div>
              <div id="fix-missing-nodes" class="text-sm text-amber-800 font-mono"></div>
            </div>

            <!-- Existing Nodes Info (NEW) -->
            <div class="bg-slate-50 border border-slate-200 rounded p-3">
              <div class="text-xs font-bold text-slate-600 mb-2"><i class="fa-solid fa-cube mr-1"></i>Block Node
                Definitions:</div>
              <div id="fix-nodes-table" class="text-xs"></div>
            </div>

            <!-- Geometry Analysis (NEW) -->
            <div class="bg-blue-50 border border-blue-200 rounded p-3">
              <div class="text-xs font-bold text-blue-700 mb-1"><i class="fa-solid fa-ruler-combined mr-1"></i>Geometry
                Analysis:</div>
              <div id="fix-geometry-analysis" class="text-xs text-blue-800"></div>
            </div>

            <!-- Fix Options -->
            <div class="space-y-3">
              <!-- Option A: Auto-create at origin -->
              <div class="border rounded p-3 hover:bg-slate-50 cursor-pointer"
                onclick="App.Import.applyFixOption('origin')">
                <div class="flex items-center">
                  <input type="radio" name="fixOption" value="origin" class="mr-2">
                  <span class="font-bold text-sm text-slate-700">A. Auto-create at Origin (0, 0, 0)</span>
                </div>
                <p class="text-xs text-slate-500 mt-1 ml-5">Create missing node(s) at coordinates (0, 0, 0)</p>
              </div>

              <!-- Option B: Enter coordinates -->
              <div class="border rounded p-3"
                onclick="document.querySelector('input[name=fixOption][value=coords]').checked = true">
                <div class="flex items-center">
                  <input type="radio" name="fixOption" value="coords" class="mr-2">
                  <span class="font-bold text-sm text-slate-700">B. Enter Coordinates Manually</span>
                </div>
                <div class="mt-2 ml-5 grid grid-cols-3 gap-2">
                  <div>
                    <label class="text-[10px] font-bold text-slate-500">X</label>
                    <input id="fix-coord-x" type="number" step="0.001" value="0"
                      class="w-full border rounded px-2 py-1 text-sm text-center">
                  </div>
                  <div>
                    <label class="text-[10px] font-bold text-slate-500">Y</label>
                    <input id="fix-coord-y" type="number" step="0.001" value="0"
                      class="w-full border rounded px-2 py-1 text-sm text-center">
                  </div>
                  <div>
                    <label class="text-[10px] font-bold text-slate-500">Z</label>
                    <input id="fix-coord-z" type="number" step="0.001" value="0"
                      class="w-full border rounded px-2 py-1 text-sm text-center">
                  </div>
                </div>
              </div>

              <!-- Option C: Select from checkpoints -->
              <div class="border rounded p-3"
                onclick="document.querySelector('input[name=fixOption][value=checkpoint]').checked = true">
                <div class="flex items-center">
                  <input type="radio" name="fixOption" value="checkpoint" class="mr-2">
                  <span class="font-bold text-sm text-slate-700">C. Select from Existing Points</span>
                </div>
                <div class="mt-2 ml-5 max-h-24 overflow-auto">
                  <div id="fix-checkpoint-list" class="space-y-1 text-xs"></div>
                </div>
              </div>
            </div>
          </div>
          <div class="bg-slate-100 px-4 py-3 flex justify-end space-x-2 border-t">
            <button onclick="App.Import.closeFixNode()"
              class="px-4 py-2 bg-slate-300 rounded font-bold hover:bg-slate-400">Cancel</button>
            <button onclick="App.Import.applyFixNode()"
              class="px-4 py-2 bg-emerald-600 text-white rounded font-bold hover:bg-emerald-700">
              <i class="fa-solid fa-check mr-1"></i>Apply Fix
            </button>
          </div>
        </div>
      </div>

      <!-- Cursor & Snap Info -->
      <div id="ui-cursor-info"
        class="absolute bottom-2 left-[330px] pointer-events-none text-xs bg-white/90 p-1.5 rounded border border-slate-200 shadow-sm font-mono space-y-0.5 z-20 transition-all duration-300">
        <div id="cursorCoords" class="text-slate-600">0.00, 0.00</div>
        <div id="snapInfo" class="text-eng-magenta font-bold h-4"></div>
        <div class="text-blue-500 italic text-[10px]">Scroll: Zoom | Middle: Pan | Drag: Snap</div>
      </div>

      <!-- Snap & Display Controls -->
      <div
        class="absolute bottom-2 right-2 bg-white/90 p-2 rounded border border-slate-200 shadow-sm w-48 z-20 space-y-2">
        <!-- Grid Rounding Control -->
        <div class="mb-2 border-b border-slate-100 pb-2">
          <div class="flex justify-between items-center mb-1 text-xs font-bold text-slate-600">
            <span><i class="fa-solid fa-border-all mr-1"></i>Grid Rounding</span><span id="grid-val"
              class="text-blue-500">0.05 m</span>
          </div>
          <input type="range" min="0" max="11" step="1" value="2"
            oninput="const v=App.UI.getSliderStep(this.value); App.State.gridStep=v; document.getElementById('grid-val').innerText=v>0?v+' m':'OFF'">
        </div>

        <!-- Snap Control -->
        <div>
          <div class="flex justify-between items-center mb-1 text-xs font-bold text-slate-600">
            <span><i class="fa-solid fa-magnet mr-1"></i>Snap</span><span id="snap-val" class="text-blue-500">0.05
              m</span>
          </div>
          <input type="range" min="0" max="11" step="1" value="2"
            oninput="const v=App.UI.getSliderStep(this.value); App.State.snapStep=v; document.getElementById('snap-val').innerText=v>0?v+' m':'OFF'">
        </div>

        <!-- Show Names Toggle -->
        <div class="flex items-center justify-between">
          <span class="text-xs font-bold text-slate-600"><i class="fa-solid fa-tag mr-1"></i>Names</span>
          <button id="toggleNames"
            onclick="App.State.showNames = !App.State.showNames; this.classList.toggle('bg-blue-500'); this.classList.toggle('text-white'); App.Renderer.draw();"
            class="px-2 py-0.5 text-[10px] font-bold rounded text-slate-500 hover:bg-slate-50">OFF</button>
        </div>
      </div>

      <!-- ELEMENT LIST PANEL (Middle-Left) -->
      <div id="element-list-panel"
        class="absolute left-[330px] top-24 w-36 bg-white/95 rounded border border-slate-200 shadow-sm z-20 max-h-[85vh] overflow-hidden flex flex-col transition-all duration-300">
        <div
          class="bg-slate-100 px-2 py-1 text-[10px] font-bold text-slate-600 border-b flex justify-between items-center">
          <span><i class="fa-solid fa-layer-group mr-1"></i>Elements</span>
          <span id="element-count" class="text-slate-400">0</span>
        </div>
        <div class="overflow-y-auto max-h-[525px] text-[10px]" id="element-list-content">
          <!-- Dynamic content -->
        </div>
      </div>

      <!-- SELECTED ELEMENTS PANEL (Bottom-Center) - DRAGGABLE -->
      <div id="selection-panel"
        class="absolute bottom-36 left-1/2 -translate-x-1/2 bg-white/95 rounded border border-slate-200 shadow-md z-20 hidden"
        style="transform: translate(-50%, 0);">
        <div id="selection-panel-header"
          class="bg-amber-100 px-2 py-1 text-[10px] font-bold text-amber-700 border-b flex justify-between items-center cursor-move select-none"
          onmousedown="App.UI.startDragPanel(event, 'selection-panel')">
          <span><i class="fa-solid fa-grip-vertical mr-1 text-amber-400"></i><i
              class="fa-solid fa-check-square mr-1"></i>Selected (<span id="selected-count">0</span>)</span>
          <div class="flex space-x-1">
            <button onclick="event.stopPropagation();App.Actions.filterSelection('block')"
              class="px-1 hover:bg-amber-200 rounded" title="Filter Blocks"><i class="fa-solid fa-cube"></i></button>
            <button onclick="event.stopPropagation();App.Actions.filterSelection('pile')"
              class="px-1 hover:bg-amber-200 rounded" title="Filter Piles"><i class="fa-solid fa-circle"></i></button>
            <button onclick="event.stopPropagation();App.Actions.filterSelection('machine')"
              class="px-1 hover:bg-amber-200 rounded" title="Filter Machines"><i class="fa-solid fa-cogs"></i></button>
            <button onclick="event.stopPropagation();App.Actions.filterSelection('point')"
              class="px-1 hover:bg-amber-200 rounded" title="Filter Points"><i
                class="fa-solid fa-crosshairs"></i></button>
            <button onclick="event.stopPropagation();App.Actions.filterSelection('load')"
              class="px-1 hover:bg-amber-200 rounded" title="Filter Loads"><i class="fa-solid fa-bullseye"></i></button>
            <button onclick="event.stopPropagation();App.Actions.filterSelection('assembly')"
              class="px-1 hover:bg-purple-200 text-purple-600 rounded" title="Filter Assemblies"><i
                class="fa-solid fa-layer-group"></i></button>
            <button onclick="event.stopPropagation();App.State.clearSelection()"
              class="px-1 hover:bg-red-200 text-red-500 rounded" title="Close / Clear Selection"><i
                class="fa-solid fa-times"></i></button>
          </div>
        </div>
        <div class="flex flex-wrap gap-1 p-1 max-w-md max-h-40 overflow-y-auto" id="selected-list-content">
          <!-- Dynamic content -->
        </div>
      </div>

      <!-- PROPERTIES PANEL (Middle-Right) -->
      <div id="props-panel"
        class="absolute right-2 top-24 w-48 bg-white/95 rounded border border-slate-200 shadow-sm z-20 hidden">
        <div
          class="bg-blue-100 px-2 py-1 text-[10px] font-bold text-blue-700 border-b flex justify-between items-center">
          <span><i class="fa-solid fa-sliders mr-1"></i>Properties</span>
          <span id="props-type" class="text-blue-500"></span>
        </div>
        <div class="p-2 space-y-1 text-[10px]" id="props-content">
          <!-- Dynamic properties -->
        </div>
      </div>

      <!-- Audit Panel (Top-Right of Canvas) -->
      <div id="audit-panel"
        class="absolute top-2 right-2 z-30 text-right text-[11px] font-bold pointer-events-none max-w-sm">
        <div id="audit-errors" class="text-red-600 whitespace-pre-line"></div>
        <div id="audit-warnings" class="text-amber-500 whitespace-pre-line"></div>
      </div>

      <!-- VIEW LOCK BUTTONS (Bottom-Center of Canvas) -->
      <div id="view-lock-panel"
        class="absolute bottom-4 left-1/2 -translate-x-1/2 z-40 bg-white rounded-lg border border-slate-300 shadow-md px-2 py-1 flex flex-row space-x-1">
        <button id="btn-lock-model" onclick="App.State.toggleLock('model')"
          class="w-7 h-7 rounded text-[11px] hover:bg-slate-100 flex items-center justify-center"
          title="Lock Model - Disable all interactions">
          <i class="fa-solid fa-lock text-slate-400"></i>
        </button>
        <button id="btn-lock-drag" onclick="App.State.toggleLock('drag')"
          class="w-7 h-7 rounded text-[11px] hover:bg-slate-100 flex items-center justify-center"
          title="Lock Drag - Disable object dragging">
          <i class="fa-solid fa-hand text-slate-400"></i>
        </button>
        <button id="btn-isolate" onclick="App.State.toggleLock('isolate')"
          class="w-7 h-7 rounded text-[11px] hover:bg-slate-100 flex items-center justify-center"
          title="Isolate - Show only selected objects">
          <i class="fa-solid fa-magnifying-glass text-slate-400"></i>
        </button>
        <button id="btn-hide" onclick="App.State.hideSelected()"
          class="w-7 h-7 rounded text-[11px] hover:bg-slate-100 flex items-center justify-center"
          title="Hide - Hide selected objects">
          <i class="fa-solid fa-eye-slash text-slate-400"></i>
        </button>
        <button id="btn-show-all" onclick="App.State.showAllObjects()"
          class="w-7 h-7 rounded text-[11px] hover:bg-slate-100 flex items-center justify-center"
          title="Show All Objects">
          <i class="fa-solid fa-eye text-slate-400"></i>
        </button>
        <button id="btn-lock-rotate" onclick="App.State.toggleLock('rotate')"
          class="w-7 h-7 rounded text-[11px] hover:bg-slate-100 flex items-center justify-center"
          title="Lock Rotate - Disable 3D rotation">
          <i class="fa-solid fa-arrows-rotate text-slate-400"></i>
        </button>
        <button id="btn-toggle-grid"
          onclick="App.State.showGrid = !App.State.showGrid; App.State.updateLockButtons(); App.Renderer.draw();"
          class="w-7 h-7 rounded text-[11px] hover:bg-slate-100 flex items-center justify-center"
          title="Toggle Grid Display">
          <i class="fa-solid fa-border-all text-slate-400"></i>
        </button>
      </div>

    </div>
  </div>

  <!-- EDIT MODAL -->
  <div id="editModal" class="modal opacity-0 pointer-events-none fixed inset-0 flex items-center justify-center z-[60]">
    <div class="absolute inset-0 bg-slate-900/40 backdrop-blur-[1px]" onclick="App.UI.closeModal()"></div>
    <div class="bg-white w-80 rounded shadow-2xl z-10 overflow-hidden transform scale-95 transition-all">
      <div class="bg-slate-900 text-white px-3 py-2 flex justify-between items-center text-sm font-bold">
        <span>Edit Block</span><button onclick="App.UI.closeModal()" class="hover:text-red-400"><i
            class="fa-solid fa-times"></i></button>
      </div>
      <div class="p-3 space-y-3 text-xs">
        <input type="hidden" id="editId">
        <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Name</label><input id="editName" type="text"
            class="w-full border rounded px-1 py-1 font-bold"></div>
        <div class="grid grid-cols-3 gap-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">L</label><input id="editL" type="number"
              class="w-full border rounded px-1 py-1" step="0.1"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">W</label><input id="editW" type="number"
              class="w-full border rounded px-1 py-1" step="0.1"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">H</label><input id="editH" type="number"
              class="w-full border rounded px-1 py-1" step="0.1"></div>
        </div>
        <div class="grid grid-cols-3 gap-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">X</label><input id="editX" type="number"
              class="w-full border rounded px-1 py-1" step="0.1"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Y</label><input id="editY" type="number"
              class="w-full border rounded px-1 py-1" step="0.1"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Z</label><input id="editZ" type="number"
              class="w-full border rounded px-1 py-1" step="0.1"></div>
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2">
          <div><label class="text-[10px] font-bold text-slate-500">Density (kN/m³)</label><input id="editDensity"
              type="number" step="0.01" class="w-full border rounded px-1 text-xs"></div>
          <div class="flex items-end pb-1">
            <div class="flex items-center space-x-2">
              <input id="editOp" type="checkbox"
                class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
              <label for="editOp" class="text-xs font-bold text-slate-600">Subtract (Void)</label>
            </div>
          </div>
        </div>
        <button onclick="App.Actions.saveEdit()"
          class="w-full bg-slate-900 text-white py-2 rounded font-bold hover:bg-slate-800">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- MACHINE EDIT MODAL -->
  <div id="machineModal"
    class="modal opacity-0 pointer-events-none fixed inset-0 flex items-center justify-center z-[60]">
    <div class="absolute inset-0 bg-slate-900/40 backdrop-blur-[1px]" onclick="App.UI.closeMachineModal()"></div>
    <div class="bg-white w-80 rounded shadow-2xl z-10 overflow-hidden transform scale-95 transition-all">
      <div class="bg-purple-600 text-white px-3 py-2 flex justify-between items-center text-sm font-bold">
        <span><i class="fa-solid fa-cogs mr-1"></i> Edit Machine</span><button onclick="App.UI.closeMachineModal()"
          class="hover:text-red-300"><i class="fa-solid fa-times"></i></button>
      </div>
      <div class="p-3 space-y-3 text-xs">
        <input type="hidden" id="editMachineId">
        <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Name</label><input id="editMachineName"
            type="text" class="w-full border rounded px-1 py-1 font-bold"></div>
        <div class="grid grid-cols-2 gap-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Weight (kN)</label><input
              id="editMachineW" type="number" class="w-full border rounded px-1 py-1" step="0.001"></div>
          <div><label class="text-[10px] font-bold text-purple-500 block mb-1">Rotation (°)</label><input
              id="editMachineRot" type="number" class="w-full border rounded px-1 py-1 border-purple-300" step="15">
          </div>
        </div>
        <div class="grid grid-cols-3 gap-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">X</label><input id="editMachineX"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Y</label><input id="editMachineY"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Z</label><input id="editMachineZ"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
        </div>
        <!-- Inertia Row -->
        <div class="grid grid-cols-3 gap-2 mt-1">
          <div><label class="text-[10px] font-bold text-blue-500 block mb-1">Ix (T·m²)</label><input id="editMachineIx"
              type="number" class="w-full border rounded px-1 py-1 border-blue-300" step="0.001"></div>
          <div><label class="text-[10px] font-bold text-blue-500 block mb-1">Iy (T·m²)</label><input id="editMachineIy"
              type="number" class="w-full border rounded px-1 py-1 border-blue-300" step="0.001"></div>
          <div><label class="text-[10px] font-bold text-blue-500 block mb-1">Iz (T·m²)</label><input id="editMachineIz"
              type="number" class="w-full border rounded px-1 py-1 border-blue-300" step="0.001"></div>
        </div>
        <button onclick="App.Actions.saveMachineEdit()"
          class="w-full bg-purple-600 text-white py-2 rounded font-bold hover:bg-purple-700">Save Machine</button>
      </div>
    </div>
  </div>

  <!-- POINT EDIT MODAL -->
  <div id="pointModal"
    class="modal opacity-0 pointer-events-none fixed inset-0 flex items-center justify-center z-[60]">
    <div class="absolute inset-0 bg-slate-900/40 backdrop-blur-[1px]" onclick="App.UI.closePointModal()"></div>
    <div class="bg-white w-80 rounded shadow-2xl z-10 overflow-hidden transform scale-95 transition-all">
      <div class="bg-red-600 text-white px-3 py-2 flex justify-between items-center text-sm font-bold">
        <span><i class="fa-solid fa-crosshairs mr-1"></i> Edit Point</span><button onclick="App.UI.closePointModal()"
          class="hover:text-red-300"><i class="fa-solid fa-times"></i></button>
      </div>
      <div class="p-3 space-y-3 text-xs">
        <input type="hidden" id="editPointId">
        <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Name</label><input id="editPointName"
            type="text" class="w-full border rounded px-1 py-1 font-bold"></div>
        <div class="grid grid-cols-3 gap-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">X (m)</label><input id="editPointX"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Y (m)</label><input id="editPointY"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Z (m)</label><input id="editPointZ"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2 border-t pt-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Host Type</label>
            <select id="editPointHostType" class="w-full border rounded px-1 py-1">
              <option value="">None</option>
              <option value="block">Block</option>
              <option value="pile">Pile</option>
            </select>
          </div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Host ID</label>
            <input id="editPointHostId" type="text" class="w-full border rounded px-1 py-1">
          </div>
        </div>
        <button onclick="App.Actions.savePointEdit()"
          class="w-full bg-red-600 text-white py-2 rounded font-bold hover:bg-red-700">Save Point</button>
      </div>
    </div>
  </div>

  <!-- LOAD EDIT MODAL -->
  <div id="loadModal" class="modal opacity-0 pointer-events-none fixed inset-0 flex items-center justify-center z-[60]">
    <div class="absolute inset-0 bg-slate-900/40 backdrop-blur-[1px]" onclick="App.UI.closeLoadModal()"></div>
    <div class="bg-white w-96 rounded shadow-2xl z-10 overflow-hidden transform scale-95 transition-all">
      <div class="bg-red-600 text-white px-3 py-2 flex justify-between items-center text-sm font-bold">
        <span><i class="fa-solid fa-bullseye mr-1"></i> Edit Load Point</span><button onclick="App.UI.closeLoadModal()"
          class="hover:text-red-300"><i class="fa-solid fa-times"></i></button>
      </div>
      <div class="p-3 space-y-2 text-xs max-h-[70vh] overflow-y-auto">
        <input type="hidden" id="editLoadId">
        <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Name</label><input id="editLoadName"
            type="text" class="w-full border rounded px-1 py-1 font-bold"></div>
        <div class="grid grid-cols-3 gap-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">X (m)</label><input id="editLoadX"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Y (m)</label><input id="editLoadY"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Z (m)</label><input id="editLoadZ"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
        </div>
        <div class="border-t pt-2 mt-2">
          <h4 class="text-red-600 font-bold text-[10px] mb-1">Primary Forces (kN/kNm)</h4>
          <div class="grid grid-cols-3 gap-2">
            <div><label class="text-[10px] text-red-500">Fx</label><input id="editLoadFx" type="number"
                class="w-full border rounded px-1 py-1 border-red-200" step="0.1"></div>
            <div><label class="text-[10px] text-green-500">Fy</label><input id="editLoadFy" type="number"
                class="w-full border rounded px-1 py-1 border-green-200" step="0.1"></div>
            <div><label class="text-[10px] text-blue-500">Fz</label><input id="editLoadFz" type="number"
                class="w-full border rounded px-1 py-1 border-blue-200" step="0.1"></div>
          </div>
          <div class="grid grid-cols-3 gap-2 mt-1">
            <div><label class="text-[10px] text-slate-500">Mx</label><input id="editLoadMx" type="number"
                class="w-full border rounded px-1 py-1" step="0.1"></div>
            <div><label class="text-[10px] text-slate-500">My</label><input id="editLoadMy" type="number"
                class="w-full border rounded px-1 py-1" step="0.1"></div>
            <div><label class="text-[10px] text-slate-500">Mz</label><input id="editLoadMz" type="number"
                class="w-full border rounded px-1 py-1" step="0.1"></div>
          </div>
        </div>
        <div id="loadSecondarySection" class="border-t pt-2 mt-2 hidden">
          <h4 class="text-orange-600 font-bold text-[10px] mb-1">Secondary Forces (Type R only)</h4>
          <div class="grid grid-cols-3 gap-2">
            <div><label class="text-[10px] text-red-400">Fx2</label><input id="editLoadFx2" type="number"
                class="w-full border rounded px-1 py-1 border-dashed" step="0.1"></div>
            <div><label class="text-[10px] text-green-400">Fy2</label><input id="editLoadFy2" type="number"
                class="w-full border rounded px-1 py-1 border-dashed" step="0.1"></div>
            <div><label class="text-[10px] text-blue-400">Fz2</label><input id="editLoadFz2" type="number"
                class="w-full border rounded px-1 py-1 border-dashed" step="0.1"></div>
          </div>
          <div class="grid grid-cols-3 gap-2 mt-1">
            <div><label class="text-[10px] text-slate-400">Mx2</label><input id="editLoadMx2" type="number"
                class="w-full border rounded px-1 py-1 border-dashed" step="0.1"></div>
            <div><label class="text-[10px] text-slate-400">My2</label><input id="editLoadMy2" type="number"
                class="w-full border rounded px-1 py-1 border-dashed" step="0.1"></div>
            <div><label class="text-[10px] text-slate-400">Mz2</label><input id="editLoadMz2" type="number"
                class="w-full border rounded px-1 py-1 border-dashed" step="0.1"></div>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2 border-t pt-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Type</label>
            <select id="editLoadType" class="w-full border rounded px-1 py-1"
              onchange="document.getElementById('loadSecondarySection').classList.toggle('hidden', this.value !== 'R')">
              <option value="C">C (Centrifugal)</option>
              <option value="R">R (Reciprocating)</option>
            </select>
          </div>
          <div class="col-span-1"></div>
        </div>
        <div class="grid grid-cols-2 gap-2 mt-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Host Type</label>
            <select id="editLoadHostType" class="w-full border rounded px-1 py-1">
              <option value="">None</option>
              <option value="block">Block</option>
              <option value="machine">Machine</option>
            </select>
          </div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Host ID #</label>
            <input id="editLoadHostId" type="number" class="w-full border rounded px-1 py-1"
              placeholder="e.g. 1, 2, 3...">
          </div>
        </div>
        <button onclick="App.Actions.saveLoadEdit()"
          class="w-full bg-red-600 text-white py-2 rounded font-bold hover:bg-red-700 mt-2">Save Load</button>
      </div>
    </div>
  </div>

  <!-- PILE EDIT MODAL (UPDATED) -->
  <div id="pileModal" class="modal opacity-0 pointer-events-none fixed inset-0 flex items-center justify-center z-[60]">
    <div class="absolute inset-0 bg-slate-900/40 backdrop-blur-[1px]" onclick="App.UI.closePileModal()"></div>
    <div class="bg-white w-80 rounded shadow-2xl z-10 overflow-hidden transform scale-95 transition-all">
      <div class="bg-green-600 text-white px-3 py-2 flex justify-between items-center text-sm font-bold">
        <span><i class="fa-solid fa-circle mr-1"></i> Edit Pile</span><button onclick="App.UI.closePileModal()"
          class="hover:text-red-300"><i class="fa-solid fa-times"></i></button>
      </div>
      <div class="p-3 space-y-3 text-xs">
        <input type="hidden" id="editPileId">
        <div><label class="text-[10px] font-bold text-green-600 block mb-1">Name</label>
          <input id="editPileName" type="text" class="w-full border rounded px-1 py-1 border-green-300"
            placeholder="Pile Name">
        </div>
        <div class="grid grid-cols-3 gap-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">X (m)</label><input id="editPileX"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Y (m)</label><input id="editPileY"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Z (m)</label><input id="editPileZ"
              type="number" class="w-full border rounded px-1 py-1" step="0.01"></div>
        </div>
        <div class="grid grid-cols-2 gap-2">
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Shape</label>
            <select id="editPileShape" class="w-full border rounded px-1 py-1">
              <option value="round">Round</option>
              <option value="square">Square</option>
            </select>
          </div>
          <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Size (D/a)</label><input id="editPileSize"
              type="number" class="w-full border rounded px-1 py-1" step="0.05"></div>
        </div>
        <div><label class="text-[10px] font-bold text-slate-500 block mb-1">Length (m)</label><input id="editPileLen"
            type="number" class="w-full border rounded px-1 py-1" step="0.1"></div>
        <div class="grid grid-cols-2 gap-2">
          <div><label class="text-[10px] font-bold text-green-600 block mb-1">Kv (kN/m)</label><input id="editPileKv"
              type="number" class="w-full border rounded px-1 py-1 border-green-300" step="1000"></div>
          <div><label class="text-[10px] font-bold text-green-600 block mb-1">Kh (kN/m)</label><input id="editPileKh"
              type="number" class="w-full border rounded px-1 py-1 border-green-300" step="1000"></div>
        </div>
        <button onclick="App.Actions.savePileEdit()"
          class="w-full bg-green-600 text-white py-2 rounded font-bold hover:bg-green-700">Save Pile</button>
      </div>
    </div>

    <!-- EXPORT POPUP (WCVL Wizard) -->
    <div id="exportPopup"
      class="modal opacity-0 pointer-events-none fixed inset-0 flex items-center justify-center z-[70]">
      <div class="absolute inset-0 bg-slate-900/50 backdrop-blur-[2px]" onclick="App.Export.close()"></div>
      <div class="relative bg-white rounded-lg shadow-xl w-[700px] max-h-[85vh] overflow-hidden flex flex-col">
        <div
          class="bg-gradient-to-r from-fuchsia-600 to-purple-600 px-4 py-2 flex justify-between items-center text-white">
          <span class="font-bold"><i class="fa-solid fa-file-export mr-2"></i>Export WCVL Input File</span>
          <div class="flex items-center space-x-2">
            <span id="export-step-indicator" class="text-fuchsia-200 text-sm">Step 1/3</span>
            <button onclick="App.Export.close()" class="hover:text-fuchsia-200"><i
                class="fa-solid fa-times"></i></button>
          </div>
        </div>
        <!-- Step 1: Info & Audit -->
        <div id="export-step-1" class="p-4 space-y-3 overflow-y-auto flex-grow">
          <div class="grid grid-cols-2 gap-4">
            <div class="bg-slate-50 p-3 rounded border">
              <h3 class="font-bold text-slate-700 mb-2"><i class="fa-solid fa-info-circle mr-1"></i>Model Summary</h3>
              <div id="export-summary" class="text-sm space-y-1"></div>
            </div>
            <div class="bg-fuchsia-50 p-3 rounded border border-fuchsia-200">
              <h3 class="font-bold text-fuchsia-700 mb-2"><i class="fa-solid fa-exclamation-triangle mr-1"></i>Audit
              </h3>
              <div id="export-audit" class="text-sm text-fuchsia-600"></div>
            </div>
          </div>
          <div class="bg-blue-50 p-3 rounded border border-blue-200">
            <h3 class="font-bold text-blue-700 mb-2"><i class="fa-solid fa-crosshairs mr-1"></i>Coordinate Origin</h3>
            <div class="flex items-center space-x-4">
              <label class="flex items-center space-x-2 cursor-pointer">
                <input type="radio" name="coord-origin" value="real" checked class="w-4 h-4">
                <span class="text-sm">Real (Current model coordinates)</span>
              </label>
              <label class="flex items-center space-x-2 cursor-pointer">
                <input type="radio" name="coord-origin" value="custom" class="w-4 h-4">
                <span class="text-sm">Custom origin offset</span>
              </label>
            </div>
            <div id="coord-offset-inputs" class="hidden mt-2 grid grid-cols-3 gap-2">
              <div><label class="text-[10px] text-blue-600">Offset X</label><input type="number" id="offset-x" value="0"
                  class="w-full border rounded px-1 text-sm" step="0.1"></div>
              <div><label class="text-[10px] text-blue-600">Offset Y</label><input type="number" id="offset-y" value="0"
                  class="w-full border rounded px-1 text-sm" step="0.1"></div>
              <div><label class="text-[10px] text-blue-600">Offset Z</label><input type="number" id="offset-z" value="0"
                  class="w-full border rounded px-1 text-sm" step="0.1"></div>
            </div>
          </div>
        </div>
        <!-- Step 2: Mapping -->
        <div id="export-step-2" class="hidden p-4 overflow-y-auto flex-grow">
          <h3 class="font-bold text-slate-700 mb-2"><i class="fa-solid fa-map mr-1"></i>Data Mapping Details</h3>
          <div id="export-mapping"
            class="text-xs font-mono bg-slate-50 p-3 rounded border max-h-[400px] overflow-y-auto whitespace-pre-wrap">
          </div>
        </div>
        <!-- Step 3: Output -->
        <div id="export-step-3" class="hidden p-4 overflow-y-auto flex-grow">
          <h3 class="font-bold text-slate-700 mb-2"><i class="fa-solid fa-code mr-1"></i>WCVL Output (Copy below)</h3>
          <textarea id="export-output"
            class="w-full h-64 text-xs font-mono bg-slate-900 text-green-400 p-3 rounded border" readonly></textarea>
          <button onclick="App.Export.copyOutput()"
            class="mt-2 bg-green-600 text-white px-4 py-2 rounded font-bold hover:bg-green-700">
            <i class="fa-solid fa-copy mr-1"></i>Copy All
          </button>
        </div>
        <!-- Navigation -->
        <div class="bg-slate-100 px-4 py-3 flex justify-between border-t">
          <button id="export-prev-btn" onclick="App.Export.prev()"
            class="hidden px-4 py-2 bg-slate-300 text-slate-700 rounded font-bold hover:bg-slate-400">
            <i class="fa-solid fa-arrow-left mr-1"></i>Back
          </button>
          <div></div>
          <button id="export-next-btn" onclick="App.Export.next()"
            class="px-4 py-2 bg-fuchsia-600 text-white rounded font-bold hover:bg-fuchsia-700">
            Next<i class="fa-solid fa-arrow-right ml-1"></i>
          </button>
        </div>
      </div>
    </div>

    <!-- IMPORT POPUP (WCVL Parser) -->
    <div id="importPopup"
      class="modal opacity-0 pointer-events-none fixed inset-0 flex items-center justify-center z-[70]">
      <div class="absolute inset-0 bg-slate-900/50 backdrop-blur-[2px]" onclick="App.Import.close()"></div>
      <div class="relative bg-white rounded-lg shadow-xl w-[600px] max-h-[80vh] overflow-hidden">
        <div class="bg-gradient-to-r from-blue-600 to-cyan-600 px-4 py-2 flex justify-between items-center text-white">
          <span class="font-bold"><i class="fa-solid fa-file-import mr-2"></i>Import WCVL Input File</span>
          <button onclick="App.Import.close()" class="hover:text-blue-200"><i class="fa-solid fa-times"></i></button>
        </div>
        <div class="p-4 space-y-3">
          <p class="text-sm text-slate-600">Paste WCVL input file content below:</p>
          <textarea id="import-text" class="w-full h-48 text-xs font-mono bg-slate-50 p-3 rounded border" placeholder="PILE
Project_Name
CCAI M
23.544 9.81 280 0.25 0.25 0.25 0.25
..."></textarea>
          <div id="import-log" class="text-xs text-purple-600 max-h-20 overflow-y-auto"></div>
        </div>
        <div class="bg-slate-100 px-4 py-3 flex justify-end space-x-2 border-t">
          <button onclick="App.Import.close()"
            class="px-4 py-2 bg-slate-300 text-slate-700 rounded font-bold hover:bg-slate-400">Cancel</button>
          <button onclick="App.Import.parse()"
            class="px-4 py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700">
            <i class="fa-solid fa-download mr-1"></i>Import
          </button>
        </div>
      </div>
    </div>

    <!-- CAP TYPE A (ARBITRARY) MODAL -->
    <div id="capAModal" class="hidden fixed inset-0 flex items-center justify-center z-[80]">
      <div class="absolute inset-0 bg-slate-900/50 backdrop-blur-[2px]"
        onclick="document.getElementById('capAModal').classList.add('hidden')"></div>
      <div class="relative bg-white rounded-lg shadow-xl w-[400px] overflow-hidden">
        <div
          class="bg-gradient-to-r from-amber-500 to-orange-500 px-4 py-2 flex justify-between items-center text-white">
          <span class="font-bold"><i class="fa-solid fa-sliders mr-2"></i>Arbitrary Cap Parameters</span>
          <button onclick="document.getElementById('capAModal').classList.add('hidden')" class="hover:text-amber-200"><i
              class="fa-solid fa-times"></i></button>
        </div>
        <div class="p-4 space-y-3">
          <p class="text-xs text-slate-500">Enter foundation properties directly (Cap Type A)</p>
          <div class="grid grid-cols-2 gap-2">
            <div><label class="text-[10px] font-bold text-slate-500">Weight (kN)</label>
              <input id="capA-Weight" type="number" step="0.01" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.capAParams.Weight = parseFloat(this.value); App.State.notify();">
            </div>
            <div><label class="text-[10px] font-bold text-slate-500">Cx (m)</label>
              <input id="capA-Cx" type="number" step="0.01" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.capAParams.Cx = parseFloat(this.value); App.State.notify();">
            </div>
          </div>
          <div class="grid grid-cols-3 gap-2">
            <div><label class="text-[10px] font-bold text-slate-500">Ixx</label>
              <input id="capA-Ixx" type="number" step="0.01" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.capAParams.Ixx = parseFloat(this.value); App.State.notify();">
            </div>
            <div><label class="text-[10px] font-bold text-slate-500">Iyy</label>
              <input id="capA-Iyy" type="number" step="0.01" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.capAParams.Iyy = parseFloat(this.value); App.State.notify();">
            </div>
            <div><label class="text-[10px] font-bold text-slate-500">Izz</label>
              <input id="capA-Izz" type="number" step="0.01" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.capAParams.Izz = parseFloat(this.value); App.State.notify();">
            </div>
          </div>
          <div class="grid grid-cols-3 gap-2">
            <div><label class="text-[10px] font-bold text-slate-500">Cy (m)</label>
              <input id="capA-Cy" type="number" step="0.01" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.capAParams.Cy = parseFloat(this.value); App.State.notify();">
            </div>
            <div><label class="text-[10px] font-bold text-slate-500">Cz (m)</label>
              <input id="capA-Cz" type="number" step="0.01" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.capAParams.Cz = parseFloat(this.value); App.State.notify();">
            </div>
            <div></div>
          </div>
        </div>
        <div class="bg-slate-100 px-4 py-3 flex justify-end border-t">
          <button onclick="document.getElementById('capAModal').classList.add('hidden')"
            class="px-4 py-2 bg-amber-600 text-white rounded font-bold hover:bg-amber-700">
            <i class="fa-solid fa-check mr-1"></i>Save
          </button>
        </div>
      </div>
    </div>

    <!-- STIFFNESS C (COMPUTED) MODAL -->
    <div id="stiffCModal" class="hidden fixed inset-0 flex items-center justify-center z-[80]">
      <div class="absolute inset-0 bg-slate-900/50 backdrop-blur-[2px]"
        onclick="document.getElementById('stiffCModal').classList.add('hidden')"></div>
      <div class="relative bg-white rounded-lg shadow-xl w-[350px] overflow-hidden">
        <div class="bg-gradient-to-r from-teal-500 to-cyan-500 px-4 py-2 flex justify-between items-center text-white">
          <span class="font-bold"><i class="fa-solid fa-calculator mr-2"></i>Computed Stiffness Parameters</span>
          <button onclick="document.getElementById('stiffCModal').classList.add('hidden')"
            class="hover:text-teal-200"><i class="fa-solid fa-times"></i></button>
        </div>
        <div class="p-4 space-y-3">
          <p class="text-xs text-slate-500">Pile properties for stiffness computation (Stiffness=C)</p>
          <div class="grid grid-cols-2 gap-2">
            <div><label class="text-[10px] font-bold text-slate-500">D - Diameter (m)</label>
              <input id="stiffC-D" type="number" value="0.4" step="0.01" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.stiffnessCParams.D = parseFloat(this.value); App.State.notify();">
            </div>
            <div><label class="text-[10px] font-bold text-slate-500">L - Length (m)</label>
              <input id="stiffC-L" type="number" value="15" step="1" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.stiffnessCParams.L = parseFloat(this.value); App.State.notify();">
            </div>
          </div>
          <div class="grid grid-cols-2 gap-2">
            <div><label class="text-[10px] font-bold text-slate-500">Es - Soil Modulus (kN/m²)</label>
              <input id="stiffC-Es" type="number" value="30000" step="1000" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.stiffnessCParams.Es = parseFloat(this.value); App.State.notify();">
            </div>
            <div><label class="text-[10px] font-bold text-slate-500">f - Factor</label>
              <input id="stiffC-f" type="number" value="1.0" step="0.1" class="w-full border rounded px-1 text-xs"
                onchange="App.State.params.stiffnessCParams.f = parseFloat(this.value); App.State.notify();">
            </div>
          </div>
        </div>
        <div class="bg-slate-100 px-4 py-3 flex justify-end border-t">
          <button onclick="document.getElementById('stiffCModal').classList.add('hidden')"
            class="px-4 py-2 bg-teal-600 text-white rounded font-bold hover:bg-teal-700">
            <i class="fa-solid fa-check mr-1"></i>Save
          </button>
        </div>
      </div>
    </div>

    <!-- JAVASCRIPT LOGIC -->
    <script>
      const App = {
        State: {
          blocks: [{ id: 'init', name: 'Base', L: 5, W: 3, H: 1, X: 0, Y: 0, Z: 0, density: 24, op: 1 }],
          piles: [
            { id: 'p1', X: -2.5, Y: -1.5, Z: 0, Kv: 0, Kh: 0, shape: 'round', size: 0.4, length: 15 },
            { id: 'p2', X: 2.5, Y: -1.5, Z: 0, Kv: 0, Kh: 0, shape: 'round', size: 0.4, length: 15 },
            { id: 'p3', X: -2.5, Y: 1.5, Z: 0, Kv: 0, Kh: 0, shape: 'round', size: 0.4, length: 15 },
            { id: 'p4', X: 2.5, Y: 1.5, Z: 0, Kv: 0, Kh: 0, shape: 'round', size: 0.4, length: 15 }
          ],
          points: [], // Check Points
          machines: [],
          assemblies: [], // Machine Assembly objects (annotative, not used in calculations)
          showAssemblies: true, // Toggle visibility of assembly annotations
          showNames: true,
          clipboard: null,
          projectInfo: {
            jobName: "",
            machineType: "C", capType: "C", arrangement: "A", stiffness: "I", pileHead: " ", unit: "M"
          },
          // Load Points Array - each load is a draggable object with forces
          loadPoints: [],
          // Global loads settings (freq shared across all)
          loadsConfig: { freq: 3000 },
          // Static/Wind Loads for foundation checks
          staticLoads: {
            WindX: 0,     // kN
            WindY: 0,     // kN
            WindArmZ: 0   // m (moment arm for overturning)
          },
          params: {
            gravity: 9.81,
            concreteDensity: 23.544,
            concreteStrength: 280,
            dampingZ: 0.25,
            dampingX: 0.25,
            dampingRock: 0.25,
            dampingTor: 0.25,
            unit: 'm',
            pileDrawMode: 'representative',
            defaultKv: 0,
            defaultKh: 0,
            // Legacy aliases
            dampingRatio: 0.25,
            dampingRatioX: 0.25,
            // Unit defaults
            gravityMetric: 9.81,
            gravityEnglish: 32.2,
            // Global pile stiffness (Legacy export)
            globalKv: 0,
            globalKh: 0,
            stiffnessStrategy: 'global', // global, first, average, max, min
            zBottomOverride: null, // null = auto from min block Z
            // Cap Type A (Arbitrary) parameters
            capAParams: {
              Weight: 0, // kN (total weight of foundation)
              Ixx: 0, Iyy: 0, Izz: 0, // Mass moment of inertia
              Cx: 0, Cy: 0, Cz: 0 // Center of gravity
            },
            // Stiffness C (Computed) parameters
            stiffnessCParams: {
              D: 0.4, // Pile diameter (m)
              L: 15, // Pile length (m)
              Es: 30000, // Soil modulus (kN/m2)
              f: 1.0 // Factor
            },
            // === FOUNDATION CHECK PARAMETERS ===
            // Pile Capacity Limits (from Geotech Report)
            pileCapacity: {
              compression: 2500, // kN
              tension: 500,      // kN
              lateral: 100       // kN
            },
            // ISO 10816 Vibration Limits
            limits: {
              displacement: 25,  // μm
              velocity: 4.5,     // mm/s (Class II default)
              acceleration: 0.5  // m/s²
            },
            isoClass: 'II', // ISO 10816 Machine Class: I, II, III, IV
            // ACI 351.3R Static Checks
            massRatioMin: 3,        // ≥3 for Centrifugal, ≥5 for Reciprocating
            eccentricityLimit: 5,   // % of dimension
            // DIN 4024 Frequency Tuning
            dinZonePercent: 20,     // ±20% avoidance zone
            din2xHarmonic: false    // Check 2x harmonic for reciprocating
          },
          viewMode: 'XY',
          selection: { type: null, id: null },
          selectedIds: [], // Multi-select: [{type, id}, ...]
          snapStep: 0.1,
          gridStep: 0.05, // Grid Rounding Step (0 = OFF)
          showGrid: true, // Show grid lines on canvas
          showNames: true,
          filters: { point: true, machine: true, load: true, block: true, pile: true }, // Filter state
          clipboard: null,
          lastClicked: { type: null, index: -1 }, // Shift-select tracking
          // Enable/View Control Flags (true = feature enabled, false = disabled)
          enableModel: true,   // Enable all interactions (default ON)
          enableDrag: true,    // Enable object dragging (default ON)
          enableRotate: true,  // Enable 3D rotation (default ON)
          isolatedIds: null,   // Array of {type, id} to isolate, null = show all
          hiddenIds: [],        // Array of {type, id} that are hidden
          listeners: [],

          subscribe(fn) { this.listeners.push(fn); },
          notify(hist = true) {
            const actualChange = hist ? App.History.push() : false;
            this.listeners.forEach(fn => fn());
            // Refresh audit panel
            if (typeof App !== 'undefined' && App.Audit) {
              const audit = App.Audit.run();
              const errEl = document.getElementById('audit-errors-top');
              const warnEl = document.getElementById('audit-warnings-top');
              if (errEl) errEl.innerText = audit.errors.join('\n');
              if (warnEl) warnEl.innerText = audit.warnings.join('\n');
            }
            // Reset sweep status badge only when ACTUAL model change occurred
            if (actualChange && typeof App !== 'undefined' && App.UI && App.UI.sweepData) {
              const badge = document.getElementById('res-status-badge');
              if (badge) {
                badge.innerText = 'Need run again';
                badge.className = 'text-[10px] bg-amber-100 text-amber-700 px-2 py-0.5 rounded-full font-bold';
              }
            }
            // === UI SYNC: Keep inputs in sync with state ===
            const params = this.params;
            const projectInfo = this.projectInfo;
            const loadsConfig = this.loadsConfig;
            const $ = id => document.getElementById(id);

            // Piles Panel - Global Stiffness
            if ($('global-Kv')) $('global-Kv').value = params.globalKv || 0;
            if ($('global-Kh')) $('global-Kh').value = params.globalKh || 0;
            if ($('stiffness-strategy')) $('stiffness-strategy').value = params.stiffnessStrategy || 'global';
            if ($('zBottom-override')) $('zBottom-override').value = params.zBottomOverride || '';

            // Settings Panel - Material
            if ($('set-density')) $('set-density').value = params.concreteDensity || 23.544;
            if ($('set-gravity')) $('set-gravity').value = params.gravity || 9.81;
            if ($('set-strength')) $('set-strength').value = params.concreteStrength || 280;
            if ($('set-dampZ')) $('set-dampZ').value = params.dampingZ || 0.25;
            if ($('set-dampX')) $('set-dampX').value = params.dampingX || 0.25;
            if ($('set-dampRock')) $('set-dampRock').value = params.dampingRock || 0.25;
            if ($('set-dampTor')) $('set-dampTor').value = params.dampingTor || 0.25;

            // Settings Panel - Project Info
            if ($('project-machineType')) $('project-machineType').value = projectInfo.machineType || 'C';
            if ($('project-capType')) $('project-capType').value = projectInfo.capType || 'C';
            if ($('project-arrangement')) $('project-arrangement').value = projectInfo.arrangement || 'A';
            if ($('project-stiffness')) $('project-stiffness').value = projectInfo.stiffness || 'I';
            if ($('project-pileHead')) $('project-pileHead').value = projectInfo.pileHead || ' ';
            if ($('project-unit')) $('project-unit').value = projectInfo.unit || 'M';

            // Machine Panel
            if ($('machine-type')) $('machine-type').value = projectInfo.machineType || 'C';
            if ($('machine-freq')) $('machine-freq').value = loadsConfig.freq || 3000;

            // Header
            if ($('header-jobName')) $('header-jobName').value = projectInfo.jobName || '';

            // === VISIBILITY TOGGLE: Show/hide conditional buttons ===
            // Cap Type A button visibility
            const capARow = $('capA-params-row');
            if (capARow) {
              if (projectInfo.capType === 'A') capARow.classList.remove('hidden');
              else capARow.classList.add('hidden');
            }
            // Stiffness C button visibility
            const stiffCRow = $('stiffC-params-row');
            if (stiffCRow) {
              if (projectInfo.stiffness === 'C') stiffCRow.classList.remove('hidden');
              else stiffCRow.classList.add('hidden');
            }

            // === SYNC MODAL INPUTS ===
            const capA = params.capAParams || {};
            if ($('capA-Weight')) $('capA-Weight').value = capA.Weight || 0;
            if ($('capA-Ixx')) $('capA-Ixx').value = capA.Ixx || 0;
            if ($('capA-Iyy')) $('capA-Iyy').value = capA.Iyy || 0;
            if ($('capA-Izz')) $('capA-Izz').value = capA.Izz || 0;
            if ($('capA-Cx')) $('capA-Cx').value = capA.Cx || 0;
            if ($('capA-Cy')) $('capA-Cy').value = capA.Cy || 0;
            if ($('capA-Cz')) $('capA-Cz').value = capA.Cz || 0;

            const stiffC = params.stiffnessCParams || {};
            if ($('stiffC-D')) $('stiffC-D').value = stiffC.D || 0.4;
            if ($('stiffC-L')) $('stiffC-L').value = stiffC.L || 15;
            if ($('stiffC-Es')) $('stiffC-Es').value = stiffC.Es || 30000;
            if ($('stiffC-f')) $('stiffC-f').value = stiffC.f || 1.0;
          },

          updateParams(p) { Object.assign(this.params, p); this.notify(); },
          setSelection(t, id) {
            this.selection = { type: t, id };
            this.selectedIds = t && id ? [{ type: t, id }] : [];
            // Reset lastClicked if needed, but safer to leave it or update it on click
            App.UI.render(); App.UI.updatePropsPanel(); App.Renderer.draw();
          },
          setMultiSelection(items) {
            this.selectedIds = items || [];
            if (items.length === 1) {
              this.selection = { type: items[0].type, id: items[0].id };
            } else {
              this.selection = { type: null, id: null };
            }
            App.UI.render(); App.UI.updatePropsPanel(); App.Renderer.draw();
          },
          handleListClick(type, index, e, id) {
            // Handle Shift-Select
            if (e.shiftKey && this.lastClicked.type === type && this.lastClicked.index > -1) {
              const start = Math.min(this.lastClicked.index, index);
              const end = Math.max(this.lastClicked.index, index);
              let items = [];
              if (type === 'block') items = this.blocks;
              if (type === 'pile') items = this.piles;
              if (type === 'machine') items = this.machines;
              if (type === 'point') items = this.points;
              if (type === 'load') items = this.loadPoints;
              if (type === 'assembly') items = this.assemblies;

              // Select range
              const range = items.slice(start, end + 1).map(x => ({ type, id: x.id }));

              // If Ctrl held, ADD range. Else REPLACE with range.
              if (e.ctrlKey) {
                // Add unique
                range.forEach(r => {
                  if (!this.selectedIds.some(s => s.type === r.type && s.id === r.id)) {
                    this.selectedIds.push(r);
                  }
                });
              } else {
                this.selectedIds = range;
              }
            } else if (e.ctrlKey) {
              // Toggle
              this.toggleSelection(type, id, true);
            } else {
              // Single Select
              this.setSelection(type, id);
            }

            // Update last clicked
            this.lastClicked = { type, index };
            this.selection = this.selectedIds.length > 0 ? this.selectedIds[0] : { type: null, id: null };
            App.UI.render(); App.UI.updatePropsPanel(); App.Renderer.draw();
          },
          toggleSelection(t, id, ctrlKey = false) {
            if (ctrlKey) {
              const idx = this.selectedIds.findIndex(s => s.type === t && s.id === id);
              if (idx >= 0) {
                this.selectedIds.splice(idx, 1);
              } else {
                this.selectedIds.push({ type: t, id });
              }
            } else { // Single select fallback
              this.selectedIds = [{ type: t, id }];
            }
            if (this.selectedIds.length === 1) this.selection = { ...this.selectedIds[0] };
            else this.selection = { type: null, id: null };
            App.UI.render(); App.UI.updatePropsPanel(); App.Renderer.draw();
          },

          isSelected(t, id) {
            return this.selectedIds.some(s => s.type === t && s.id === id);
          },
          clearSelection() {
            this.selection = { type: null, id: null };
            this.selectedIds = [];
            App.UI.render(); App.UI.updatePropsPanel(); App.Renderer.draw();
          },
          updateBlock(b) { const idx = this.blocks.findIndex(x => x.id === b.id); if (idx >= 0) this.blocks[idx] = b; this.notify(); },
          updatePile(p) { const idx = this.piles.findIndex(x => x.id === p.id); if (idx >= 0) this.piles[idx] = p; this.notify(); },
          updatePoint(p) { const idx = this.points.findIndex(x => x.id === p.id); if (idx >= 0) this.points[idx] = p; this.notify(); },
          // Silent update - KHÔNG ghi history (dùng cho kéo thả)
          updateBlockSilent(b) { const idx = this.blocks.findIndex(x => x.id === b.id); if (idx >= 0) this.blocks[idx] = b; this.listeners.forEach(fn => fn()); },
          updatePileSilent(p) { const idx = this.piles.findIndex(x => x.id === p.id); if (idx >= 0) this.piles[idx] = p; this.listeners.forEach(fn => fn()); },
          updateMachineSilent(m) { const idx = this.machines.findIndex(x => x.id === m.id); if (idx >= 0) this.machines[idx] = m; this.listeners.forEach(fn => fn()); },
          updatePointSilent(p) { const idx = this.points.findIndex(x => x.id === p.id); if (idx >= 0) this.points[idx] = p; this.listeners.forEach(fn => fn()); },

          // Toggle control functions (inverted: true = feature enabled)
          toggleLock(lockType) {
            if (lockType === 'model') {
              this.enableModel = !this.enableModel;
            } else if (lockType === 'drag') {
              this.enableDrag = !this.enableDrag;
            } else if (lockType === 'rotate') {
              this.enableRotate = !this.enableRotate;
            } else if (lockType === 'isolate') {
              // Toggle isolate mode - store currently selected objects
              if (this.isolatedIds) {
                this.isolatedIds = null; // Exit isolate mode
              } else if (this.selectedIds.length > 0) {
                this.isolatedIds = [...this.selectedIds]; // Isolate selected
              }
            }
            this.updateLockButtons();
            App.Renderer?.draw();
          },
          showAllObjects() {
            this.isolatedIds = null;
            this.hiddenIds = []; // Reset hidden objects
            this.updateLockButtons();
            App.Renderer?.draw();
          },
          hideSelected() {
            // Add selected objects to hiddenIds
            if (this.selectedIds.length > 0) {
              this.selectedIds.forEach(s => {
                // Check if not already hidden
                if (!this.hiddenIds.some(h => h.type === s.type && h.id === s.id)) {
                  this.hiddenIds.push({ type: s.type, id: s.id });
                }
              });
              this.clearSelection();
              this.updateLockButtons();
              App.Renderer?.draw();
            }
          },
          updateLockButtons() {
            const $ = id => document.getElementById(id);
            // Model button - green when enabled (interactions allowed)
            const btnModel = $('btn-lock-model');
            if (btnModel) {
              const icon = btnModel.querySelector('i');
              if (this.enableModel) {
                btnModel.classList.add('bg-green-100');
                btnModel.classList.remove('bg-red-100');
                icon?.classList.replace('text-slate-400', 'text-green-600');
                icon?.classList.replace('text-red-500', 'text-green-600');
              } else {
                btnModel.classList.add('bg-red-100');
                btnModel.classList.remove('bg-green-100');
                icon?.classList.replace('text-green-600', 'text-red-500');
                icon?.classList.replace('text-slate-400', 'text-red-500');
              }
            }
            // Drag button - green when enabled
            const btnDrag = $('btn-lock-drag');
            if (btnDrag) {
              const icon = btnDrag.querySelector('i');
              if (this.enableDrag) {
                btnDrag.classList.add('bg-green-100');
                btnDrag.classList.remove('bg-orange-100');
                icon?.classList.replace('text-slate-400', 'text-green-600');
                icon?.classList.replace('text-orange-500', 'text-green-600');
              } else {
                btnDrag.classList.add('bg-orange-100');
                btnDrag.classList.remove('bg-green-100');
                icon?.classList.replace('text-green-600', 'text-orange-500');
                icon?.classList.replace('text-slate-400', 'text-orange-500');
              }
            }
            // Rotate button - green when enabled
            const btnRotate = $('btn-lock-rotate');
            if (btnRotate) {
              const icon = btnRotate.querySelector('i');
              if (this.enableRotate) {
                btnRotate.classList.add('bg-green-100');
                btnRotate.classList.remove('bg-blue-100');
                icon?.classList.replace('text-slate-400', 'text-green-600');
                icon?.classList.replace('text-blue-500', 'text-green-600');
              } else {
                btnRotate.classList.add('bg-blue-100');
                btnRotate.classList.remove('bg-green-100');
                icon?.classList.replace('text-green-600', 'text-blue-500');
                icon?.classList.replace('text-slate-400', 'text-blue-500');
              }
            }
            // Isolate button - purple when active
            const btnIsolate = $('btn-isolate');
            if (btnIsolate) {
              const icon = btnIsolate.querySelector('i');
              if (this.isolatedIds) {
                btnIsolate.classList.add('bg-purple-100');
                icon?.classList.replace('text-slate-400', 'text-purple-500');
              } else {
                btnIsolate.classList.remove('bg-purple-100');
                icon?.classList.replace('text-purple-500', 'text-slate-400');
              }
            }
            // Grid toggle button - cyan when visible
            const btnGrid = $('btn-toggle-grid');
            if (btnGrid) {
              const icon = btnGrid.querySelector('i');
              if (this.showGrid) {
                btnGrid.classList.add('bg-cyan-100');
                icon?.classList.replace('text-slate-400', 'text-cyan-600');
              } else {
                btnGrid.classList.remove('bg-cyan-100');
                icon?.classList.replace('text-cyan-600', 'text-slate-400');
              }
            }
          },
        },

        History: {
          stack: [], ptr: -1,
          push() {
            const s = JSON.stringify({ blocks: App.State.blocks, piles: App.State.piles, points: App.State.points, machines: App.State.machines, loadPoints: App.State.loadPoints, loadsConfig: App.State.loadsConfig, assemblies: App.State.assemblies });
            if (this.ptr > -1 && this.stack[this.ptr] === s) return false; // No change
            if (this.ptr < this.stack.length - 1) this.stack = this.stack.slice(0, this.ptr + 1);
            this.stack.push(s);
            this.ptr++; if (this.stack.length > 20) { this.stack.shift(); this.ptr--; }
            return true; // Actual change added
          },
          undo() {
            if (this.ptr > 0) {
              this.ptr--; const d = JSON.parse(this.stack[this.ptr]);
              App.State.blocks = d.blocks || []; App.State.piles = d.piles || []; App.State.points = d.points || [];
              App.State.machines = d.machines || []; App.State.loadPoints = d.loadPoints || []; App.State.loadsConfig = d.loadsConfig || { freq: 3000 };
              App.State.assemblies = d.assemblies || [];
              App.State.notify(false);
            }
          },
          redo() {
            if (this.ptr < this.stack.length - 1) {
              this.ptr++; const d = JSON.parse(this.stack[this.ptr]);
              App.State.blocks = d.blocks || []; App.State.piles = d.piles || []; App.State.points = d.points || [];
              App.State.machines = d.machines || []; App.State.loadPoints = d.loadPoints || []; App.State.loadsConfig = d.loadsConfig || { freq: 3000 };
              App.State.assemblies = d.assemblies || [];
              App.State.notify(false);
            }
          }
        },

        // Audit module for model validation
        Audit: {
          run() {
            const errors = [];
            const warnings = [];
            const blocks = App.State.blocks.filter(b => b.op !== -1);
            const piles = App.State.piles;
            const machines = App.State.machines;
            const loads = App.State.loadPoints;
            const D = piles[0]?.size || 0.4; // Pile diameter

            // === CRITICAL ERRORS (Red) ===

            // 1. Missing blocks
            if (blocks.length === 0) {
              errors.push('No blocks defined');
            }

            // 2. Missing piles
            if (piles.length === 0 && blocks.length > 0) {
              errors.push('No piles defined');
            }

            // === PARAMETER VALIDATION ERRORS ===
            const params = App.State.params;
            const projectInfo = App.State.projectInfo;
            const loadsConfig = App.State.loadsConfig;

            // P1. Check Global Kv/Kh when strategy is 'global' AND stiffness is NOT 'C'
            // (Stiffness C uses D/L/Es/f, not Kv/Kh)
            if (projectInfo.stiffness !== 'C' && params.stiffnessStrategy === 'global' && piles.length > 0) {
              if (!params.globalKv || params.globalKv === 0) {
                errors.push('Global Kv not set (required when strategy=global)');
              }
              if (!params.globalKh || params.globalKh === 0) {
                errors.push('Global Kh not set (required when strategy=global)');
              }
            }

            // P2. Piles have different Kv/Kh - warn when not using global strategy (skip if stiffness=C)
            if (projectInfo.stiffness !== 'C' && piles.length > 1 && params.stiffnessStrategy !== 'global') {
              const kvValues = [...new Set(piles.map(p => p.Kv))];
              const khValues = [...new Set(piles.map(p => p.Kh))];
              if (kvValues.length > 1 || khValues.length > 1) {
                warnings.push('Piles have different Kv/Kh values - Legacy engine uses single value');
              }
            }

            // P3. Missing gravity
            if (!params.gravity || params.gravity === 0) {
              errors.push('Gravity not set (params.gravity = 0)');
            }

            // P4. Missing concrete density
            if (!params.concreteDensity || params.concreteDensity === 0) {
              errors.push('Concrete density not set');
            }

            // P5. CapType=R requires single block
            if (projectInfo.capType === 'R' && blocks.length !== 1) {
              errors.push('CapType=R (Rectangular) requires exactly 1 block');
            }

            // P6. Arrangement=R requires piles on rectangular grid
            if (projectInfo.arrangement === 'R' && piles.length > 0) {
              const uniqueX = [...new Set(piles.map(p => p.X))];
              const uniqueY = [...new Set(piles.map(p => p.Y))];
              if (piles.length !== uniqueX.length * uniqueY.length) {
                errors.push('Arrangement=R requires piles on perfect rectangular grid');
              }
            }

            // P7. Missing job name
            if (!projectInfo.jobName || projectInfo.jobName.trim() === '') {
              warnings.push('Job name not set');
            }

            // P8. Missing freq (RPM)
            if (!loadsConfig.freq || loadsConfig.freq === 0) {
              warnings.push('Operating frequency (RPM) not set');
            }

            // P9. Machines with zero weight
            const zeroWeightMachines = [];
            machines.forEach((m, i) => {
              if (!m.W || m.W === 0) zeroWeightMachines.push(i + 1);
            });
            if (zeroWeightMachines.length > 0) {
              warnings.push(`Machines with zero weight: #${zeroWeightMachines.join(', #')}`);
            }

            // P10. No machines defined
            if (machines.length === 0 && blocks.length > 0) {
              warnings.push('No machines defined');
            }

            // === LOAD-RELATED AUDITS ===

            // L1. Machine=R requires secondary forces
            if (projectInfo.machineType === 'R' && loads.length > 0) {
              const hasSecondary = loads.some(lp =>
                (lp.Fx2 && lp.Fx2 !== 0) || (lp.Fy2 && lp.Fy2 !== 0) ||
                (lp.Fz2 && lp.Fz2 !== 0) || (lp.Mx2 && lp.Mx2 !== 0) ||
                (lp.My2 && lp.My2 !== 0) || (lp.Mz2 && lp.Mz2 !== 0)
              );
              if (!hasSecondary) {
                warnings.push('Machine=R (Reciprocating) should have secondary forces defined');
              }
            }

            // L2. Loads with all forces = 0
            const zeroLoads = [];
            loads.forEach((lp, i) => {
              const hasPrimary = (lp.Fx || lp.Fy || lp.Fz || lp.Mx || lp.My || lp.Mz);
              if (!hasPrimary) zeroLoads.push(i + 1);
            });
            if (zeroLoads.length > 0) {
              warnings.push(`Loads with zero forces: #${zeroLoads.join(', #')}`);
            }

            // L3. No loads when machines exist
            if (loads.length === 0 && machines.length > 0) {
              warnings.push('No loads defined (machines exist)');
            }

            // L4. No check points defined
            const points = App.State.points;
            if (points.length === 0 && blocks.length > 0) {
              warnings.push('No check points defined');
            }

            // 3. Duplicate blocks (same L,W,H,X,Y,Z)
            const blockKeys = new Set();
            const dupBlocks = [];
            blocks.forEach((b, i) => {
              const key = `${b.L.toFixed(1)}_${b.W.toFixed(1)}_${b.H.toFixed(1)}_${b.X.toFixed(1)}_${b.Y.toFixed(1)}_${b.Z.toFixed(1)}`;
              if (blockKeys.has(key)) dupBlocks.push(i + 1);
              blockKeys.add(key);
            });
            if (dupBlocks.length > 0) {
              errors.push(`Duplicate blocks: #${dupBlocks.join(', #')}`);
            }

            // 4. Duplicate piles (same X,Y within 0.1m)
            const dupPiles = [];
            for (let i = 0; i < piles.length; i++) {
              for (let j = i + 1; j < piles.length; j++) {
                if (Math.abs(piles[i].X - piles[j].X) < 0.1 && Math.abs(piles[i].Y - piles[j].Y) < 0.1) {
                  if (!dupPiles.includes(j + 1)) dupPiles.push(j + 1);
                }
              }
            }
            if (dupPiles.length > 0) {
              errors.push(`Duplicate piles: #${dupPiles.join(', #')}`);
            }

            // 5. Floating piles (not under any block XY footprint)
            const floatingPiles = [];
            piles.forEach((p, i) => {
              const underBlock = blocks.some(b =>
                p.X >= b.X && p.X <= b.X + b.L && p.Y >= b.Y && p.Y <= b.Y + b.W
              );
              if (!underBlock && blocks.length > 0) floatingPiles.push(i + 1);
            });
            if (floatingPiles.length > 0) {
              errors.push(`Floating piles: #${floatingPiles.join(', #')}`);
            }

            // 6. Floating loads (load not within any block volume OR on a machine)
            const floatingLoads = [];
            loads.forEach((lp, i) => {
              const inBlock = blocks.some(b =>
                lp.X >= b.X && lp.X <= b.X + b.L &&
                lp.Y >= b.Y && lp.Y <= b.Y + b.W &&
                lp.Z >= b.Z && lp.Z <= b.Z + b.H + 0.5 // Allow slightly above block
              );
              // Also check if load is at a machine position (within 0.5m tolerance)
              const onMachine = machines.some(m =>
                Math.abs(lp.X - m.X) < 0.5 && Math.abs(lp.Y - m.Y) < 0.5 && Math.abs(lp.Z - m.Z) < 1.0
              );
              if (!inBlock && !onMachine && blocks.length > 0) floatingLoads.push(i + 1);
            });
            if (floatingLoads.length > 0) {
              errors.push(`Floating loads: #${floatingLoads.join(', #')}`);
            }

            // 7. Floating machines (machine not in footprint of any block - XY only, similar to piles)
            const floatingMachines = [];
            machines.forEach((m, i) => {
              const inBlock = blocks.some(b =>
                m.X >= b.X && m.X <= b.X + b.L &&
                m.Y >= b.Y && m.Y <= b.Y + b.W
              );
              if (!inBlock && blocks.length > 0) floatingMachines.push(i + 1);
            });
            if (floatingMachines.length > 0) {
              errors.push(`Floating machines: #${floatingMachines.join(', #')}`);
            }

            // === WARNINGS (Yellow) ===

            // W1. Block too small (any side < 2*D)
            const smallBlocks = [];
            blocks.forEach((b, i) => {
              if (b.L < 2 * D || b.W < 2 * D || b.H < D) smallBlocks.push(i + 1);
            });
            if (smallBlocks.length > 0) {
              warnings.push(`Small blocks: #${smallBlocks.join(', #')}`);
            }

            // W2. Piles near edge (<1D from block edge)
            // FIXED: Only check edge distance for the LARGEST enclosing block
            const edgePiles = [];
            piles.forEach((p, i) => {
              // Find all blocks containing this pile
              const enclosingBlocks = blocks.filter(b =>
                p.X >= b.X && p.X <= b.X + b.L && p.Y >= b.Y && p.Y <= b.Y + b.W
              );
              if (enclosingBlocks.length === 0) return;
              // Get the LARGEST enclosing block (by footprint area)
              const primaryBlock = enclosingBlocks.reduce((max, b) =>
                (b.L * b.W) > (max.L * max.W) ? b : max
                , enclosingBlocks[0]);
              // Check edge distance only for primary block
              const dLeft = p.X - primaryBlock.X;
              const dRight = (primaryBlock.X + primaryBlock.L) - p.X;
              const dBottom = p.Y - primaryBlock.Y;
              const dTop = (primaryBlock.Y + primaryBlock.W) - p.Y;
              if (Math.min(dLeft, dRight, dBottom, dTop) < D) {
                edgePiles.push(i + 1);
              }
            });
            if (edgePiles.length > 0) {
              warnings.push(`Piles near edge (<1D): #${edgePiles.join(', #')}`);
            }

            // W3. Missing loads when machines exist
            if (loads.length === 0 && machines.length > 0) {
              warnings.push('No loads defined for machines');
            }

            // W4. Loads exist but no machines
            if (loads.length > 0 && machines.length === 0) {
              warnings.push('Loads defined but no machines');
            }

            return { errors, warnings };
          },
          getErrors() {
            return this.run().errors;
          },
          getWarnings() {
            return this.run().warnings;
          }
        },

        // Export module for WCVL wizard
        Export: {
          step: 1,
          output: '',
          openSimple() {
            // Simple popup - use centralized WCVL output logic from App.IO
            this.output = App.IO.getWCVLOutput();
            const auditResult = App.Audit.run();
            let html = '<div class="space-y-3">';
            // Audit summary
            if (auditResult.errors.length > 0) {
              html += '<div class="text-red-600 text-sm font-bold">Errors: ' + auditResult.errors.join(', ') + '</div>';
              html += '<div class="text-red-500 text-xs">Fix errors before exporting!</div>';
            }
            if (auditResult.warnings.length > 0) {
              html += '<div class="text-amber-500 text-sm">Warnings: ' + auditResult.warnings.join(', ') + '</div>';
            }
            if (auditResult.errors.length === 0 && auditResult.warnings.length === 0) {
              html += '<div class="text-green-600 text-sm font-bold">✓ No issues</div>';
            }
            // Output
            html += '<textarea class="w-full h-64 text-xs font-mono bg-slate-900 text-green-400 p-3 rounded" readonly>' + this.output.replace(/</g, '&lt;') + '</textarea>';
            html += '<div class="flex justify-end space-x-2">';
            html += '<button onclick="navigator.clipboard.writeText(App.Export.output);App.UI.showCanvasMsg(\'Copied!\')" class="px-4 py-2 bg-green-600 text-white rounded font-bold hover:bg-green-700"><i class="fa-solid fa-copy mr-1"></i>Copy</button>';
            html += '<button onclick="document.getElementById(\'simpleExportPopup\').classList.add(\'hidden\')" class="px-4 py-2 bg-slate-400 text-white rounded font-bold">Close</button>';
            html += '</div></div>';
            document.getElementById('simpleExportContent').innerHTML = html;
            document.getElementById('simpleExportPopup').classList.remove('hidden');
          },
          open() {
            this.step = 1;
            this.updateUI();
            document.getElementById('exportPopup').classList.remove('opacity-0', 'pointer-events-none');
            // Setup coordinate origin toggle
            document.querySelectorAll('input[name="coord-origin"]').forEach(r => {
              r.onchange = () => {
                document.getElementById('coord-offset-inputs').classList.toggle('hidden', r.value !== 'custom');
              };
            });
          },
          close() {
            document.getElementById('exportPopup').classList.add('opacity-0', 'pointer-events-none');
          },
          updateUI() {
            // Hide all steps, show current
            [1, 2, 3].forEach(i => {
              document.getElementById('export-step-' + i).classList.toggle('hidden', i !== this.step);
            });
            document.getElementById('export-step-indicator').innerText = 'Step ' + this.step + '/3';
            document.getElementById('export-prev-btn').classList.toggle('hidden', this.step === 1);
            document.getElementById('export-next-btn').innerText = this.step === 3 ? 'Close' : 'Next';

            if (this.step === 1) {
              // Populate summary
              const sum = `Blocks: ${App.State.blocks.length}<br>Piles: ${App.State.piles.length}<br>Machines: ${App.State.machines.length}<br>Loads: ${App.State.loadPoints.length}<br>Points: ${App.State.points.length}`;
              document.getElementById('export-summary').innerHTML = sum;
              // Populate audit
              const auditResult = App.Audit.run();
              const allIssues = [...auditResult.errors, ...auditResult.warnings];
              let auditHTML = '';
              if (auditResult.errors.length > 0) {
                auditHTML += '<div class="text-red-600">' + auditResult.errors.join('<br>') + '</div>';
              }
              if (auditResult.warnings.length > 0) {
                auditHTML += '<div class="text-amber-600">' + auditResult.warnings.join('<br>') + '</div>';
              }
              document.getElementById('export-audit').innerHTML = auditHTML || '<span class="text-green-600">✓ No issues</span>';
              // Block next if critical errors
              const hasErrors = auditResult.errors.length > 0;
              document.getElementById('export-next-btn').disabled = hasErrors;
              document.getElementById('export-next-btn').classList.toggle('opacity-50', hasErrors);
            } else if (this.step === 2) {
              // Generate mapping
              this.generateMapping();
            } else if (this.step === 3) {
              // Generate output
              this.generateOutput();
              document.getElementById('export-output').value = this.output;
            }
          },
          next() {
            if (this.step < 3) { this.step++; this.updateUI(); }
            else { this.close(); }
          },
          prev() {
            if (this.step > 1) { this.step--; this.updateUI(); }
          },
          getOffset() {
            const useCustom = document.querySelector('input[name="coord-origin"]:checked')?.value === 'custom';
            return useCustom ? {
              x: +document.getElementById('offset-x').value || 0,
              y: +document.getElementById('offset-y').value || 0,
              z: +document.getElementById('offset-z').value || 0
            } : { x: 0, y: 0, z: 0 };
          },
          generateMapping() {
            const o = this.getOffset();
            let map = '';
            map += '=== HEADER ===\n';
            map += 'Line 1: PILE\n';
            map += `Line 2: ${App.State.projectInfo.jobName || 'Project'} // Job Name\n`;
            const machType = App.State.projectInfo.machineType || 'C';
            map += `Line 3: ${machType}CAI M // [Machine=${machType}] [Cap=C] [Arr=A] [Stiff=I] [Head= ] [Unit=M]\n`;
            map += '\n=== MATERIAL CONSTANTS ===\n';
            const p = App.State.params;
            map += `Line 4: ${(p.concreteDensity || 23.544).toFixed(3)} ${p.gravity} ${p.concreteStrength || 280} ${p.dampingRatio || 0.25} ${p.dampingRatioX || 0.25} ${p.dampingRatio || 0.25} ${p.dampingRatio || 0.25}\n`;
            map += '\n=== MACHINE DATA ===\n';
            map += `Line 5: ${App.State.machines.length} ${App.State.loadsConfig.freq || 3000} // Num machines, RPM\n`;
            App.State.machines.forEach((m, i) => {
              map += `Line ${6 + i}: ${m.W} ${(m.X - o.x).toFixed(3)} ${(m.Y - o.y).toFixed(3)} ${(m.Z - o.z).toFixed(3)} ${m.Ix || 0} ${m.Iy || 0} ${m.Iz || 0} // ${m.name}\n`;
            });
            document.getElementById('export-mapping').innerText = map;
          },
          copyOutput() {
            navigator.clipboard.writeText(this.output);
            App.UI.showCanvasMsg('✓ Copied to clipboard');
          }
        },

        // Import module for WCVL parsing with Preview support
        Import: {
          _pendingData: null, // Stores parsed data before user confirms

          openSimple() {
            document.getElementById('simpleImportText').value = '';
            document.getElementById('simpleImportLog').innerHTML = '';
            document.getElementById('simpleImportPopup').classList.remove('hidden');
          },

          // Load file content and put into textarea
          loadFromFile(input) {
            const file = input.files[0];
            if (!file) return;

            // Validate file size (max 1MB)
            if (file.size > 1024 * 1024) {
              App.UI.showCanvasMsg('❌ File too large (max 1MB)');
              input.value = '';
              return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
              const text = e.target.result;

              // Check for binary content (more than 10% non-printable chars)
              let nonPrintable = 0;
              for (let i = 0; i < Math.min(text.length, 1000); i++) {
                const code = text.charCodeAt(i);
                if (code < 32 && code !== 9 && code !== 10 && code !== 13) nonPrintable++;
              }
              if (nonPrintable > 100) {
                App.UI.showCanvasMsg('❌ Binary file detected. Use text files only.');
                input.value = '';
                return;
              }

              // Put content into textarea
              document.getElementById('simpleImportText').value = text;
              document.getElementById('simpleImportLog').innerHTML = `📄 Loaded: ${file.name}`;
            };
            reader.onerror = () => {
              App.UI.showCanvasMsg('❌ Failed to read file');
            };
            reader.readAsText(file);
            input.value = ''; // Reset for next selection
          },

          // ========== MAIN ENTRY POINT ==========
          parseAndPreview() {
            const text = document.getElementById('simpleImportText').value;
            const logEl = document.getElementById('simpleImportLog');
            const log = (msg) => { logEl.innerHTML += msg + '<br>'; };
            logEl.innerHTML = '';

            if (!text.trim()) { log('❌ No data provided'); return; }

            // Detect file type
            const fileType = this.detectFileType(text);
            log(`📂 Detected format: <b>${fileType}</b>`);

            let data = null;
            try {
              if (fileType === 'INPUT') {
                data = this.parseInputWCVL(text);
              } else if (fileType === 'OUTPUT') {
                data = this.parseOutputLegacy(text);
              } else {
                log('❌ Unknown file format. Expected WCVL Input or Legacy Output.');
                return;
              }
            } catch (e) {
              log(`❌ Parse error: ${e.message}`);
              console.error(e);
              return;
            }

            if (!data) { log('❌ Failed to parse data'); return; }

            log(`✅ Parsed: ${data.machines.length} machines, ${data.blocks.length} blocks, ${data.piles.length} piles`);

            // Store for later apply
            this._pendingData = data;

            // Close input popup, open preview
            document.getElementById('simpleImportPopup').classList.add('hidden');
            this.openPreview(data);
          },

          // ========== FILE TYPE DETECTION ==========
          detectFileType(text) {
            const firstLines = text.substring(0, 500).toUpperCase();
            if (firstLines.includes('PILE') && !firstLines.includes('DYNAMICAL ANALYSIS')) {
              return 'INPUT';
            }
            if (firstLines.includes('DYNAMICAL ANALYSIS') || firstLines.includes('CTCI CORPORATION')) {
              return 'OUTPUT';
            }
            // Check for INPUT format indicators
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            if (lines[0] === 'PILE') return 'INPUT';
            return 'UNKNOWN';
          },

          // ========== PARSE WCVL INPUT (.in file) ==========
          parseInputWCVL(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            const warnings = [];

            // Line 1: PILE header
            if (lines[0] !== 'PILE') warnings.push('Line 1 is not "PILE"');

            // Line 2: Job Name
            const jobName = lines[1] || 'Unknown';

            // Line 3: Flags (e.g., "CCAI M")
            const flags = lines[2].split(/\s+/);
            const flagStr = flags[0] || 'CCAI';
            const machineType = flagStr[0] || 'C'; // C=Centrifugal, R=Reciprocating
            const capType = flagStr[1] || 'C';     // C=Composited, R=Rectangular
            const arrType = flagStr[2] || 'A';     // A=Array, R=Rectangular grid
            const stiffType = flagStr[3] || 'I';   // I=Input, C=Computed
            const unitSystem = flags[1] || 'M';    // M=Metric, E=English

            // Line 4: Material constants [density, gravity, fc, damp_z, damp_x, damp_rock, damp_tor]
            const mat = lines[3].split(/\s+/).map(Number);
            const params = {
              concreteDensity: mat[0] || 23.544,
              gravity: mat[1] || 9.81,
              concreteStrength: mat[2] || 280,
              dampingZ: mat[3] || 0.25,
              dampingX: mat[4] || 0.25,
              dampingRock: mat[5] || 0.25,
              dampingTor: mat[6] || 0.25
            };

            // Line 5: Machine count and RPM
            const machLine = lines[4].split(/\s+/).map(Number);
            const numMachines = machLine[0] || 0;
            const rpm = machLine[1] || 3000;

            // Parse machines (Lines 6+)
            const machines = [];
            let lineIdx = 5;
            for (let i = 0; i < numMachines && lineIdx < lines.length; i++) {
              const parts = lines[lineIdx++].split(/\s+/).map(Number);
              machines.push({
                id: 'm' + Date.now() + i,
                name: 'Machine ' + (i + 1),
                W: parts[0] || 0, X: parts[1] || 0, Y: parts[2] || 0, Z: parts[3] || 0,
                Ix: parts[4] || 0, Iy: parts[5] || 0, Iz: parts[6] || 0
              });
            }

            // Parse forces - 4 lines for Type C, 8 lines for Type R
            // Format: Fx line = [Value, Zc, Yc], Fy line = [Value, Zc, Xc], Fz line = [Value, Yc, Xc], Moments = [Mx, My, Mz]
            const forces = { primary: null, secondary: null };
            if (lineIdx + 3 < lines.length) {
              const fxLine = lines[lineIdx++].split(/\s+/).map(Number);
              const fyLine = lines[lineIdx++].split(/\s+/).map(Number);
              const fzLine = lines[lineIdx++].split(/\s+/).map(Number);
              const mLine = lines[lineIdx++].split(/\s+/).map(Number);
              forces.primary = {
                Fx: { value: fxLine[0] || 0, arm1: { label: 'Z', val: fxLine[1] || 0 }, arm2: { label: 'Y', val: fxLine[2] || 0 } },
                Fy: { value: fyLine[0] || 0, arm1: { label: 'Z', val: fyLine[1] || 0 }, arm2: { label: 'X', val: fyLine[2] || 0 } },
                Fz: { value: fzLine[0] || 0, arm1: { label: 'Y', val: fzLine[1] || 0 }, arm2: { label: 'X', val: fzLine[2] || 0 } },
                Mx: mLine[0] || 0, My: mLine[1] || 0, Mz: mLine[2] || 0
              };
              // For Type R, read secondary forces
              if (machineType === 'R' && lineIdx + 3 < lines.length) {
                const fx2 = lines[lineIdx++].split(/\s+/).map(Number);
                const fy2 = lines[lineIdx++].split(/\s+/).map(Number);
                const fz2 = lines[lineIdx++].split(/\s+/).map(Number);
                const m2 = lines[lineIdx++].split(/\s+/).map(Number);
                forces.secondary = {
                  Fx: { value: fx2[0] || 0, arm1: { label: 'Z', val: fx2[1] || 0 }, arm2: { label: 'Y', val: fx2[2] || 0 } },
                  Fy: { value: fy2[0] || 0, arm1: { label: 'Z', val: fy2[1] || 0 }, arm2: { label: 'X', val: fy2[2] || 0 } },
                  Fz: { value: fz2[0] || 0, arm1: { label: 'Y', val: fz2[1] || 0 }, arm2: { label: 'X', val: fz2[2] || 0 } },
                  Mx: m2[0] || 0, My: m2[1] || 0, Mz: m2[2] || 0
                };
              }
            }

            // Parse geometry (Nodes & Blocks) - depends on capType (A, R, C)
            const blocks = [];
            const nodes = [];
            const skippedBlocks = []; // Store blocks that couldn't be created due to missing nodes
            let capAParams = null; // For Type A

            if (capType === 'A') {
              // Arbitrary cap: Weight Ixx Iyy Izz Cx Cy Cz
              const geo = lines[lineIdx++].split(/\s+/).map(Number);
              capAParams = {
                Weight: geo[0] || 0,
                Ixx: geo[1] || 0, Iyy: geo[2] || 0, Izz: geo[3] || 0,
                Cx: geo[4] || 0, Cy: geo[5] || 0, Cz: geo[6] || 0
              };
              // Generate representative block at CG location (approx dimensions from weight)
              // Assume concrete density 23.544 kN/m³, create cube with matching weight
              const volume = (capAParams.Weight || 1) / (params.concreteDensity || 23.544);
              const side = Math.cbrt(volume);
              blocks.push({
                id: 'b' + Date.now(), name: 'Arbitrary Cap', op: 1, density: params.concreteDensity,
                L: side, W: side, H: side,
                X: capAParams.Cx - side / 2, Y: capAParams.Cy - side / 2, Z: capAParams.Cz - side / 2
              });
              warnings.push('Cap Type A: Representative block generated from Weight/CG');
            } else if (capType === 'R') {
              // Rectangular cap: Lx Ly T Cx Cy Cz
              const geo = lines[lineIdx++].split(/\s+/).map(Number);
              blocks.push({
                id: 'b' + Date.now(), name: 'Cap', op: 1, density: params.concreteDensity,
                L: geo[0], W: geo[1], H: geo[2],
                X: geo[3] - geo[0] / 2, Y: geo[4] - geo[1] / 2, Z: geo[5] - geo[2] / 2
              });
            } else {
              // Composited: numNodes numBlocks
              // IMPORTANT: Input format may INTERLEAVE nodes and blocks!
              // Nodes have 4 values (ID, X, Y, Z), Blocks have 5-6 values (BlockID, N1, N2, N3, N4, [Factor])
              const geoCounts = lines[lineIdx++].split(/\s+/).map(Number);
              const numNodes = geoCounts[0] || 0;
              const numBlocks = geoCounts[1] || 0;
              const totalGeoLines = numNodes + numBlocks;

              // Storage for raw block definitions (parse after all nodes are known)
              const pendingBlocks = [];

              // Read ALL geometry lines and classify by value count
              for (let i = 0; i < totalGeoLines && lineIdx < lines.length; i++) {
                // Filter out empty strings and NaN from split (handles leading whitespace)
                const rawParts = lines[lineIdx++].split(/\s+/);
                const parts = rawParts.filter(p => p !== '' && p.trim() !== '').map(Number).filter(n => !isNaN(n));

                if (parts.length <= 4) {
                  // 4 values = Node definition (ID, X, Y, Z)
                  nodes.push({ id: Math.round(parts[0]), X: parts[1], Y: parts[2], Z: parts[3] });
                } else {
                  // 5-6 values = Block definition (BlockID, N1, N2, N3, N4, [Factor])
                  const blockId = Math.round(parts[0]);
                  // Skip duplicate block IDs
                  if (!pendingBlocks.find(pb => pb.blockId === blockId)) {
                    pendingBlocks.push({
                      blockId,
                      nodeIds: [Math.round(parts[1]), Math.round(parts[2]), Math.round(parts[3]), Math.round(parts[4])],
                      factor: parts[5] !== undefined ? parts[5] : 1
                    });
                  } else {
                    warnings.push(`Duplicate Block ID ${blockId} skipped`);
                  }
                }
              }

              // Now process pending blocks (nodes are all loaded)
              for (const pBlock of pendingBlocks) {
                const n1 = nodes.find(n => n.id == pBlock.nodeIds[0]);
                const n2 = nodes.find(n => n.id == pBlock.nodeIds[1]);
                const n3 = nodes.find(n => n.id == pBlock.nodeIds[2]);
                const n4 = nodes.find(n => n.id == pBlock.nodeIds[3]);
                if (n1 && n2 && n3 && n4) {
                  // Vector calculation: L = dist(N1,N2), W = dist(N1,N3), H = |Z4 - Z1|
                  const L = Math.sqrt((n2.X - n1.X) ** 2 + (n2.Y - n1.Y) ** 2 + (n2.Z - n1.Z) ** 2);
                  const W = Math.sqrt((n3.X - n1.X) ** 2 + (n3.Y - n1.Y) ** 2 + (n3.Z - n1.Z) ** 2);
                  let H = Math.abs(n4.Z - n1.Z);
                  const blockZ = Math.min(n1.Z, n4.Z);
                  if (n4.Z < n1.Z) { warnings.push(`Block ${pBlock.blockId}: Node 4 below Node 1 (inverted)`); }
                  const opValue = (pBlock.factor < 0) ? -1 : 1;
                  blocks.push({
                    id: 'b' + Date.now() + blocks.length, name: 'Block ' + pBlock.blockId, op: opValue,
                    density: params.concreteDensity, L, W, H, X: n1.X, Y: n1.Y, Z: blockZ
                  });
                } else {
                  const missingNodes = [];
                  if (!n1) missingNodes.push(pBlock.nodeIds[0]);
                  if (!n2) missingNodes.push(pBlock.nodeIds[1]);
                  if (!n3) missingNodes.push(pBlock.nodeIds[2]);
                  if (!n4) missingNodes.push(pBlock.nodeIds[3]);
                  warnings.push(`Skipped Block ${pBlock.blockId}: Missing Node(s) [${missingNodes.join(', ')}]`);
                  // Store skipped block for potential fix
                  skippedBlocks.push({
                    blockId: pBlock.blockId,
                    nodeIds: pBlock.nodeIds,
                    missingNodeIds: missingNodes,
                    factor: pBlock.factor,
                    existingNodes: nodes.slice() // Copy of nodes at time of skip
                  });
                }
              }
            }

            // Parse pile stiffness - depends on stiffType (I=Input, C=Computed)
            const stiffLine = lines[lineIdx++]?.split(/\s+/).map(Number) || [0, 0, 0, 0];
            let Kv = 0, Kh = 0;
            let stiffnessCParams = null;

            if (stiffType === 'C') {
              // Computed stiffness: D L Es f
              stiffnessCParams = {
                D: stiffLine[0] || 0.4,
                L: stiffLine[1] || 15,
                Es: stiffLine[2] || 30000,
                f: stiffLine[3] || 1.0
              };
              warnings.push('Stiffness Type C: Using computed stiffness parameters');
            } else {
              // Input stiffness: Kv Kh
              Kv = stiffLine[0] || 0;
              Kh = stiffLine[1] || 0;
            }
            const piles = [];

            if (arrType === 'R') {
              // Rectangular grid: nc nr, then xCoords[], yCoords[]
              const arrCounts = lines[lineIdx++].split(/\s+/).map(Number);
              const nc = arrCounts[0] || 0, nr = arrCounts[1] || 0;
              const xCoords = lines[lineIdx++].split(/\s+/).map(Number);
              const yCoords = lines[lineIdx++].split(/\s+/).map(Number);
              for (let ix = 0; ix < nc; ix++) {
                for (let iy = 0; iy < nr; iy++) {
                  piles.push({ id: 'p' + Date.now() + ix + '_' + iy, X: xCoords[ix], Y: yCoords[iy], Z: 0, Kv, Kh, shape: 'round', size: 0.4, length: 15 });
                }
              }
            } else {
              // Array: numPiles, then X Y per pile
              const numPiles = +(lines[lineIdx++] || 0);
              for (let i = 0; i < numPiles && lineIdx < lines.length; i++) {
                const parts = lines[lineIdx++].split(/\s+/).map(Number);
                piles.push({ id: 'p' + Date.now() + i, X: parts[0], Y: parts[1], Z: 0, Kv, Kh, shape: 'round', size: 0.4, length: 15 });
              }
            }

            // Z Bottom (ELEV. OF BOTTOM OF PILE CAP)
            let zBottom = 0;
            if (lineIdx < lines.length) {
              zBottom = parseFloat(lines[lineIdx++]) || 0;
              piles.forEach(p => p.Z = zBottom);
            }

            // Check points
            const points = [];
            const numPoints = +(lines[lineIdx++] || 0);
            for (let i = 0; i < numPoints && lineIdx < lines.length; i++) {
              const parts = lines[lineIdx++].split(/\s+/).map(Number);
              points.push({ id: 'pt' + Date.now() + i, name: 'Point ' + parts[0], X: parts[1], Y: parts[2], Z: parts[3] });
            }

            return {
              fileType: 'INPUT', jobName, machineType, capType, arrType, stiffType, unitSystem,
              params, rpm, machines, forces, blocks, piles, points, warnings,
              skippedBlocks, nodes, zBottom, capAParams, stiffnessCParams
            };
          },

          // ========== PARSE LEGACY OUTPUT (.out file) ==========
          parseOutputLegacy(text) {
            const warnings = [];
            // Pre-filter: Remove header/footer/page break lines
            const rawLines = text.split('\n');
            const lines = rawLines.filter(line => {
              const l = line.trim();
              if (!l) return false;
              if (l.includes('CTCI Corporation')) return false;
              if (/Page\s+\d+/i.test(l)) return false;
              if (/^\*+$/.test(l)) return false; // Lines of only asterisks
              if (/^=+$/.test(l)) return false;  // Lines of only equals
              if (/^-+$/.test(l)) return false;  // Lines of only dashes
              return true;
            });

            // Initialize data
            let jobName = 'Unknown';
            let machineType = 'C', unitSystem = 'M', rpm = 3000;
            const machines = [], blocks = [], piles = [], points = [];
            const forces = { primary: null, secondary: null };
            let Kv = 1289491, Kh = 228309, zBottom = 0;
            const params = { concreteDensity: 23.544, gravity: 9.81, concreteStrength: 280 };

            // State machine to track current section
            let section = 'NONE';
            const nodes = [];

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();

              // Detect section headers
              if (line.includes('TITLE :')) {
                jobName = line.split(':')[1]?.trim() || 'Unknown';
                continue;
              }
              if (line.includes('GRAVITATIONAL CONSTANT')) {
                const m = line.match(/([\d.]+)\s*M\/SEC/);
                if (m) params.gravity = parseFloat(m[1]);
                continue;
              }
              if (line.includes('UNIT WEIGHT OF CONCRETE')) {
                const m = line.match(/([\d.]+)\s*KN/);
                if (m) params.concreteDensity = parseFloat(m[1]);
                continue;
              }
              if (line.includes('STRENGTH OF CONCRETE')) {
                const m = line.match(/([\d.]+)\s*KG/);
                if (m) params.concreteStrength = parseFloat(m[1]);
                continue;
              }
              if (line.includes('TYPE OF MACHINE')) {
                if (line.includes('CENTRIFUGAL')) machineType = 'C';
                else if (line.includes('RECIPROCATING')) machineType = 'R';
                continue;
              }
              if (line.includes('OPERATION FREQUENCY')) {
                const m = line.match(/([\d.]+)\s*rpm/i);
                if (m) rpm = parseFloat(m[1]);
                continue;
              }

              // Section: DATA FOR MACHINE
              if (line.includes('DATA FOR MACHINE')) { section = 'MACHINES'; continue; }
              // Section: DATA FOR ACTION FORCES
              if (line.includes('DATA FOR ACTION FORCES')) { section = 'FORCES'; continue; }
              // Section: DATA FOR FOUNDATION
              if (line.includes('DATA FOR FOUNDATION')) { section = 'FOUNDATION'; continue; }
              // Section: DATA FOR PILES
              if (line.includes('DATA FOR PILES')) { section = 'PILES'; continue; }
              // Section: POINTS TO CACULATE
              if (line.includes('POINTS TO CACULATE')) { section = 'POINTS'; continue; }

              // Parse based on section
              if (section === 'MACHINES') {
                // Table rows: Weight X Y Z Ix Iy Iz
                const m = line.match(/^\s*([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)/);
                if (m) {
                  machines.push({
                    id: 'm' + Date.now() + machines.length,
                    name: 'Machine ' + (machines.length + 1),
                    W: parseFloat(m[1]), X: parseFloat(m[2]), Y: parseFloat(m[3]), Z: parseFloat(m[4]),
                    Ix: parseFloat(m[5]), Iy: parseFloat(m[6]), Iz: parseFloat(m[7])
                  });
                }
              }
              if (section === 'FORCES') {
                // Parse force lines using regex
                if (line.includes('MAX X-DIR PRIMARY FORCE')) {
                  const valM = line.match(/=\s*([\d.-]+)\s*KN/);
                  if (valM) forces.primary = forces.primary || {};
                  if (valM) forces.primary.Fx = { value: parseFloat(valM[1]), arm1: { label: '', val: 0 }, arm2: { label: '', val: 0 } };
                }
                if (line.includes('MAX Y-DIR PRIMARY')) {
                  const valM = line.match(/=\s*([\d.-]+)\s*KN/);
                  if (valM && forces.primary) forces.primary.Fy = { value: parseFloat(valM[1]), arm1: { label: '', val: 0 }, arm2: { label: '', val: 0 } };
                }
                if (line.includes('MAX Z-DIR PRIMARY')) {
                  const valM = line.match(/=\s*([\d.-]+)\s*KN/);
                  if (valM && forces.primary) forces.primary.Fz = { value: parseFloat(valM[1]), arm1: { label: '', val: 0 }, arm2: { label: '', val: 0 } };
                }
                if (line.includes('C.G. OF THE FORCE')) {
                  // Parse CG coordinates based on context - format varies
                  const coords = line.match(/=\s*([\d.-]+)\s*M\s+([\d.-]+)\s*M/);
                  if (coords && forces.primary) {
                    // Determine which force based on previous line context
                  }
                }
                if (line.includes('MAX PRIMARY   MOMENT ABOUT X-X')) {
                  const valM = line.match(/=\s*([\d.-]+)/);
                  if (valM && forces.primary) forces.primary.Mx = parseFloat(valM[1]);
                }
                if (line.includes('MAX PRIMARY   MOMENT ABOUT Y-Y')) {
                  const valM = line.match(/=\s*([\d.-]+)/);
                  if (valM && forces.primary) forces.primary.My = parseFloat(valM[1]);
                }
                if (line.includes('MAX TORSIONAL PRIMARY')) {
                  const valM = line.match(/=\s*([\d.-]+)/);
                  if (valM && forces.primary) forces.primary.Mz = parseFloat(valM[1]);
                }
              }
              if (section === 'FOUNDATION') {
                // Parse NODE table
                if (line.includes('NODE') && line.includes('X') && line.includes('Y')) { continue; } // Header
                // Node row: ID X Y Z
                const nodeM = line.match(/^\s*(\d+)\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)/);
                if (nodeM && !line.includes('BLOCK')) {
                  nodes.push({ id: parseInt(nodeM[1]), X: parseFloat(nodeM[2]), Y: parseFloat(nodeM[3]), Z: parseFloat(nodeM[4]) });
                }
                // Block row: ID N1 N2 N3 N4 Factor
                if (line.includes('BLOCK') && line.includes('NODE')) { continue; } // Header
                const blockM = line.match(/^\s*(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+([\d.]+)/);
                if (blockM) {
                  const n1 = nodes.find(n => n.id === parseInt(blockM[2]));
                  const n2 = nodes.find(n => n.id === parseInt(blockM[3]));
                  const n3 = nodes.find(n => n.id === parseInt(blockM[4]));
                  const n4 = nodes.find(n => n.id === parseInt(blockM[5]));
                  if (n1 && n2 && n3 && n4) {
                    const L = Math.sqrt((n2.X - n1.X) ** 2 + (n2.Y - n1.Y) ** 2 + (n2.Z - n1.Z) ** 2);
                    const W = Math.sqrt((n3.X - n1.X) ** 2 + (n3.Y - n1.Y) ** 2 + (n3.Z - n1.Z) ** 2);
                    let H = n4.Z - n1.Z;
                    if (H < 0) { warnings.push(`Block ${blockM[1]}: Negative H`); H = Math.abs(H); }
                    blocks.push({
                      id: 'b' + Date.now() + blocks.length, name: 'Block ' + blockM[1],
                      op: parseFloat(blockM[6]) >= 0 ? 1 : -1, density: params.concreteDensity,
                      L, W, H, X: n1.X, Y: n1.Y, Z: n1.Z
                    });
                  }
                }
                // ELEV. OF BOTTOM
                if (line.includes('ELEV. OF BOTTOM')) {
                  const m = line.match(/([\d.-]+)\s*M/);
                  if (m) zBottom = parseFloat(m[1]);
                }
              }
              if (section === 'PILES') {
                // Parse stiffness
                if (line.includes('VERTICAL   STIFNESS')) {
                  const m = line.match(/=\s*([\d.]+)/);
                  if (m) Kv = parseFloat(m[1]);
                }
                if (line.includes('HORIZONTAL STIFNESS')) {
                  const m = line.match(/=\s*([\d.]+)/);
                  if (m) Kh = parseFloat(m[1]);
                }
                // Pile location rows: ID X Y
                const pileM = line.match(/^\s*(\d+)\s+([\d.-]+)\s+([\d.-]+)\s*$/);
                if (pileM) {
                  piles.push({
                    id: 'p' + Date.now() + piles.length,
                    X: parseFloat(pileM[2]), Y: parseFloat(pileM[3]), Z: zBottom,
                    Kv, Kh, shape: 'round', size: 0.4, length: 15
                  });
                }
              }
              if (section === 'POINTS') {
                // Point rows: ID X Y Z
                const ptM = line.match(/^\s*(\d+)\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)/);
                if (ptM) {
                  points.push({
                    id: 'pt' + Date.now() + points.length, name: 'Point ' + ptM[1],
                    X: parseFloat(ptM[2]), Y: parseFloat(ptM[3]), Z: parseFloat(ptM[4])
                  });
                }
              }
            }

            // Apply zBottom to all piles if not already set
            piles.forEach(p => { if (p.Z === 0) p.Z = zBottom; });

            return {
              fileType: 'OUTPUT', jobName, machineType, capType: 'C', arrType: 'A', stiffType: 'I', unitSystem,
              params, rpm, machines, forces, blocks, piles, points, warnings
            };
          },

          // ========== OPEN PREVIEW MODAL ==========
          openPreview(data) {
            const $ = id => document.getElementById(id);
            const unitLabel = data.unitSystem === 'E' ? { force: 'Kips', length: 'ft' } : { force: 'kN', length: 'm' };

            // Update header
            $('preview-format').innerText = `Format: ${data.fileType} | Job: ${data.jobName}`;
            $('preview-unit').innerText = data.unitSystem === 'E' ? 'English (E)' : 'Metric (M)';
            $('preview-machType').innerText = data.machineType === 'R' ? 'Reciprocating (R)' : 'Centrifugal (C)';
            $('preview-blockCount').innerText = data.blocks.length;
            $('preview-blockCount2').innerText = data.blocks.length;
            $('preview-pileCount').innerText = data.piles.length;
            $('preview-pileCount2').innerText = data.piles.length;
            $('preview-machCount').innerText = data.machines.length;
            $('preview-pointCount').innerText = data.points.length;
            // RPM and Hz display
            const rpm = data.rpm || 0;
            const hz = (rpm / 60).toFixed(1);
            $('preview-rpm').innerHTML = `${rpm} rpm<br><span class="text-[10px] text-amber-500">(${hz} Hz)</span>`;

            // Update unit labels in table headers
            $('th-mach-weight').innerText = `Weight (${unitLabel.force})`;
            $('th-force-val').innerText = `Value (${unitLabel.force})`;

            // Warnings - show with Fix links for missing node errors
            const warnEl = $('preview-warnings');
            if (data.warnings && data.warnings.length > 0) {
              // Check if there are skipped blocks with missing nodes
              const hasSkippedBlocks = data.skippedBlocks && data.skippedBlocks.length > 0;

              const warningsHtml = data.warnings.map(w => {
                // Check if this is a "Skipped Block" warning
                if (w.includes('Skipped Block') && w.includes('Missing Node')) {
                  // Add Fix link
                  return `<span>${w}</span> <a href="#" onclick="App.Import.openFixNode(); return false;" class="text-emerald-600 hover:text-emerald-700 font-bold underline ml-1">Fix</a>`;
                }
                return w;
              }).join('<br>');

              warnEl.innerHTML = '<i class="fa-solid fa-exclamation-triangle mr-1"></i>' + warningsHtml;
              warnEl.classList.remove('hidden');
            } else {
              warnEl.classList.add('hidden');
            }

            // Populate Machines table
            $('preview-machines').innerHTML = data.machines.map((m, i) => `
              <tr class="border-t"><td class="p-1">${i + 1}</td><td class="p-1">${m.name}</td>
              <td class="p-1 text-right">${m.W.toFixed(3)}</td>
              <td class="p-1 text-right">${m.X.toFixed(3)}</td><td class="p-1 text-right">${m.Y.toFixed(3)}</td><td class="p-1 text-right">${m.Z.toFixed(3)}</td></tr>
            `).join('');

            // Populate Forces table
            let forcesHtml = '';
            if (data.forces.primary) {
              const p = data.forces.primary;
              const loc = (f) => f ? `(${f.arm2?.val?.toFixed(2) || '?'}, ${f.arm1?.val?.toFixed(2) || '?'}, ?)` : '-';
              forcesHtml += `<tr class="border-t"><td class="p-1">Fx</td><td class="p-1 text-blue-600">Primary</td>
                <td class="p-1 text-right">${p.Fx?.value?.toFixed(4) || 0}</td>
                <td class="p-1 text-right">${p.Fx?.arm1?.label}: ${p.Fx?.arm1?.val?.toFixed(3) || '-'}</td>
                <td class="p-1 text-right">${p.Fx?.arm2?.label}: ${p.Fx?.arm2?.val?.toFixed(3) || '-'}</td>
                <td class="p-1 text-slate-500 text-[10px]">${loc(p.Fx)}</td></tr>`;
              forcesHtml += `<tr class="border-t"><td class="p-1">Fy</td><td class="p-1 text-blue-600">Primary</td>
                <td class="p-1 text-right">${p.Fy?.value?.toFixed(4) || 0}</td>
                <td class="p-1 text-right">${p.Fy?.arm1?.label}: ${p.Fy?.arm1?.val?.toFixed(3) || '-'}</td>
                <td class="p-1 text-right">${p.Fy?.arm2?.label}: ${p.Fy?.arm2?.val?.toFixed(3) || '-'}</td>
                <td class="p-1 text-slate-500 text-[10px]">${loc(p.Fy)}</td></tr>`;
              forcesHtml += `<tr class="border-t"><td class="p-1">Fz</td><td class="p-1 text-blue-600">Primary</td>
                <td class="p-1 text-right">${p.Fz?.value?.toFixed(4) || 0}</td>
                <td class="p-1 text-right">${p.Fz?.arm1?.label}: ${p.Fz?.arm1?.val?.toFixed(3) || '-'}</td>
                <td class="p-1 text-right">${p.Fz?.arm2?.label}: ${p.Fz?.arm2?.val?.toFixed(3) || '-'}</td>
                <td class="p-1 text-slate-500 text-[10px]">${loc(p.Fz)}</td></tr>`;
              forcesHtml += `<tr class="border-t bg-slate-50"><td class="p-1">Moments</td><td class="p-1 text-blue-600">Primary</td>
                <td class="p-1 text-right" colspan="4">Mx: ${p.Mx || 0}, My: ${p.My || 0}, Mz: ${p.Mz || 0}</td></tr>`;
            }
            if (data.forces.secondary) {
              const s = data.forces.secondary;
              forcesHtml += `<tr class="border-t bg-orange-50"><td class="p-1">Fx</td><td class="p-1 text-orange-600">Secondary</td>
                <td class="p-1 text-right">${s.Fx?.value?.toFixed(4) || 0}</td>
                <td class="p-1 text-right">${s.Fx?.arm1?.label}: ${s.Fx?.arm1?.val?.toFixed(3) || '-'}</td>
                <td class="p-1 text-right">${s.Fx?.arm2?.label}: ${s.Fx?.arm2?.val?.toFixed(3) || '-'}</td>
                <td class="p-1">-</td></tr>`;
              forcesHtml += `<tr class="border-t bg-orange-50"><td class="p-1">Fy</td><td class="p-1 text-orange-600">Secondary</td>
                <td class="p-1 text-right">${s.Fy?.value?.toFixed(4) || 0}</td>
                <td class="p-1 text-right">${s.Fy?.arm1?.label}: ${s.Fy?.arm1?.val?.toFixed(3) || '-'}</td>
                <td class="p-1 text-right">${s.Fy?.arm2?.label}: ${s.Fy?.arm2?.val?.toFixed(3) || '-'}</td>
                <td class="p-1">-</td></tr>`;
              forcesHtml += `<tr class="border-t bg-orange-50"><td class="p-1">Fz</td><td class="p-1 text-orange-600">Secondary</td>
                <td class="p-1 text-right">${s.Fz?.value?.toFixed(4) || 0}</td>
                <td class="p-1 text-right">${s.Fz?.arm1?.label}: ${s.Fz?.arm1?.val?.toFixed(3) || '-'}</td>
                <td class="p-1 text-right">${s.Fz?.arm2?.label}: ${s.Fz?.arm2?.val?.toFixed(3) || '-'}</td>
                <td class="p-1">-</td></tr>`;
              forcesHtml += `<tr class="border-t bg-orange-50"><td class="p-1">Moments</td><td class="p-1 text-orange-600">Secondary</td>
                <td class="p-1 text-right" colspan="4">Mx: ${s.Mx || 0}, My: ${s.My || 0}, Mz: ${s.Mz || 0}</td></tr>`;
            }
            $('preview-forces').innerHTML = forcesHtml || '<tr><td colspan="6" class="p-2 text-slate-400 text-center">No forces parsed</td></tr>';

            // Populate Blocks table
            $('preview-blocks').innerHTML = data.blocks.map((b, i) => {
              const warn = (b.L <= 0 || b.W <= 0 || b.H <= 0) ? '<i class="fa-solid fa-exclamation-triangle text-amber-500" title="Invalid dimension"></i>' : '';
              return `<tr class="border-t"><td class="p-1">${i + 1}</td><td class="p-1">${b.name}</td>
                <td class="p-1 text-right">${b.L.toFixed(3)}</td><td class="p-1 text-right">${b.W.toFixed(3)}</td><td class="p-1 text-right">${b.H.toFixed(3)}</td>
                <td class="p-1 text-right">${b.X.toFixed(3)}</td><td class="p-1 text-right">${b.Y.toFixed(3)}</td><td class="p-1 text-right">${b.Z.toFixed(3)}</td>
                <td class="p-1 text-center">${b.op}</td><td class="p-1">${warn}</td></tr>`;
            }).join('');

            // Populate Piles table
            $('preview-piles').innerHTML = data.piles.map((p, i) => `
              <tr class="border-t"><td class="p-1">${i + 1}</td>
              <td class="p-1 text-right">${p.X.toFixed(3)}</td><td class="p-1 text-right">${p.Y.toFixed(3)}</td><td class="p-1 text-right">${p.Z.toFixed(3)}</td>
              <td class="p-1 text-right">${p.Kv?.toFixed(0) || '-'}</td><td class="p-1 text-right">${p.Kh?.toFixed(0) || '-'}</td></tr>
            `).join('');

            // Populate Points table
            $('preview-points').innerHTML = data.points.map((pt, i) => `
              <tr class="border-t"><td class="p-1">${i + 1}</td><td class="p-1">${pt.name}</td>
              <td class="p-1 text-right">${pt.X.toFixed(3)}</td><td class="p-1 text-right">${pt.Y.toFixed(3)}</td><td class="p-1 text-right">${pt.Z.toFixed(3)}</td></tr>
            `).join('');

            // Show modal
            $('importPreviewPopup').classList.remove('hidden');
          },

          closePreview() {
            document.getElementById('importPreviewPopup').classList.add('hidden');
            this._pendingData = null;
          },

          // ========== APPLY PREVIEW DATA ==========
          applyPreview() {
            const data = this._pendingData;
            if (!data) { console.error('No pending data'); return; }

            // Apply to App.State
            App.State.projectInfo.jobName = data.jobName;
            App.State.projectInfo.machineType = data.machineType;
            App.State.projectInfo.capType = data.capType || 'C';
            App.State.projectInfo.arrangement = data.arrType || 'A';
            App.State.projectInfo.stiffType = data.stiffType || 'I';
            App.State.projectInfo.unit = data.unitSystem;
            App.State.params.concreteDensity = data.params.concreteDensity;
            App.State.params.gravity = data.params.gravity;
            App.State.params.concreteStrength = data.params.concreteStrength;
            App.State.params.dampingZ = data.params.dampingZ;
            App.State.params.dampingX = data.params.dampingX;
            App.State.params.dampingRock = data.params.dampingRock;
            App.State.params.dampingTor = data.params.dampingTor;
            App.State.loadsConfig.freq = data.rpm;

            // Set global Kv/Kh from first pile (imported data uses uniform stiffness)
            if (data.piles && data.piles.length > 0) {
              App.State.params.globalKv = data.piles[0].Kv || 0;
              App.State.params.globalKh = data.piles[0].Kh || 0;
            }

            App.State.machines = data.machines;
            App.State.blocks = data.blocks;
            App.State.piles = data.piles;
            App.State.points = data.points;
            App.State.params.zBottomOverride = data.zBottom || null;

            // Sync Cap Type A params if present
            if (data.capAParams) {
              App.State.params.capAParams = data.capAParams;
            }

            // Sync Stiffness C params if present
            if (data.stiffnessCParams) {
              App.State.params.stiffnessCParams = data.stiffnessCParams;
            }

            // Sync stiffness field (not stiffType)
            App.State.projectInfo.stiffness = data.stiffType || 'I';

            // Create load point from forces if available
            if (data.forces.primary) {
              const p = data.forces.primary;
              App.State.loadPoints = [{
                id: 'load' + Date.now(), name: 'Primary Load', type: data.machineType,
                X: p.Fy?.arm2?.val || 0, Y: p.Fx?.arm2?.val || 0, Z: p.Fx?.arm1?.val || 0,
                Fx: p.Fx?.value || 0, Fy: p.Fy?.value || 0, Fz: p.Fz?.value || 0,
                Mx: p.Mx || 0, My: p.My || 0, Mz: p.Mz || 0,
                Fx2: data.forces.secondary?.Fx?.value || 0,
                Fy2: data.forces.secondary?.Fy?.value || 0,
                Fz2: data.forces.secondary?.Fz?.value || 0,
                Mx2: data.forces.secondary?.Mx || 0,
                My2: data.forces.secondary?.My || 0,
                Mz2: data.forces.secondary?.Mz || 0
              }];
            }

            // Update UI inputs
            document.getElementById('header-jobName').value = data.jobName || '';
            document.getElementById('machine-type').value = data.machineType;
            document.getElementById('machine-freq').value = data.rpm;

            App.State.notify();
            this.closePreview();
            App.UI.showCanvasMsg('✅ Import successful!');
          },

          // ========== LEGACY METHODS (kept for compatibility) ==========
          parseSimple() { this.parseAndPreview(); },
          open() { document.getElementById('importPopup').classList.remove('opacity-0', 'pointer-events-none'); },
          close() { document.getElementById('importPopup').classList.add('opacity-0', 'pointer-events-none'); },
          log(msg) { document.getElementById('import-log').innerHTML += msg + '<br>'; },
          parse() { this.parseAndPreview(); },

          // ========== FIX MISSING NODE FUNCTIONS ==========
          _fixContext: null, // Stores context for fixing nodes

          openFixNode() {
            const data = this._pendingData;
            if (!data || !data.skippedBlocks || data.skippedBlocks.length === 0) {
              alert('No skipped blocks to fix.');
              return;
            }

            const $ = id => document.getElementById(id);

            // Store fix context
            this._fixContext = {
              skippedBlocks: data.skippedBlocks,
              nodes: data.nodes || [],
              points: data.points || [],
              currentBlockIdx: 0
            };

            // Populate block selector if multiple blocks
            const blockSelect = $('fix-block-select');
            const blockSelector = $('fixBlockSelector');
            if (data.skippedBlocks.length > 1) {
              blockSelector.innerHTML = data.skippedBlocks.map((sb, i) =>
                `<option value="${i}">Block ${sb.blockId} - Missing Nodes: [${sb.missingNodeIds.join(', ')}]</option>`
              ).join('');
              blockSelect.classList.remove('hidden');
            } else {
              blockSelect.classList.add('hidden');
            }

            // Show missing nodes for first/selected block
            this.onFixBlockSelect();

            // Populate checkpoints list
            const checkpointList = $('fix-checkpoint-list');
            if (data.points && data.points.length > 0) {
              checkpointList.innerHTML = data.points.map((pt, i) => `
                <label class="flex items-center p-1 hover:bg-slate-100 rounded cursor-pointer">
                  <input type="radio" name="selectedCheckpoint" value="${i}" class="mr-2">
                  <span class="font-mono">${pt.name}: (${pt.X.toFixed(2)}, ${pt.Y.toFixed(2)}, ${pt.Z.toFixed(2)})</span>
                </label>
              `).join('');
            } else {
              checkpointList.innerHTML = '<span class="text-slate-400 italic">No check points available</span>';
            }

            // Show modal
            $('fixNodePopup').classList.remove('hidden');
          },

          closeFixNode() {
            document.getElementById('fixNodePopup').classList.add('hidden');
            this._fixContext = null;
          },

          onFixBlockSelect() {
            const $ = id => document.getElementById(id);
            const idx = parseInt($('fixBlockSelector').value) || 0;

            if (!this._fixContext || !this._fixContext.skippedBlocks[idx]) return;

            this._fixContext.currentBlockIdx = idx;
            const sb = this._fixContext.skippedBlocks[idx];
            const allNodes = this._fixContext.nodes || [];
            const existingBlocks = this._pendingData?.blocks || [];

            // Show missing nodes
            $('fix-missing-nodes').innerHTML = sb.missingNodeIds.map(id =>
              `<span class="inline-block bg-red-100 text-red-700 px-2 py-0.5 rounded mr-1 mb-1">Node ${id}</span>`
            ).join('');

            // Build nodes table - show all 4 node positions for this block
            const nodeData = sb.nodeIds.map((nodeId, pos) => {
              const node = allNodes.find(n => n.id === nodeId);
              const isMissing = sb.missingNodeIds.includes(nodeId);
              return { nodeId, pos: pos + 1, node, isMissing };
            });

            let tableHtml = `<table class="w-full border-collapse text-[11px]">
              <tr class="bg-slate-200">
                <th class="border px-2 py-1 text-left">Role</th>
                <th class="border px-2 py-1">Node ID</th>
                <th class="border px-2 py-1">X</th>
                <th class="border px-2 py-1">Y</th>
                <th class="border px-2 py-1">Z</th>
                <th class="border px-2 py-1">Status</th>
              </tr>`;

            const roles = ['N1: Origin (X,Y,Z)', 'N2: Length Dir', 'N3: Width Dir', 'N4: Height Dir'];
            nodeData.forEach((nd, i) => {
              const rowClass = nd.isMissing ? 'bg-red-50' : 'bg-green-50';
              const statusIcon = nd.isMissing
                ? '<span class="text-red-600">❌ Missing</span>'
                : '<span class="text-green-600">✓ OK</span>';
              tableHtml += `<tr class="${rowClass}">
                <td class="border px-2 py-1 font-bold">${roles[i]}</td>
                <td class="border px-2 py-1 text-center font-mono">${nd.nodeId}</td>
                <td class="border px-2 py-1 text-center font-mono">${nd.node ? nd.node.X.toFixed(3) : '?'}</td>
                <td class="border px-2 py-1 text-center font-mono">${nd.node ? nd.node.Y.toFixed(3) : '?'}</td>
                <td class="border px-2 py-1 text-center font-mono">${nd.node ? nd.node.Z.toFixed(3) : '?'}</td>
                <td class="border px-2 py-1 text-center">${statusIcon}</td>
              </tr>`;
            });
            tableHtml += '</table>';
            $('fix-nodes-table').innerHTML = tableHtml;

            // Geometry Analysis
            const n1 = nodeData[0].node;
            const n2 = nodeData[1].node;
            const n3 = nodeData[2].node;
            const n4 = nodeData[3].node;

            let geoHtml = '<div class="space-y-2">';

            // WCVL Rules explanation
            geoHtml += `<div class="mb-2 p-2 bg-white rounded border text-[10px]">
              <div class="font-bold text-blue-700 mb-1">📐 WCVL Block Rules:</div>
              <ul class="list-disc list-inside text-slate-600 space-y-0.5">
                <li><b>N1</b>: Origin corner → Block.X, Block.Y, Block.Z</li>
                <li><b>N1→N2</b>: Length vector → L = distance(N1, N2)</li>
                <li><b>N1→N3</b>: Width vector → W = distance(N1, N3)</li>
                <li><b>N4.Z - N1.Z</b>: Height → H = Z difference</li>
              </ul>
            </div>`;

            // Compute available dimensions
            geoHtml += '<div class="font-bold text-blue-700 mb-1">📊 Computed Dimensions:</div>';

            let L = null, W = null, H = null;
            if (n1 && n2) {
              L = Math.sqrt((n2.X - n1.X) ** 2 + (n2.Y - n1.Y) ** 2 + (n2.Z - n1.Z) ** 2);
              geoHtml += `<div class="text-green-700">✓ L (Length) = ${L.toFixed(3)} m</div>`;
            } else {
              geoHtml += `<div class="text-red-600">❌ L (Length) = Cannot compute (missing ${!n1 ? 'N1' : 'N2'})</div>`;
            }

            if (n1 && n3) {
              W = Math.sqrt((n3.X - n1.X) ** 2 + (n3.Y - n1.Y) ** 2 + (n3.Z - n1.Z) ** 2);
              geoHtml += `<div class="text-green-700">✓ W (Width) = ${W.toFixed(3)} m</div>`;
            } else {
              geoHtml += `<div class="text-red-600">❌ W (Width) = Cannot compute (missing ${!n1 ? 'N1' : 'N3'})</div>`;
            }

            if (n1 && n4) {
              H = Math.abs(n4.Z - n1.Z);
              geoHtml += `<div class="text-green-700">✓ H (Height) = ${H.toFixed(3)} m</div>`;
            } else {
              geoHtml += `<div class="text-red-600">❌ H (Height) = Cannot compute (missing ${!n1 ? 'N1' : 'N4'})</div>`;
            }

            // Plane analysis
            const existingNodes = nodeData.filter(nd => nd.node).map(nd => nd.node);
            if (existingNodes.length >= 3) {
              geoHtml += '<div class="mt-2 font-bold text-blue-700">🔍 Plane Analysis:</div>';
              const xs = existingNodes.map(n => n.X);
              const ys = existingNodes.map(n => n.Y);
              const zs = existingNodes.map(n => n.Z);
              const xSame = xs.every(x => Math.abs(x - xs[0]) < 0.001);
              const ySame = ys.every(y => Math.abs(y - ys[0]) < 0.001);
              const zSame = zs.every(z => Math.abs(z - zs[0]) < 0.001);

              if (zSame) {
                geoHtml += `<div class="text-blue-600">→ Nodes lie on XY plane (Z = ${zs[0].toFixed(3)})</div>`;
              } else if (ySame) {
                geoHtml += `<div class="text-blue-600">→ Nodes lie on XZ plane (Y = ${ys[0].toFixed(3)})</div>`;
              } else if (xSame) {
                geoHtml += `<div class="text-blue-600">→ Nodes lie on YZ plane (X = ${xs[0].toFixed(3)})</div>`;
              } else {
                geoHtml += `<div class="text-amber-600">→ Nodes are not coplanar (3D geometry)</div>`;
              }
            }

            // ========== CANDIDATE SCORING SYSTEM ==========
            geoHtml += '<div class="mt-3 font-bold text-emerald-700 text-sm">🎯 Recommended Coordinates:</div>';

            // Generate candidate coordinates
            const candidates = [];
            const missingPos = sb.nodeIds.indexOf(sb.missingNodeIds[0]); // Focus on first missing node

            // Candidate A: Origin (0, 0, 0)
            candidates.push({ name: 'Origin', coords: { X: 0, Y: 0, Z: 0 }, reason: 'Default origin point' });

            // Candidate B: Based on existing nodes geometry
            if (n1) {
              if (missingPos === 1) { // N2 missing - extend in X direction
                candidates.push({ name: 'Extend +X', coords: { X: n1.X + 1, Y: n1.Y, Z: n1.Z }, reason: 'Creates L=1m in X direction' });
                candidates.push({ name: 'Extend +X (2m)', coords: { X: n1.X + 2, Y: n1.Y, Z: n1.Z }, reason: 'Creates L=2m in X direction' });
              } else if (missingPos === 2) { // N3 missing - extend in Y direction
                candidates.push({ name: 'Extend +Y', coords: { X: n1.X, Y: n1.Y + 1, Z: n1.Z }, reason: 'Creates W=1m in Y direction' });
                candidates.push({ name: 'Extend +Y (2m)', coords: { X: n1.X, Y: n1.Y + 2, Z: n1.Z }, reason: 'Creates W=2m in Y direction' });
              } else if (missingPos === 3) { // N4 missing - extend in Z direction
                candidates.push({ name: 'Extend +Z', coords: { X: n1.X, Y: n1.Y, Z: n1.Z + 0.5 }, reason: 'Creates H=0.5m in Z direction' });
                candidates.push({ name: 'Extend +Z (1m)', coords: { X: n1.X, Y: n1.Y, Z: n1.Z + 1 }, reason: 'Creates H=1m in Z direction' });
              }
            }

            // Candidate C: Match existing block volumes if available
            if (existingBlocks.length > 0) {
              const avgL = existingBlocks.reduce((s, b) => s + b.L, 0) / existingBlocks.length;
              const avgW = existingBlocks.reduce((s, b) => s + b.W, 0) / existingBlocks.length;
              const avgH = existingBlocks.reduce((s, b) => s + b.H, 0) / existingBlocks.length;

              if (n1 && missingPos === 1) {
                candidates.push({ name: 'Match Avg L', coords: { X: n1.X + avgL, Y: n1.Y, Z: n1.Z }, reason: `Matches avg block L=${avgL.toFixed(2)}m` });
              } else if (n1 && missingPos === 2) {
                candidates.push({ name: 'Match Avg W', coords: { X: n1.X, Y: n1.Y + avgW, Z: n1.Z }, reason: `Matches avg block W=${avgW.toFixed(2)}m` });
              } else if (n1 && missingPos === 3) {
                candidates.push({ name: 'Match Avg H', coords: { X: n1.X, Y: n1.Y, Z: n1.Z + avgH }, reason: `Matches avg block H=${avgH.toFixed(2)}m` });
              }
            }

            // Helper: Create test block with candidate node
            const createTestBlock = (candidateCoords) => {
              const testNodes = [...nodeData];
              testNodes[missingPos] = { ...testNodes[missingPos], node: candidateCoords };

              const tn1 = testNodes[0].node;
              const tn2 = testNodes[1].node;
              const tn3 = testNodes[2].node;
              const tn4 = testNodes[3].node;

              if (!tn1 || !tn2 || !tn3 || !tn4) return null;

              const testL = Math.sqrt((tn2.X - tn1.X) ** 2 + (tn2.Y - tn1.Y) ** 2 + (tn2.Z - tn1.Z) ** 2);
              const testW = Math.sqrt((tn3.X - tn1.X) ** 2 + (tn3.Y - tn1.Y) ** 2 + (tn3.Z - tn1.Z) ** 2);
              const testH = Math.abs(tn4.Z - tn1.Z);

              return { L: testL, W: testW, H: testH, X: tn1.X, Y: tn1.Y, Z: Math.min(tn1.Z, tn4.Z) };
            };

            // Score each candidate
            candidates.forEach(c => {
              c.score = 0;
              c.issues = [];

              const testBlock = createTestBlock(c.coords);
              if (!testBlock) {
                c.issues.push('Cannot create block');
                return;
              }

              // Audit: Check for valid dimensions
              if (testBlock.L <= 0) c.issues.push('L ≤ 0');
              if (testBlock.W <= 0) c.issues.push('W ≤ 0');
              if (testBlock.H <= 0) c.issues.push('H ≤ 0');

              // Pass audit = +50 points
              if (c.issues.length === 0) {
                c.score += 50;

                // Geometry scoring
                const volume = testBlock.L * testBlock.W * testBlock.H;

                // Prefer proportional blocks (not too long/thin)
                const aspectMax = Math.max(testBlock.L, testBlock.W, testBlock.H);
                const aspectMin = Math.min(testBlock.L, testBlock.W, testBlock.H);
                const aspectRatio = aspectMin > 0 ? aspectMax / aspectMin : 999;
                if (aspectRatio < 10) c.score += 20; // Good proportions
                else if (aspectRatio < 20) c.score += 10;

                // Prefer blocks similar to existing ones
                if (existingBlocks.length > 0) {
                  const avgVol = existingBlocks.reduce((s, b) => s + b.L * b.W * b.H, 0) / existingBlocks.length;
                  const volDiff = Math.abs(volume - avgVol) / avgVol;
                  if (volDiff < 0.3) c.score += 20; // Within 30% of avg volume
                  else if (volDiff < 0.5) c.score += 10;
                }

                // Prefer contiguous with existing blocks (check if touches any edge)
                const touches = existingBlocks.some(b => {
                  const xOverlap = !(testBlock.X + testBlock.L < b.X || b.X + b.L < testBlock.X);
                  const yOverlap = !(testBlock.Y + testBlock.W < b.Y || b.Y + b.W < testBlock.Y);
                  const zOverlap = !(testBlock.Z + testBlock.H < b.Z || b.Z + b.H < testBlock.Z);
                  return (xOverlap && yOverlap) || (yOverlap && zOverlap) || (xOverlap && zOverlap);
                });
                if (touches) c.score += 10;
              }

              c.testBlock = testBlock;
            });

            // Sort by score descending
            candidates.sort((a, b) => b.score - a.score);

            // Build recommendation table
            geoHtml += `<table class="w-full border-collapse text-[10px] mt-2">
              <tr class="bg-emerald-100">
                <th class="border px-1 py-1">Score</th>
                <th class="border px-1 py-1">Candidate</th>
                <th class="border px-1 py-1">Coords (X,Y,Z)</th>
                <th class="border px-1 py-1">Result</th>
                <th class="border px-1 py-1">Action</th>
              </tr>`;

            candidates.slice(0, 5).forEach((c, i) => {
              const rowBg = i === 0 ? 'bg-emerald-50 font-bold' : '';
              const scoreColor = c.score >= 70 ? 'text-emerald-600' : c.score >= 40 ? 'text-amber-600' : 'text-red-600';
              const resultText = c.issues.length > 0
                ? `<span class="text-red-600">❌ ${c.issues.join(', ')}</span>`
                : c.testBlock
                  ? `<span class="text-green-600">✓ L=${c.testBlock.L.toFixed(2)}, W=${c.testBlock.W.toFixed(2)}, H=${c.testBlock.H.toFixed(2)}</span>`
                  : '-';

              geoHtml += `<tr class="${rowBg}">
                <td class="border px-1 py-1 text-center ${scoreColor}">${c.score}</td>
                <td class="border px-1 py-1">${c.name}</td>
                <td class="border px-1 py-1 font-mono text-center">(${c.coords.X.toFixed(2)}, ${c.coords.Y.toFixed(2)}, ${c.coords.Z.toFixed(2)})</td>
                <td class="border px-1 py-1">${resultText}</td>
                <td class="border px-1 py-1 text-center">
                  <button onclick="App.Import.applySuggestedCoords(${c.coords.X}, ${c.coords.Y}, ${c.coords.Z})"
                    class="text-blue-600 hover:text-blue-800 underline">Apply</button>
                </td>
              </tr>`;
            });
            geoHtml += '</table>';

            // Best recommendation summary
            const best = candidates[0];
            if (best && best.score >= 50) {
              geoHtml += `<div class="mt-2 p-2 bg-emerald-100 border border-emerald-300 rounded text-[11px]">
                <div class="font-bold text-emerald-700">🏆 Best Recommendation: "${best.name}"</div>
                <div class="text-emerald-800">Coords: (${best.coords.X.toFixed(3)}, ${best.coords.Y.toFixed(3)}, ${best.coords.Z.toFixed(3)})</div>
                <div class="text-emerald-600 italic">${best.reason}</div>
              </div>`;
            } else {
              geoHtml += `<div class="mt-2 p-2 bg-amber-100 border border-amber-300 rounded text-[11px]">
                <div class="font-bold text-amber-700">⚠️ No high-confidence recommendation</div>
                <div class="text-amber-600">Please enter coordinates manually or select from options above.</div>
              </div>`;
            }

            geoHtml += '</div>';
            $('fix-geometry-analysis').innerHTML = geoHtml;
          },

          // Helper to apply suggested coordinates to the input fields
          applySuggestedCoords(x, y, z) {
            const $ = id => document.getElementById(id);
            $('fix-coord-x').value = x.toFixed(3);
            $('fix-coord-y').value = y.toFixed(3);
            $('fix-coord-z').value = z.toFixed(3);
            document.querySelector('input[name="fixOption"][value="coords"]').checked = true;
          },

          applyFixOption(option) {
            const radio = document.querySelector(`input[name="fixOption"][value="${option}"]`);
            if (radio) radio.checked = true;
          },

          applyFixNode() {
            const $ = id => document.getElementById(id);
            const ctx = this._fixContext;
            if (!ctx) { alert('No fix context'); return; }

            const selectedOption = document.querySelector('input[name="fixOption"]:checked')?.value;
            if (!selectedOption) { alert('Please select a fix option'); return; }

            const sb = ctx.skippedBlocks[ctx.currentBlockIdx];
            let newCoords = { X: 0, Y: 0, Z: 0 };

            if (selectedOption === 'origin') {
              newCoords = { X: 0, Y: 0, Z: 0 };
            } else if (selectedOption === 'coords') {
              newCoords = {
                X: parseFloat($('fix-coord-x').value) || 0,
                Y: parseFloat($('fix-coord-y').value) || 0,
                Z: parseFloat($('fix-coord-z').value) || 0
              };
            } else if (selectedOption === 'checkpoint') {
              const selectedPt = document.querySelector('input[name="selectedCheckpoint"]:checked')?.value;
              if (selectedPt === undefined) { alert('Please select a checkpoint'); return; }
              const pt = ctx.points[parseInt(selectedPt)];
              if (pt) newCoords = { X: pt.X, Y: pt.Y, Z: pt.Z };
            }

            // Add missing nodes to the pending data's node list
            const data = this._pendingData;
            if (!data.nodes) data.nodes = [];

            sb.missingNodeIds.forEach(nodeId => {
              // Check if node already exists
              if (!data.nodes.find(n => n.id == nodeId)) {
                data.nodes.push({ id: nodeId, X: newCoords.X, Y: newCoords.Y, Z: newCoords.Z });
              }
            });

            // Try to rebuild the block
            const n1 = data.nodes.find(n => n.id == sb.nodeIds[0]);
            const n2 = data.nodes.find(n => n.id == sb.nodeIds[1]);
            const n3 = data.nodes.find(n => n.id == sb.nodeIds[2]);
            const n4 = data.nodes.find(n => n.id == sb.nodeIds[3]);

            if (n1 && n2 && n3 && n4) {
              const L = Math.sqrt((n2.X - n1.X) ** 2 + (n2.Y - n1.Y) ** 2 + (n2.Z - n1.Z) ** 2);
              const W = Math.sqrt((n3.X - n1.X) ** 2 + (n3.Y - n1.Y) ** 2 + (n3.Z - n1.Z) ** 2);
              const H = Math.abs(n4.Z - n1.Z);
              const blockZ = Math.min(n1.Z, n4.Z);
              const opValue = (sb.factor < 0) ? -1 : 1;

              data.blocks.push({
                id: 'b' + Date.now() + data.blocks.length,
                name: 'Block ' + sb.blockId,
                op: opValue,
                density: data.params?.concreteDensity || 24,
                L, W, H, X: n1.X, Y: n1.Y, Z: blockZ
              });

              // Remove this block from skipped list
              ctx.skippedBlocks.splice(ctx.currentBlockIdx, 1);

              // Remove the corresponding warning
              const warnIdx = data.warnings.findIndex(w => w.includes(`Skipped Block ${sb.blockId}`));
              if (warnIdx >= 0) data.warnings.splice(warnIdx, 1);

              // Refresh preview
              this.openPreview(data);

              // If more skipped blocks, keep modal open
              if (ctx.skippedBlocks.length > 0) {
                this._fixContext.currentBlockIdx = 0;
                this.openFixNode();
              } else {
                this.closeFixNode();
                App.UI.showCanvasMsg('✅ All blocks fixed!');
              }
            } else {
              alert('Failed to create block - some nodes still missing');
            }
          }
        },

        Physics: {
          // Full Geometry Calculation with MOI
          calcSystem(blocks, machines, params) {
            const g = params.gravity || 9.81;
            const rho = params.concreteDensity || 24;
            let totalMass = 0, sumMx = 0, sumMy = 0, sumMz = 0;

            // Separate tracking for blocks and machines (for legacy report)
            let massBlocks = 0, QxBlocks = 0, QyBlocks = 0, QzBlocks = 0;
            let massMachines = 0, QxMachines = 0, QyMachines = 0, QzMachines = 0;

            // Block data - prioritize global density (rho) since blocks don't have individual density UI
            const blockData = blocks.map(b => {
              const sign = b.op === -1 ? -1 : 1;
              const volume = b.L * b.W * b.H;
              const weight = volume * rho; // Use global rho, ignore b.density (legacy/import artifact)
              const mass = sign * weight / g;
              return { mass, cx: b.X + b.L / 2, cy: b.Y + b.W / 2, cz: b.Z + b.H / 2, L: b.L, W: b.W, H: b.H };
            });

            // Machine data
            const machineData = (machines ?? []).map(m => ({
              mass: m.W / g, cx: m.X, cy: m.Y, cz: m.Z, Ix: m.Ix ?? 0, Iy: m.Iy ?? 0, Iz: m.Iz ?? 0
            }));

            // Total Mass & CG - track block contributions
            blockData.forEach(d => {
              totalMass += d.mass;
              sumMx += d.mass * d.cx;
              sumMy += d.mass * d.cy;
              sumMz += d.mass * d.cz;
              massBlocks += d.mass;
              QxBlocks += d.mass * d.cx;
              QyBlocks += d.mass * d.cy;
              QzBlocks += d.mass * d.cz;
            });
            // Track machine contributions
            machineData.forEach(d => {
              totalMass += d.mass;
              sumMx += d.mass * d.cx;
              sumMy += d.mass * d.cy;
              sumMz += d.mass * d.cz;
              massMachines += d.mass;
              QxMachines += d.mass * d.cx;
              QyMachines += d.mass * d.cy;
              QzMachines += d.mass * d.cz;
            });
            const cg = totalMass !== 0 ? { x: sumMx / totalMass, y: sumMy / totalMass, z: sumMz / totalMass } : { x: 0, y: 0, z: 0 };

            // MOI with Parallel Axis Theorem - track separate contributions
            let Ixx = 0, Iyy = 0, Izz = 0;
            let Ixx_blocks = 0, Iyy_blocks = 0, Izz_blocks = 0;
            let Ixx_machines = 0, Iyy_machines = 0, Izz_machines = 0;

            blockData.forEach(d => {
              const Ixx_local = (1 / 12) * d.mass * (d.W ** 2 + d.H ** 2);
              const Iyy_local = (1 / 12) * d.mass * (d.L ** 2 + d.H ** 2);
              const Izz_local = (1 / 12) * d.mass * (d.L ** 2 + d.W ** 2);
              const dx = d.cx - cg.x, dy = d.cy - cg.y, dz = d.cz - cg.z;
              const Ixx_contrib = Ixx_local + d.mass * (dy ** 2 + dz ** 2);
              const Iyy_contrib = Iyy_local + d.mass * (dx ** 2 + dz ** 2);
              const Izz_contrib = Izz_local + d.mass * (dx ** 2 + dy ** 2);
              Ixx += Ixx_contrib; Iyy += Iyy_contrib; Izz += Izz_contrib;
              Ixx_blocks += Ixx_contrib; Iyy_blocks += Iyy_contrib; Izz_blocks += Izz_contrib;
            });
            machineData.forEach(d => {
              const dx = d.cx - cg.x, dy = d.cy - cg.y, dz = d.cz - cg.z;
              const Ixx_contrib = d.Ix + d.mass * (dy ** 2 + dz ** 2);
              const Iyy_contrib = d.Iy + d.mass * (dx ** 2 + dz ** 2);
              const Izz_contrib = d.Iz + d.mass * (dx ** 2 + dy ** 2);
              Ixx += Ixx_contrib; Iyy += Iyy_contrib; Izz += Izz_contrib;
              Ixx_machines += Ixx_contrib; Iyy_machines += Iyy_contrib; Izz_machines += Izz_contrib;
            });

            return {
              mass: totalMass, cg, Ixx, Iyy, Izz,
              // First moments (total)
              Qx: sumMx, Qy: sumMy, Qz: sumMz,
              // Block contributions
              massBlocks, QxBlocks, QyBlocks, QzBlocks, Ixx_blocks, Iyy_blocks, Izz_blocks,
              // Machine contributions
              massMachines, QxMachines, QyMachines, QzMachines, Ixx_machines, Iyy_machines, Izz_machines
            };
          },

          // Full Stiffness Calculation
          calcStiffness(piles, cg) {
            // Calculate pile centroid (NOT system CG) for rocking/torsional stiffness
            const n = piles.length;
            const pileCgX = n > 0 ? piles.reduce((s, p) => s + p.X, 0) / n : 0;
            const pileCgY = n > 0 ? piles.reduce((s, p) => s + p.Y, 0) / n : 0;

            let Kz = 0, Kx = 0, Ky = 0, Kphi_x = 0, Kphi_y = 0, Kpsi = 0;
            piles.forEach(p => {
              const Kv = p.Kv ?? 0, Kh = p.Kh ?? 0;
              const dx = p.X - pileCgX, dy = p.Y - pileCgY;  // Use pile centroid
              Kz += Kv; Kx += Kh; Ky += Kh;
              Kphi_x += Kv * dy ** 2;
              Kphi_y += Kv * dx ** 2;
              Kpsi += Kh * (dx ** 2 + dy ** 2);
            });
            return { Kz, Kx, Ky, Kphi_x, Kphi_y, Kpsi, pileCgX, pileCgY };  // Return pile CG
          },

          // === FOUNDATION CHECKS (Section 6.0) ===
          runStaticChecks(sys, piles, params) {
            const results = {};
            const g = params.gravity || 9.81;

            // Machine weight (kN) and mass (t)
            const machineWeightKN = App.State.machines.reduce((s, m) => s + (m.W || 0), 0);
            const foundationWeightKN = sys.mass * g;

            // === MASS RATIO CHECK (ACI 351.3R) ===
            const massRatio = machineWeightKN > 0 ? foundationWeightKN / machineWeightKN : Infinity;
            const massRatioLimit = params.massRatioMin || 3;
            results.massRatio = {
              ratio: massRatio,
              limit: massRatioLimit,
              pass: massRatio >= massRatioLimit
            };

            // === ECCENTRICITY CHECK (ACI 351.3R) ===
            const stiff = this.calcStiffness(piles, sys.cg);
            const ex = Math.abs(sys.cg.x - stiff.pileCgX);
            const ey = Math.abs(sys.cg.y - stiff.pileCgY);
            // Use foundation dimensions from blocks
            const blocks = App.State.blocks.filter(b => b.op !== -1);
            const minX = Math.min(...blocks.map(b => b.X));
            const maxX = Math.max(...blocks.map(b => b.X + b.L));
            const minY = Math.min(...blocks.map(b => b.Y));
            const maxY = Math.max(...blocks.map(b => b.Y + b.W));
            const Lx = maxX - minX || 1;
            const Ly = maxY - minY || 1;
            const eccLimit = params.eccentricityLimit || 5;
            results.eccentricity = {
              ex, ey,
              exPercent: (ex / Lx) * 100,
              eyPercent: (ey / Ly) * 100,
              limit: eccLimit,
              pass: (ex / Lx) * 100 < eccLimit && (ey / Ly) * 100 < eccLimit
            };

            // === PILE REACTION CHECK ===
            const n = piles.length || 1;
            const W = foundationWeightKN + machineWeightKN;
            // Static loads (wind)
            const windX = App.State.staticLoads?.WindX || 0;
            const windY = App.State.staticLoads?.WindY || 0;
            const windArmZ = App.State.staticLoads?.WindArmZ || (sys.cg.z || 1);
            const Mx_wind = windY * windArmZ; // Moment about X from wind Y
            const My_wind = windX * windArmZ; // Moment about Y from wind X

            // Sum of (xi² + yi²) for pile reactions
            let sumX2 = 0, sumY2 = 0;
            piles.forEach(p => {
              sumX2 += (p.X - stiff.pileCgX) ** 2;
              sumY2 += (p.Y - stiff.pileCgY) ** 2;
            });
            sumX2 = sumX2 || 1; sumY2 = sumY2 || 1;

            // Max/Min reaction: Q = W/n ± Mx*y/ΣY² ± My*x/ΣX²
            let Qmax = 0, Qmin = Infinity;
            piles.forEach(p => {
              const dx = p.X - stiff.pileCgX;
              const dy = p.Y - stiff.pileCgY;
              const Q = W / n + Mx_wind * dy / sumY2 + My_wind * dx / sumX2;
              if (Q > Qmax) Qmax = Q;
              if (Q < Qmin) Qmin = Q;
            });

            const compLimit = params.pileCapacity?.compression || 2500;
            const tensLimit = params.pileCapacity?.tension || 500;
            results.pileReaction = {
              Qmax, Qmin,
              compLimit, tensLimit,
              passComp: Qmax <= compLimit,
              passTens: Qmin >= -tensLimit
            };

            return results;
          },

          // === FREQUENCY TUNING CHECK (DIN 4024) ===
          checkFrequencyTuning(fn, fop, params) {
            const zonePercent = params?.dinZonePercent || 20;
            const lowLimit = fop * (1 - zonePercent / 100);
            const highLimit = fop * (1 + zonePercent / 100);
            const inDanger = fn > lowLimit && fn < highLimit;
            return {
              fn, fop, lowLimit, highLimit,
              zone: fn <= lowLimit ? 'LOW-TUNED' : (fn >= highLimit ? 'HIGH-TUNED' : 'DANGER'),
              pass: !inDanger
            };
          },

          // Full Analysis (Comprehensive - matches legacy output)
          solve(sys, stiff, loads, params) {
            const Dz = params.dampingZ ?? 0.25;
            const Dx = params.dampingX ?? 0.25;
            const Dr = params.dampingRock ?? 0.25;
            const Dt = params.dampingTor ?? 0.25;
            const freqRPM = loads.freq ?? 0;
            const w_op = (freqRPM / 60) * 2 * Math.PI;
            const w_op_sq = w_op ** 2;
            const Fz = loads.Fz ?? 0;
            const Fy = loads.Fy ?? 0;
            const Fx = loads.Fx ?? 0;
            const Wt = sys.mass * (params.gravity ?? 9.81); // Total weight (kN)

            // Get base elevation from blocks or specific override
            let minZ = Infinity;
            App.State.blocks.forEach(b => {
              if (b.op !== -1) minZ = Math.min(minZ, b.Z);
            });
            if (minZ === Infinity) minZ = 0;

            // Use override if available
            const zBottom = (params.zBottomOverride !== undefined && params.zBottomOverride !== null && params.zBottomOverride !== "")
              ? parseFloat(params.zBottomOverride)
              : minZ;

            const h = sys.cg.z - zBottom; // Height from base to CG

            // Compute Ibx_x and Iby_y (MOI about base axis)
            const Ibx_x = sys.Ixx + sys.mass * h ** 2;
            const Iby_y = sys.Iyy + sys.mass * h ** 2;

            // ============ VERTICAL VIBRATION ============
            // Helper: Calculate Magnification Factor
            const calcMF = (gamma, D) => Math.abs(gamma) < 0.001 ? 1 : 1 / Math.sqrt((1 - gamma ** 2) ** 2 + (2 * D * gamma) ** 2);
            const isRecip = App.State.projectInfo?.machineType === 'R';
            const Fz_s = loads.Fz_s ?? 0; // Secondary force (only for Reciprocating)

            let vertical = { fn: 0, fr: 0, gamma: 0, gamma_s: 0, DMF: 0, DMF_s: 0, amp: 0 };
            if (sys.mass > 0 && stiff.Kz > 0) {
              const wn = Math.sqrt(stiff.Kz / sys.mass);
              vertical.fn = (wn / (2 * Math.PI)) * 60;
              // Fr: Reciprocating = Fn × factor (peak left), Centrifugal = Fn / factor (peak right)
              const frFactor = Math.sqrt(Math.max(0.01, 1 - 2 * Dz ** 2));
              vertical.fr = isRecip ? (vertical.fn * frFactor) : (vertical.fn / frFactor);

              // Primary component
              vertical.gamma = w_op / wn;
              vertical.DMF = calcMF(vertical.gamma, Dz);

              // Secondary component (only for Reciprocating at 2×f_op)
              if (isRecip) {
                const w_sec = w_op * 2;
                vertical.gamma_s = w_sec / wn;
                vertical.DMF_s = calcMF(vertical.gamma_s, Dz);
              }

              // Superposition: D = (MFp×Fp + MFs×Fs) / K
              vertical.amp = (vertical.DMF * Fz + vertical.DMF_s * Fz_s) / stiff.Kz;
            }

            // ============ COUPLED Y-DIR + X-X ROTATION ============
            // Legacy formula: Wtrans²=Kh/Mt, Wrotat²=(Kr-Wt×h)/Ib, MU=Wtrans²/Wrotat², GAMA=It/Ib
            const Kh = stiff.Kx; // Horizontal stiffness (Kh = Kx = Ky in legacy)
            let coupled_YXX = { fn1: 0, fn2: 0, Dy: 0, Rxx: 0, Ftrans: 0, Frotat: 0 };
            if (sys.mass > 0 && Ibx_x > 0 && Kh > 0 && stiff.Kphi_x > 0) {
              const Kr = stiff.Kphi_x; // Rocking stiffness about X axis
              const It = sys.Ixx; // MOI at CG
              const Ib = Ibx_x; // MOI about base

              const Wtrans_sq = Kh / sys.mass;
              const Wrotat_sq = (Kr - Wt * h) / Ib;

              if (Wrotat_sq > 0) {
                // Uncoupled natural frequencies
                coupled_YXX.Ftrans = Math.sqrt(Wtrans_sq) / (2 * Math.PI) * 60;
                coupled_YXX.Frotat = Math.sqrt(Wrotat_sq) / (2 * Math.PI) * 60;

                const MU = Wtrans_sq / Wrotat_sq;
                const GAMA = It / Ib;
                const disc = (1 + MU) ** 2 - 4 * GAMA * MU;

                if (disc >= 0) {
                  // Coupled natural frequencies: Wn² = Wrotat²/(2*GAMA) * [1+MU ∓ sqrt((1+MU)²-4*GAMA*MU)]
                  const wn1_sq = (Wrotat_sq / (2 * GAMA)) * (1 + MU - Math.sqrt(disc));
                  const wn2_sq = (Wrotat_sq / (2 * GAMA)) * (1 + MU + Math.sqrt(disc));
                  coupled_YXX.fn1 = wn1_sq > 0 ? Math.sqrt(wn1_sq) / (2 * Math.PI) * 60 : 0;
                  coupled_YXX.fn2 = wn2_sq > 0 ? Math.sqrt(wn2_sq) / (2 * Math.PI) * 60 : 0;

                  // Helper to calculate amplitude at a given excitation frequency
                  const calcCoupledAmplitude = (w_ex_sq, Fy_in, BMx_in) => {
                    const Delta = sys.mass * It * (wn1_sq - w_ex_sq) * (wn2_sq - w_ex_sq);
                    if (Math.abs(Delta) < 1e-20) return { Dy: 0, Rxx: 0 };
                    const A11 = Math.abs(Kh * h ** 2 + Kr - Wt * h - It * w_ex_sq) / Math.abs(Delta);
                    const A12 = Math.abs(Kh * h) / Math.abs(Delta);
                    const A22 = Math.abs(Kh - sys.mass * w_ex_sq) / Math.abs(Delta);

                    const w_ex = Math.sqrt(w_ex_sq);
                    const f_ex = (w_ex / (2 * Math.PI)) * 60;
                    const r1 = f_ex / (coupled_YXX.fn1 || 1);
                    const r2 = f_ex / (coupled_YXX.fn2 || 1);
                    const Ch = Math.abs(1 - r1 ** 2) / Math.sqrt((1 - r1 ** 2) ** 2 + (2 * Dx * r1) ** 2 + 1e-10);
                    const Cr = Math.abs(1 - r2 ** 2) / Math.sqrt((1 - r2 ** 2) ** 2 + (2 * Dr * r2) ** 2 + 1e-10);

                    return {
                      Dy: Ch * (A11 * Fy_in + A12 * BMx_in),
                      Rxx: Cr * (A12 * Fy_in + A22 * BMx_in)
                    };
                  };

                  // Effective moment
                  const Zc = loads.Z ?? 0, Yc = loads.Y ?? 0;
                  const ZCT = sys.cg.z, YCT = sys.cg.y;
                  const BMx_x = (loads.Mx ?? 0) + Math.abs(Fy * (Zc - ZCT)) + Math.abs(Fz * (Yc - YCT));

                  // Primary component
                  const primary_yxx = calcCoupledAmplitude(w_op_sq, Fy, BMx_x);
                  coupled_YXX.Dy = primary_yxx.Dy;
                  coupled_YXX.Rxx = primary_yxx.Rxx;

                  // Secondary component (only for Reciprocating at 2×f_op)
                  if (isRecip) {
                    const w_sec_sq = (w_op * 2) ** 2;
                    const Fy_s = loads.Fy_s ?? 0;
                    const BMx_x_s = (loads.Mx_s ?? 0) + Math.abs(Fy_s * (Zc - ZCT)) + Math.abs(Fz_s * (Yc - YCT));
                    const secondary_yxx = calcCoupledAmplitude(w_sec_sq, Fy_s, BMx_x_s);
                    coupled_YXX.Dy += secondary_yxx.Dy;
                    coupled_YXX.Rxx += secondary_yxx.Rxx;
                  }
                }
              }
            }
            // ============ COUPLED X-DIR + Y-Y ROTATION ============
            let coupled_XYY = { fn1: 0, fn2: 0, Dx: 0, Ryy: 0, Ftrans: 0, Frotat: 0 };
            if (sys.mass > 0 && Iby_y > 0 && Kh > 0 && stiff.Kphi_y > 0) {
              const Kr = stiff.Kphi_y; // Rocking stiffness about Y axis
              const It = sys.Iyy; // MOI at CG
              const Ib = Iby_y; // MOI about base

              const Wtrans_sq = Kh / sys.mass;
              const Wrotat_sq = (Kr - Wt * h) / Ib;

              if (Wrotat_sq > 0) {
                coupled_XYY.Ftrans = Math.sqrt(Wtrans_sq) / (2 * Math.PI) * 60;
                coupled_XYY.Frotat = Math.sqrt(Wrotat_sq) / (2 * Math.PI) * 60;

                const MU = Wtrans_sq / Wrotat_sq;
                const GAMA = It / Ib;
                const disc = (1 + MU) ** 2 - 4 * GAMA * MU;

                if (disc >= 0) {
                  const wn1_sq = (Wrotat_sq / (2 * GAMA)) * (1 + MU - Math.sqrt(disc));
                  const wn2_sq = (Wrotat_sq / (2 * GAMA)) * (1 + MU + Math.sqrt(disc));
                  coupled_XYY.fn1 = wn1_sq > 0 ? Math.sqrt(wn1_sq) / (2 * Math.PI) * 60 : 0;
                  coupled_XYY.fn2 = wn2_sq > 0 ? Math.sqrt(wn2_sq) / (2 * Math.PI) * 60 : 0;

                  // Helper for X-YY mode amplitude calculation
                  const calcCoupledXYY = (w_ex_sq, Fx_in, BMy_in) => {
                    const Delta = sys.mass * It * (wn1_sq - w_ex_sq) * (wn2_sq - w_ex_sq);
                    if (Math.abs(Delta) < 1e-20) return { Dx: 0, Ryy: 0 };
                    const A11 = Math.abs(Kh * h ** 2 + Kr - Wt * h - It * w_ex_sq) / Math.abs(Delta);
                    const A12 = Math.abs(Kh * h) / Math.abs(Delta);
                    const A22 = Math.abs(Kh - sys.mass * w_ex_sq) / Math.abs(Delta);

                    const w_ex = Math.sqrt(w_ex_sq);
                    const f_ex = (w_ex / (2 * Math.PI)) * 60;
                    const r1 = f_ex / (coupled_XYY.fn1 || 1);
                    const r2 = f_ex / (coupled_XYY.fn2 || 1);
                    const Ch = Math.abs(1 - r1 ** 2) / Math.sqrt((1 - r1 ** 2) ** 2 + (2 * Dx * r1) ** 2 + 1e-10);
                    const Cr = Math.abs(1 - r2 ** 2) / Math.sqrt((1 - r2 ** 2) ** 2 + (2 * Dr * r2) ** 2 + 1e-10);

                    return {
                      Dx: Ch * (A11 * Fx_in + A12 * BMy_in),
                      Ryy: Cr * (A12 * Fx_in + A22 * BMy_in)
                    };
                  };

                  const Zc = loads.Z ?? 0, Xc = loads.X ?? 0;
                  const ZCT = sys.cg.z, XCT = sys.cg.x;
                  const BMy_y = (loads.My ?? 0) + Math.abs(Fx * (Zc - ZCT)) + Math.abs(Fz * (Xc - XCT));

                  // Primary component
                  const primary_xyy = calcCoupledXYY(w_op_sq, Fx, BMy_y);
                  coupled_XYY.Dx = primary_xyy.Dx;
                  coupled_XYY.Ryy = primary_xyy.Ryy;

                  // Secondary component (only for Reciprocating)
                  if (isRecip) {
                    const w_sec_sq = (w_op * 2) ** 2;
                    const Fx_s = loads.Fx_s ?? 0;
                    const BMy_y_s = (loads.My_s ?? 0) + Math.abs(Fx_s * (Zc - ZCT)) + Math.abs(Fz_s * (Xc - XCT));
                    const secondary_xyy = calcCoupledXYY(w_sec_sq, Fx_s, BMy_y_s);
                    coupled_XYY.Dx += secondary_xyy.Dx;
                    coupled_XYY.Ryy += secondary_xyy.Ryy;
                  }
                }
              }
            }

            // ============ TORSIONAL VIBRATION ============
            let torsion = { fn: 0, fr: 0, gamma: 0, gamma_s: 0, DMF: 0, DMF_s: 0, Rzz: 0 };
            if (sys.Izz > 0 && stiff.Kpsi > 0) {
              const wn = Math.sqrt(stiff.Kpsi / sys.Izz);
              torsion.fn = (wn / (2 * Math.PI)) * 60;
              // Fr: Reciprocating = Fn × factor (peak left), Centrifugal = Fn / factor (peak right)
              const frFactorT = Math.sqrt(Math.max(0.01, 1 - 2 * Dt ** 2));
              torsion.fr = isRecip ? (torsion.fn * frFactorT) : (torsion.fn / frFactorT);

              // Primary
              torsion.gamma = w_op / wn;
              torsion.DMF = calcMF(torsion.gamma, Dt);

              // Effective torsional moment TMz = Mz + Fx*|Yc-YCT| + Fy*|Xc-XCT|
              const Xc = loads.X ?? 0, Yc = loads.Y ?? 0;
              const XCT = sys.cg.x, YCT = sys.cg.y;
              const TMz = (loads.Mz ?? 0) + Math.abs(Fx * (Yc - YCT)) + Math.abs(Fy * (Xc - XCT));

              // Secondary
              let TMz_s = 0;
              if (isRecip) {
                const Fx_s = loads.Fx_s ?? 0, Fy_s = loads.Fy_s ?? 0;
                const w_sec = w_op * 2;
                torsion.gamma_s = w_sec / wn;
                torsion.DMF_s = calcMF(torsion.gamma_s, Dt);
                TMz_s = (loads.Mz_s ?? 0) + Math.abs(Fx_s * (Yc - YCT)) + Math.abs(Fy_s * (Xc - XCT));
              }

              // Superposition
              torsion.Rzz = (torsion.DMF * TMz + torsion.DMF_s * TMz_s) / stiff.Kpsi;
            }

            // ============ POINT DISPLACEMENTS ============
            const Dz_amp = vertical.amp;
            const Dy_amp = coupled_YXX.Dy;
            const Dx_amp = coupled_XYY.Dx;
            const Rxx = coupled_YXX.Rxx;
            const Ryy = coupled_XYY.Ryy;
            const Rzz = torsion.Rzz;
            const pointResults = [];

            // Collect all check points using comprehensive generator
            const checkPoints = App.Physics.generateCheckPoints();

            checkPoints.forEach(pt => {
              const dx = pt.X - sys.cg.x;
              const dy = pt.Y - sys.cg.y;
              const dz = pt.Z - sys.cg.z;
              const dispZ = Math.abs(Dz_amp) + Math.abs(Rxx * dy) + Math.abs(Ryy * dx);
              const dispX = Math.abs(Dx_amp) + Math.abs(Ryy * dz) + Math.abs(Rzz * dy);
              const dispY = Math.abs(Dy_amp) + Math.abs(Rxx * dz) + Math.abs(Rzz * dx);
              pointResults.push({
                name: pt.name || `Pt`,
                X: pt.X, Y: pt.Y, Z: pt.Z,
                dx, dy, dz,
                dispZ: dispZ, dispX: dispX, dispY: dispY // Single amplitude to match legacy report format
              });
            });

            // Legacy compatibility
            const fn_z = vertical.fn;
            const DMF_z = vertical.DMF;
            const amp_z = vertical.amp;
            const fn_psi = torsion.fn;
            const fn_coupled = Math.min(coupled_YXX.fn1 || Infinity, coupled_XYY.fn1 || Infinity);

            return {
              fn_z, DMF_z, amp_z, fn_psi, fn_coupled,
              vertical, coupled_YXX, coupled_XYY, torsion, pointResults, Ibx_x, Iby_y, h, zBottom
            };
          },
          // Generate comprehensive check points for analysis
          generateCheckPoints() {
            const pts = [];
            const addPt = (X, Y, Z, name) => pts.push({ X, Y, Z, name });

            // 1. User-defined Points
            App.State.points.forEach((p, i) => addPt(p.X, p.Y, p.Z, p.name || `Pt${i + 1}`));

            // 2. Pile Heads
            App.State.piles.forEach((p, i) => addPt(p.X, p.Y, p.Z ?? 0, `Pile${i + 1}`));

            // 3. Load Points
            App.State.loadPoints.forEach((lp, i) => addPt(lp.X, lp.Y, lp.Z, `Load${i + 1}`));

            // 4. Block Top Surfaces (Top-most only) with Virtual Edge Points
            const blocks = App.State.blocks;
            // Determine top-most blocks: a block is "top-most" if no other block covers it from above
            const isTopMost = (b) => {
              const bTop = b.Z + b.H;
              const bXMin = b.X, bXMax = b.X + b.L;
              const bYMin = b.Y, bYMax = b.Y + b.W;
              // Check if any other block is above AND overlaps in XY
              return !blocks.some(other => {
                if (other === b) return false;
                const oBot = other.Z;
                if (oBot < bTop) return false; // Not above
                // Check XY overlap
                const oXMin = other.X, oXMax = other.X + other.L;
                const oYMin = other.Y, oYMax = other.Y + other.W;
                const xOverlap = bXMin < oXMax && bXMax > oXMin;
                const yOverlap = bYMin < oYMax && bYMax > oYMin;
                return xOverlap && yOverlap;
              });
            };

            blocks.forEach((b, bi) => {
              if (!isTopMost(b)) return; // Skip non-top blocks
              const zTop = b.Z + b.H;
              const prefix = `B${bi + 1}`;
              // Corners
              addPt(b.X, b.Y, zTop, `${prefix}_C1`);
              addPt(b.X + b.L, b.Y, zTop, `${prefix}_C2`);
              addPt(b.X + b.L, b.Y + b.W, zTop, `${prefix}_C3`);
              addPt(b.X, b.Y + b.W, zTop, `${prefix}_C4`);
              // Virtual Edge Points (1/4, 1/2, 3/4 along edges)
              const fracs = [0.25, 0.5, 0.75];
              fracs.forEach((f, fi) => {
                // Edge 1: C1→C2 (Y=0)
                addPt(b.X + b.L * f, b.Y, zTop, `${prefix}_E1_${fi + 1}`);
                // Edge 2: C2→C3 (X=L)
                addPt(b.X + b.L, b.Y + b.W * f, zTop, `${prefix}_E2_${fi + 1}`);
                // Edge 3: C3→C4 (Y=W)
                addPt(b.X + b.L * (1 - f), b.Y + b.W, zTop, `${prefix}_E3_${fi + 1}`);
                // Edge 4: C4→C1 (X=0)
                addPt(b.X, b.Y + b.W * (1 - f), zTop, `${prefix}_E4_${fi + 1}`);
              });
            });

            // Deduplicate: remove points with same X,Y,Z coordinates (tolerance 0.001)
            // User-defined points have priority (they are added first)
            const tol = 0.001;
            const unique = [];
            const seen = new Set();
            pts.forEach(pt => {
              const key = `${Math.round(pt.X / tol)}_${Math.round(pt.Y / tol)}_${Math.round(pt.Z / tol)}`;
              if (!seen.has(key)) {
                seen.add(key);
                unique.push(pt);
              }
            });

            return unique;
          },
          getInterestPoints(b) {
            const pts = [];
            // Center
            pts.push({ x: b.X + b.L / 2, y: b.Y + b.W / 2, z: b.Z + b.H / 2, type: 'center' });
            // Corners
            const v = [
              { x: b.X, y: b.Y, z: b.Z }, { x: b.X + b.L, y: b.Y, z: b.Z }, { x: b.X + b.L, y: b.Y + b.W, z: b.Z }, { x: b.X, y: b.Y + b.W, z: b.Z },
              { x: b.X, y: b.Y, z: b.Z + b.H }, { x: b.X + b.L, y: b.Y, z: b.Z + b.H }, { x: b.X + b.L, y: b.Y + b.W, z: b.Z + b.H }, { x: b.X, y: b.Y + b.W, z: b.Z + b.H }
            ];
            v.forEach(p => pts.push({ ...p, type: 'corner' }));
            // Midpoints Base
            pts.push({ x: b.X + b.L / 2, y: b.Y, z: b.Z, type: 'mid' });
            pts.push({ x: b.X + b.L / 2, y: b.Y + b.W, z: b.Z, type: 'mid' });
            pts.push({ x: b.X, y: b.Y + b.W / 2, z: b.Z, type: 'mid' });
            pts.push({ x: b.X + b.L, y: b.Y + b.W / 2, z: b.Z, type: 'mid' });
            // Midpoints Vertical
            pts.push({ x: b.X, y: b.Y, z: b.Z + b.H / 2, type: 'mid' });
            pts.push({ x: b.X + b.L, y: b.Y, z: b.Z + b.H / 2, type: 'mid' });
            pts.push({ x: b.X + b.L, y: b.Y + b.W, z: b.Z + b.H / 2, type: 'mid' });
            pts.push({ x: b.X, y: b.Y + b.W, z: b.Z + b.H / 2, type: 'mid' });
            // Midpoints Top
            pts.push({ x: b.X + b.L / 2, y: b.Y, z: b.Z + b.H, type: 'mid' });
            pts.push({ x: b.X + b.L / 2, y: b.Y + b.W, z: b.Z + b.H, type: 'mid' });
            pts.push({ x: b.X, y: b.Y + b.W / 2, z: b.Z + b.H, type: 'mid' });
            pts.push({ x: b.X + b.L, y: b.Y + b.W / 2, z: b.Z + b.H, type: 'mid' });
            // Face Centers
            pts.push({ x: b.X + b.L / 2, y: b.Y + b.W / 2, z: b.Z, type: 'face' }); // Bottom
            pts.push({ x: b.X + b.L / 2, y: b.Y + b.W / 2, z: b.Z + b.H, type: 'face' }); // Top
            pts.push({ x: b.X + b.L / 2, y: b.Y, z: b.Z + b.H / 2, type: 'face' }); // Front
            pts.push({ x: b.X + b.L / 2, y: b.Y + b.W, z: b.Z + b.H / 2, type: 'face' }); // Back
            pts.push({ x: b.X, y: b.Y + b.W / 2, z: b.Z + b.H / 2, type: 'face' }); // Left
            pts.push({ x: b.X + b.L, y: b.Y + b.W / 2, z: b.Z + b.H / 2, type: 'face' }); // Right
            return pts;
          },

          // Get edges của block (4 cạnh biên + 2 cạnh giữa XY)
          getEdges(b) {
            return [
              { name: 'N', axis: 'y', value: b.Y, x1: b.X, x2: b.X + b.L, z: b.Z },      // Cạnh trên
              { name: 'S', axis: 'y', value: b.Y + b.W, x1: b.X, x2: b.X + b.L, z: b.Z }, // Cạnh dưới
              { name: 'E', axis: 'x', value: b.X + b.L, y1: b.Y, y2: b.Y + b.W, z: b.Z }, // Cạnh phải
              { name: 'W', axis: 'x', value: b.X, y1: b.Y, y2: b.Y + b.W, z: b.Z },        // Cạnh trái
              { name: 'CX', axis: 'x', value: b.X + b.L / 2, y1: b.Y, y2: b.Y + b.W, z: b.Z }, // Centerline X
              { name: 'CY', axis: 'y', value: b.Y + b.W / 2, x1: b.X, x2: b.X + b.L, z: b.Z }  // Centerline Y
            ];
          },
          // UNIVERSAL SNAP ENGINE - supports all element types (blocks, piles, machines)
          solveSnap(movingObj, tentPos, blocks, piles, machines, step, viewMode, movingType = 'block') {
            // CRITICAL FIX: If step is 0 (OFF), skip ALL snapping logic
            if (step <= 0) {
              return { x: tentPos.x, y: tentPos.y, z: tentPos.z, snapped: false, info: '', pt: null, guides: [] };
            }
            // Build snap targets from ALL elements
            const targets = [{ x: 0, y: 0, z: 0, type: 'origin' }];

            // Add block interest points
            blocks.forEach(b => {
              if (!movingObj.id || b.id !== movingObj.id) {
                targets.push(...this.getInterestPoints(b));
              }
            });

            // Add pile positions
            piles.forEach(p => {
              if (!movingObj.id || p.id !== movingObj.id) {
                targets.push({ x: p.X, y: p.Y, z: p.Z || 0, type: 'pile' });
              }
            });

            // Add machine positions
            machines.forEach(m => {
              if (!movingObj.id || m.id !== movingObj.id) {
                targets.push({ x: m.X, y: m.Y, z: m.Z, type: 'machine' });
              }
            });

            // Build snap sources based on moving object type
            let sources = [];
            if (movingType === 'block') {
              const ghost = { ...movingObj, X: tentPos.x, Y: tentPos.y, Z: tentPos.z };
              sources = this.getInterestPoints(ghost);
            } else {
              // For piles and machines, just use their position
              sources = [{ x: tentPos.x, y: tentPos.y, z: tentPos.z, type: movingType }];
            }

            let bestShift = { x: 0, y: 0, z: 0 };
            let minDst = 0.5; // 50cm snap range
            let found = false;
            let info = "";
            let pt = null;
            let guides = [];

            // Track closest point for visual feedback
            let closestDist = Infinity;
            let closestSource = null;
            let closestTarget = null;

            // 1. Point Snap (High Priority)
            for (let s of sources) {
              for (let t of targets) {
                const dx = t.x - s.x, dy = t.y - s.y, dz = t.z - s.z;
                let dist = 0;
                if (viewMode === 'XY') dist = Math.hypot(dx, dy);
                else if (viewMode === 'XZ') dist = Math.hypot(dx, dz);
                else if (viewMode === 'YZ') dist = Math.hypot(dy, dz);
                else dist = Math.hypot(dx, dy, dz);

                // Track closest for visual
                if (dist < closestDist) {
                  closestDist = dist;
                  closestSource = s;
                  closestTarget = t;
                }

                if (dist < minDst) {
                  minDst = dist; bestShift = { x: dx, y: dy, z: dz }; found = true;
                  info = `${s.type} → ${t.type}`; pt = t;
                }
              }
            }

            // Always create guide to closest point
            if (closestSource && closestTarget) {
              const color = found ? 'rgba(59, 130, 246, 0.8)' : 'rgba(59, 130, 246, 0.3)';
              guides = [{ p1: closestSource, p2: closestTarget, color }];
            }

            // 1.5. Edge-to-Edge Snap (ONLY for blocks in XY view)
            if (viewMode === 'XY' && !found && movingType === 'block') {
              const ghost = { ...movingObj, X: tentPos.x, Y: tentPos.y, Z: tentPos.z };
              const ghostEdges = this.getEdges(ghost);
              let minEdgeDist = step > 0 ? step * 2 : 0.5;

              let bestEdgeShift = null;
              let edgeSnapFound = false;
              let edgeInfo = "";
              let edgeGuides = [];

              // Grid axes
              const gridEdges = [
                { name: 'GridY0', axis: 'y', value: 0 },
                { name: 'GridX0', axis: 'x', value: 0 }
              ];

              // Block edges
              blocks.forEach(b => {
                if (b.id !== movingObj.id) {
                  gridEdges.push(...this.getEdges(b));
                }
              });

              // Compare each ghost edge with target edges
              for (let gEdge of ghostEdges) {
                for (let tEdge of gridEdges) {
                  if (gEdge.axis === tEdge.axis) {
                    const dist = Math.abs(gEdge.value - tEdge.value);

                    if (dist < minEdgeDist) {
                      minEdgeDist = dist;
                      const shift = tEdge.value - gEdge.value;

                      if (gEdge.axis === 'x') {
                        bestEdgeShift = { x: shift, y: 0, z: 0 };
                        edgeInfo = `Edge ${gEdge.name} → ${tEdge.name || 'Grid'}`;
                        edgeGuides = [
                          { p1: { x: gEdge.value, y: gEdge.y1, z: 0 }, p2: { x: gEdge.value, y: gEdge.y2, z: 0 }, color: 'rgba(59, 130, 246, 0.5)' },
                          { p1: { x: tEdge.value, y: tEdge.y1 || gEdge.y1, z: 0 }, p2: { x: tEdge.value, y: tEdge.y2 || gEdge.y2, z: 0 }, color: 'rgba(34, 197, 94, 0.8)' }
                        ];
                      } else {
                        bestEdgeShift = { x: 0, y: shift, z: 0 };
                        edgeInfo = `Edge ${gEdge.name} → ${tEdge.name || 'Grid'}`;
                        edgeGuides = [
                          { p1: { x: gEdge.x1, y: gEdge.value, z: 0 }, p2: { x: gEdge.x2, y: gEdge.value, z: 0 }, color: 'rgba(59, 130, 246, 0.5)' },
                          { p1: { x: tEdge.x1 || gEdge.x1, y: tEdge.value, z: 0 }, p2: { x: tEdge.x2 || gEdge.x2, y: tEdge.value, z: 0 }, color: 'rgba(34, 197, 94, 0.8)' }
                        ];
                      }
                      edgeSnapFound = true;
                    }
                  }
                }
              }

              if (edgeSnapFound && bestEdgeShift) {
                bestShift = bestEdgeShift;
                found = true;
                info = edgeInfo;
                guides = edgeGuides;
                pt = null;
              }
            }

            // 2. Grid Snap (Low Priority)
            if (!found && step > 0) {
              const gx = Math.round(tentPos.x / step) * step - tentPos.x;
              const gy = Math.round(tentPos.y / step) * step - tentPos.y;
              const gz = Math.round(tentPos.z / step) * step - tentPos.z;

              if (viewMode === 'XY' || viewMode.includes('ISO')) {
                if (Math.abs(gx) < step * 0.4) { bestShift.x = gx; }
                if (Math.abs(gy) < step * 0.4) { bestShift.y = gy; }
              }
              if (viewMode !== 'XY') {
                if (Math.abs(gz) < step * 0.4) { bestShift.z = gz; }
              }
            }

            let fx = tentPos.x + bestShift.x;
            let fy = tentPos.y + bestShift.y;
            let fz = tentPos.z + bestShift.z;

            // Mask based on view (Prevent jumping in depth if 2D view)
            if (movingType === 'block') {
              if (viewMode === 'XY') fz = movingObj.Z;
              if (viewMode === 'XZ') fy = movingObj.Y;
              if (viewMode === 'YZ') fx = movingObj.X;
            } else if (movingType === 'pile') {
              // Piles always at Z=0
              fz = 0;
              if (viewMode === 'XZ' || viewMode === 'YZ') {
                // In elevation views, only allow XY movement
                if (viewMode === 'XZ') fy = movingObj.Y;
                if (viewMode === 'YZ') fx = movingObj.X;
              }
            } else if (movingType === 'machine') {
              // Machines can move in all dimensions
              if (viewMode === 'XY') fz = movingObj.Z;
              if (viewMode === 'XZ') fy = movingObj.Y;
              if (viewMode === 'YZ') fx = movingObj.X;
            }

            const rnd = v => Math.round(v * 100) / 100;
            return { x: rnd(fx), y: rnd(fy), z: rnd(fz), snapped: found, info, pt, guides };
          }
        },

        // === STANDARDS LIBRARY ===
        Standards: {
          isoClasses: {
            'I': { velocity: 2.8, displacement: 20, acceleration: 0.3 },
            'II': { velocity: 4.5, displacement: 25, acceleration: 0.5 },
            'III': { velocity: 7.1, displacement: 40, acceleration: 0.8 },
            'IV': { velocity: 11.2, displacement: 50, acceleration: 1.0 }
          },
          applyISOClass(cls) {
            const preset = this.isoClasses[cls];
            if (!preset) return;
            const $ = id => document.getElementById(id);
            $('check-iso-vel').value = preset.velocity;
            $('check-iso-disp').value = preset.displacement;
            $('check-iso-acc').value = preset.acceleration;
          },
          resetDefaults() {
            const $ = id => document.getElementById(id);
            // ISO Class II defaults
            $('check-iso-class').value = 'II';
            $('check-iso-vel').value = 4.5;
            $('check-iso-disp').value = 25;
            $('check-iso-acc').value = 0.5;
            // DIN defaults
            $('check-din-zone').value = 20;
            $('check-din-2x').checked = false;
            // ACI defaults
            $('check-aci-mass').value = 3;
            $('check-aci-ecc').value = 5;
            // Pile Capacity defaults
            $('check-pile-comp').value = 2500;
            $('check-pile-tens').value = 500;
            $('check-pile-lat').value = 100;
            App.UI.showCanvasMsg('Reset to defaults');
          }
        },

        Renderer: {
          cv: null, ctx: null, scale: 30, pan: { x: 0, y: 0 },
          // Góc xoay 3D tự do (radians)
          angle3D: { azimuth: Math.PI / 4, elevation: Math.PI / 6 }, // Mặc định giống ISO_SE
          init() {
            this.cv = document.getElementById('mainCanvas');
            this.ctx = this.cv.getContext('2d');
            this.resize();
            window.onresize = () => this.resize();
            this.cv.addEventListener('mousedown', App.Interaction.onDown);
            this.cv.addEventListener('mousemove', App.Interaction.onMove);
            this.cv.addEventListener('mouseup', App.Interaction.onUp);
            this.cv.addEventListener('dblclick', App.Interaction.onDblClick);
            this.cv.addEventListener('wheel', App.Interaction.onWheel, { passive: false });
            App.State.subscribe(() => this.draw());
          },
          resize() {
            this.cv.width = this.cv.parentElement.offsetWidth;
            this.cv.height = this.cv.parentElement.offsetHeight;
            this.pan = { x: this.cv.width / 2, y: this.cv.height / 2 };
            this.draw();
          },
          setView(v) {
            App.State.viewMode = v;
            document.querySelectorAll('#view-XY, #view-XZ, #view-YZ, #view-ISO_SE, #view-ISO_SW, #view-ISO_NE, #view-ISO_NW').forEach(b => {
              if (b) b.className = (b.id === `view-${v}`) ? "px-2 py-0.5 text-[10px] font-bold rounded bg-blue-500 text-white" : "px-2 py-0.5 text-[10px] font-bold rounded text-slate-500 hover:bg-slate-50";
            });
            this.draw();
          },
          project(x, y, z) {
            const vm = App.State.viewMode;
            let u = 0, v = 0;
            if (vm === 'XY') { u = x; v = -y; }
            else if (vm === 'XZ') { u = x; v = -z; }
            else if (vm === 'YZ') { u = y; v = -z; }
            else if (vm === '3D') {
              // 3D tự do với angle3D
              const az = this.angle3D.azimuth;
              const el = this.angle3D.elevation;
              const cosAz = Math.cos(az), sinAz = Math.sin(az);
              const cosEl = Math.cos(el), sinEl = Math.sin(el);

              // Xoay quanh trục Z (azimuth) rồi quanh trục X (elevation)
              const rx = x * cosAz - y * sinAz;
              const ry = x * sinAz + y * cosAz;

              u = rx;
              v = -ry * sinEl - z * cosEl;
            }
            else {
              // ISO preset views
              const kx = vm.includes('SW') || vm.includes('NW') ? -1 : 1;
              const ky = vm.includes('NE') || vm.includes('NW') ? -1 : 1;
              const a = Math.PI / 6;
              u = (kx * x - ky * y) * Math.cos(a);
              v = (kx * x + ky * y) * Math.sin(a) - z;
            }
            return { x: this.pan.x + u * this.scale, y: this.pan.y + v * this.scale };
          },
          unproject(sx, sy) {
            return { u: (sx - this.pan.x) / this.scale, v: (sy - this.pan.y) / this.scale };
          },
          // Tính delta world từ delta screen cho ISO views
          unprojectDelta(du, dv, viewMode) {
            // du, dv là delta screen (đã chia scale)
            // Trả về { dx, dy, dz } - delta world

            if (viewMode === 'XY') {
              return { dx: du, dy: -dv, dz: 0 };
            } else if (viewMode === 'XZ') {
              return { dx: du, dy: 0, dz: -dv };
            } else if (viewMode === 'YZ') {
              return { dx: 0, dy: du, dz: -dv };
            } else if (viewMode.includes('ISO')) {
              // Inverse ISO projection
              // Forward: u = (kx*x - ky*y) * cos(a), v = (kx*x + ky*y) * sin(a) - z
              // Inverse: solve for dx, dy given du, dv (assuming dz = 0)
              const kx = viewMode.includes('SW') || viewMode.includes('NW') ? -1 : 1;
              const ky = viewMode.includes('NE') || viewMode.includes('NW') ? -1 : 1;
              const a = Math.PI / 6;
              const cosA = Math.cos(a);
              const sinA = Math.sin(a);

              // u = (kx*x - ky*y) * cosA  =>  du = (kx*dx - ky*dy) * cosA
              // v = (kx*x + ky*y) * sinA  =>  dv = (kx*dx + ky*dy) * sinA
              // Solve:
              // du/cosA = kx*dx - ky*dy  ... (1)
              // dv/sinA = kx*dx + ky*dy  ... (2)
              // Add (1)+(2): du/cosA + dv/sinA = 2*kx*dx  =>  dx = (du/cosA + dv/sinA) / (2*kx)
              // Sub (1)-(2): du/cosA - dv/sinA = -2*ky*dy =>  dy = (dv/sinA - du/cosA) / (2*ky)

              const dx = (du / cosA + dv / sinA) / (2 * kx);
              const dy = (dv / sinA - du / cosA) / (2 * ky);

              return { dx, dy, dz: 0 };
            } else if (viewMode === '3D') {
              // Inverse rotation dựa trên angle3D hiện tại
              const az = -this.angle3D.azimuth; // Negative để inverse
              const cosAz = Math.cos(az);
              const sinAz = Math.sin(az);

              // Xoay ngược delta về world coordinates
              const dx = du * cosAz - dv * sinAz;
              const dy = du * sinAz + dv * cosAz;

              return { dx, dy, dz: 0 };
            }
            return { dx: du, dy: -dv, dz: 0 };
          },
          draw() {
            const c = this.ctx; c.clearRect(0, 0, this.cv.width, this.cv.height);

            // Pre-build Sets for O(1) visibility lookup (performance optimization)
            const hiddenSet = new Set((App.State.hiddenIds || []).map(h => `${h.type}:${h.id}`));
            const isolatedSet = App.State.isolatedIds && App.State.isolatedIds.length > 0
              ? new Set(App.State.isolatedIds.map(s => `${s.type}:${s.id}`))
              : null;
            const isVisible = (type, id) => {
              const key = `${type}:${id}`;
              if (hiddenSet.has(key)) return false;
              return isolatedSet ? isolatedSet.has(key) : true;
            };

            // Infinite Axes
            const o = this.project(0, 0, 0); const len = 10000;
            const line = (x, y, z, col, dash) => { const p = this.project(x, y, z); c.beginPath(); c.strokeStyle = col; c.setLineDash(dash ? [5, 5] : []); c.moveTo(o.x, o.y); c.lineTo(p.x, p.y); c.stroke(); };
            c.lineWidth = 2;
            line(len, 0, 0, '#ef4444', false); line(-len, 0, 0, '#ef4444', true);
            line(0, len, 0, '#22c55e', false); line(0, -len, 0, '#22c55e', true);
            line(0, 0, len, '#3b82f6', false); line(0, 0, -len, '#3b82f6', true);
            c.setLineDash([]); c.lineWidth = 1;

            // Axis Labels (X, Y, Z) - at canvas edge, gray color
            c.font = 'bold 12px sans-serif';
            const labelDist = 30; // Distance along axis for label position calc
            const clampLabel = (px, py) => {
              // Clamp to canvas bounds with padding
              const pad = 15;
              return {
                x: Math.max(pad, Math.min(this.cv.width - pad, px)),
                y: Math.max(pad, Math.min(this.cv.height - pad, py))
              };
            };
            // X axis label (Red)
            const xEnd = this.project(labelDist, 0, 0);
            const xDir = { x: xEnd.x - o.x, y: xEnd.y - o.y };
            const xLabelPos = clampLabel(o.x + xDir.x * 10, o.y + xDir.y * 10);
            c.fillStyle = '#94a3b8';
            c.textAlign = xDir.x >= 0 ? 'left' : 'right';
            c.textBaseline = 'middle';
            c.fillText('X', xEnd.x > o.x ? this.cv.width - 20 : 20, xEnd.y);

            // Y axis label (Green)
            const yEnd = this.project(0, labelDist, 0);
            c.fillText('Y', yEnd.x, yEnd.y < o.y ? 20 : this.cv.height - 20);

            // Z axis label (Blue) - only in 3D/ISO views
            if (App.State.viewMode !== 'XY') {
              const zEnd = this.project(0, 0, labelDist);
              c.fillText('Z', zEnd.x + 5, zEnd.y < o.y ? 20 : this.cv.height - 20);
            }

            // Adaptive Grid Lines (origin-centered, performance optimized)
            if (App.State.showGrid && App.State.viewMode !== '3D' && !App.State.viewMode.includes('ISO')) {
              const scale = this.scale;
              const minPixelSpacing = 15; // Minimum pixels between grid lines

              // Calculate world spacing needed to achieve minPixelSpacing on screen
              const worldSpacingNeeded = minPixelSpacing / scale;

              // Snap to nice intervals
              const niceIntervals = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000];
              let gridStep = niceIntervals[0];
              for (const interval of niceIntervals) {
                if (interval >= worldSpacingNeeded) {
                  gridStep = interval;
                  break;
                }
              }
              if (worldSpacingNeeded > 1000) {
                gridStep = Math.pow(10, Math.ceil(Math.log10(worldSpacingNeeded)));
              }

              // Major grid every 5 intervals
              const majorStep = gridStep * 5;

              // Calculate visible world bounds
              const w = this.cv.width, h = this.cv.height;
              let minWorldX = (0 - this.pan.x) / scale;
              let maxWorldX = (w - this.pan.x) / scale;
              let minWorldY = (this.pan.y - h) / scale;
              let maxWorldY = (this.pan.y - 0) / scale;

              // Ensure min < max
              if (minWorldX > maxWorldX) [minWorldX, maxWorldX] = [maxWorldX, minWorldX];
              if (minWorldY > maxWorldY) [minWorldY, maxWorldY] = [maxWorldY, minWorldY];

              // Calculate grid lines anchored to origin (must be multiples of step from 0)
              // startX = largest multiple of gridStep <= minWorldX
              // endX = smallest multiple of gridStep >= maxWorldX
              const startX = Math.floor(minWorldX / gridStep) * gridStep;
              const endX = Math.ceil(maxWorldX / gridStep) * gridStep;
              const startY = Math.floor(minWorldY / gridStep) * gridStep;
              const endY = Math.ceil(maxWorldY / gridStep) * gridStep;

              // Performance: limit max lines (prevent lag on very zoomed out views)
              const maxLines = 200;
              const numLinesX = Math.round((endX - startX) / gridStep);
              const numLinesY = Math.round((endY - startY) / gridStep);
              if (numLinesX + numLinesY > maxLines) {
                // Skip grid when too many lines
                c.lineWidth = 1;
              } else {
                c.setLineDash([]);

                // Helper: check if value is major (multiple of majorStep from 0)
                const isMajor = (val) => Math.abs(Math.round(val / majorStep) * majorStep - val) < gridStep * 0.01;

                // Draw minor grid lines (batched for performance)
                c.strokeStyle = 'rgba(147, 197, 253, 0.2)';
                c.lineWidth = 0.5;
                c.beginPath();

                if (App.State.viewMode === 'XY') {
                  for (let x = startX; x <= endX; x += gridStep) {
                    if (isMajor(x)) continue;
                    const p1 = this.project(x, minWorldY, 0);
                    const p2 = this.project(x, maxWorldY, 0);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                  for (let y = startY; y <= endY; y += gridStep) {
                    if (isMajor(y)) continue;
                    const p1 = this.project(minWorldX, y, 0);
                    const p2 = this.project(maxWorldX, y, 0);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                } else if (App.State.viewMode === 'XZ') {
                  for (let x = startX; x <= endX; x += gridStep) {
                    if (isMajor(x)) continue;
                    const p1 = this.project(x, 0, minWorldY);
                    const p2 = this.project(x, 0, maxWorldY);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                  for (let z = startY; z <= endY; z += gridStep) {
                    if (isMajor(z)) continue;
                    const p1 = this.project(minWorldX, 0, z);
                    const p2 = this.project(maxWorldX, 0, z);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                } else if (App.State.viewMode === 'YZ') {
                  for (let y = startX; y <= endX; y += gridStep) {
                    if (isMajor(y)) continue;
                    const p1 = this.project(0, y, minWorldY);
                    const p2 = this.project(0, y, maxWorldY);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                  for (let z = startY; z <= endY; z += gridStep) {
                    if (isMajor(z)) continue;
                    const p1 = this.project(0, minWorldX, z);
                    const p2 = this.project(0, maxWorldX, z);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                }
                c.stroke();

                // Draw major grid lines (batched)
                c.strokeStyle = 'rgba(147, 197, 253, 0.35)';
                c.lineWidth = 0.8;
                c.beginPath();

                // Major lines: start from 0 and go both directions
                const majorStartX = Math.floor(minWorldX / majorStep) * majorStep;
                const majorEndX = Math.ceil(maxWorldX / majorStep) * majorStep;
                const majorStartY = Math.floor(minWorldY / majorStep) * majorStep;
                const majorEndY = Math.ceil(maxWorldY / majorStep) * majorStep;

                if (App.State.viewMode === 'XY') {
                  for (let x = majorStartX; x <= majorEndX; x += majorStep) {
                    const p1 = this.project(x, minWorldY, 0);
                    const p2 = this.project(x, maxWorldY, 0);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                  for (let y = majorStartY; y <= majorEndY; y += majorStep) {
                    const p1 = this.project(minWorldX, y, 0);
                    const p2 = this.project(maxWorldX, y, 0);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                } else if (App.State.viewMode === 'XZ') {
                  for (let x = majorStartX; x <= majorEndX; x += majorStep) {
                    const p1 = this.project(x, 0, minWorldY);
                    const p2 = this.project(x, 0, maxWorldY);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                  for (let z = majorStartY; z <= majorEndY; z += majorStep) {
                    const p1 = this.project(minWorldX, 0, z);
                    const p2 = this.project(maxWorldX, 0, z);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                } else if (App.State.viewMode === 'YZ') {
                  for (let y = majorStartX; y <= majorEndX; y += majorStep) {
                    const p1 = this.project(0, y, minWorldY);
                    const p2 = this.project(0, y, maxWorldY);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                  for (let z = majorStartY; z <= majorEndY; z += majorStep) {
                    const p1 = this.project(0, minWorldX, z);
                    const p2 = this.project(0, maxWorldX, z);
                    c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y);
                  }
                }
                c.stroke();
                c.lineWidth = 1;
              }
            }

            // Piles - 3D Visualization
            // Calculate representative pile length
            let maxH = 0;
            App.State.blocks.forEach(b => maxH = Math.max(maxH, b.H || 1));
            const pileDrawMode = App.State.params.pileDrawMode || 'representative';

            App.State.piles.forEach(p => {
              if (!isVisible('pile', p.id)) return; // Isolate filter
              const sel = App.State.isSelected('pile', p.id);
              const topZ = p.Z || 0;
              const pileLen = pileDrawMode === 'actual' ? (p.length || 10) : (maxH > 0 ? maxH * 2 : 5);
              const botZ = topZ - pileLen;
              const size = p.size || 0.4;
              const r = size / 2;

              const top = this.project(p.X, p.Y, topZ);
              const bot = this.project(p.X, p.Y, botZ);

              // Green color for piles (#22c55e)
              c.fillStyle = sel ? '#fbbf24' : '#22c55e';
              c.strokeStyle = sel ? '#d97706' : '#15803d';
              c.lineWidth = sel ? 2 : 1;

              if (App.State.viewMode === 'XY') {
                // Plan view - draw circle/square
                if (p.shape === 'square') {
                  const half = size / 2;
                  const p1 = this.project(p.X - half, p.Y - half, topZ);
                  const p2 = this.project(p.X + half, p.Y - half, topZ);
                  const p3 = this.project(p.X + half, p.Y + half, topZ);
                  const p4 = this.project(p.X - half, p.Y + half, topZ);
                  c.beginPath();
                  c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y); c.lineTo(p3.x, p3.y); c.lineTo(p4.x, p4.y);
                  c.closePath(); c.fill(); c.stroke();
                } else {
                  // Circle
                  const pR = this.project(p.X + r, p.Y, topZ);
                  const radPx = Math.max(4, Math.hypot(pR.x - top.x, pR.y - top.y));
                  c.beginPath(); c.arc(top.x, top.y, radPx, 0, Math.PI * 2);
                  c.fill(); c.stroke();
                }
              } else {
                // Elevation/ISO View - 3D Shape

                if (p.shape === 'square') {
                  // Square Prism
                  const half = size / 2;
                  // Calculate 4 corners of top and bottom
                  const corners = [
                    { x: p.X - half, y: p.Y - half },
                    { x: p.X + half, y: p.Y - half },
                    { x: p.X + half, y: p.Y + half },
                    { x: p.X - half, y: p.Y + half }
                  ];
                  const tops = corners.map(pt => this.project(pt.x, pt.y, topZ));
                  const bots = corners.map(pt => this.project(pt.x, pt.y, botZ));

                  // Draw 4 vertical edges (shaft)
                  c.beginPath();
                  for (let i = 0; i < 4; i++) {
                    c.moveTo(tops[i].x, tops[i].y);
                    c.lineTo(bots[i].x, bots[i].y);
                  }
                  c.stroke();

                  // Draw Top Cap (Fill)
                  c.beginPath();
                  c.moveTo(tops[0].x, tops[0].y);
                  tops.forEach(t => c.lineTo(t.x, t.y));
                  c.closePath();
                  c.globalAlpha = 0.6; c.fill(); c.globalAlpha = 1.0; c.stroke();

                  // Draw Bottom Cap (Wireframe)
                  c.beginPath();
                  c.moveTo(bots[0].x, bots[0].y);
                  bots.forEach(b => c.lineTo(b.x, b.y));
                  c.closePath();
                  c.stroke();

                } else {
                  // Cylinder (Round) - Proper 3D with ellipse caps
                  // For a vertical cylinder, the cross-section is always a circle of radius r
                  // When viewed from the side (XZ/YZ), it appears as a rectangle of width D (diameter)
                  // The "caps" are ellipses that depend on viewing angle
                  const r = size / 2;

                  if (App.State.viewMode === 'XZ') {
                    // XZ View: Looking along Y axis - cylinder appears as rectangle
                    // Width = D (diameter), Height = pile length
                    // The left/right edges are at X ± r
                    const topL = this.project(p.X - r, p.Y, topZ);
                    const topR = this.project(p.X + r, p.Y, topZ);
                    const botL = this.project(p.X - r, p.Y, botZ);
                    const botR = this.project(p.X + r, p.Y, botZ);
                    // Fill first (single path)
                    c.beginPath();
                    c.moveTo(topL.x, topL.y); c.lineTo(topR.x, topR.y);
                    c.lineTo(botR.x, botR.y); c.lineTo(botL.x, botL.y);
                    c.closePath();
                    c.globalAlpha = 0.3; c.fill(); c.globalAlpha = 1.0;
                    // Stroke all edges in single path
                    c.beginPath();
                    c.moveTo(topL.x, topL.y); c.lineTo(topR.x, topR.y);
                    c.moveTo(botL.x, botL.y); c.lineTo(botR.x, botR.y);
                    c.moveTo(topL.x, topL.y); c.lineTo(botL.x, botL.y);
                    c.moveTo(topR.x, topR.y); c.lineTo(botR.x, botR.y);
                    c.stroke();

                  } else if (App.State.viewMode === 'YZ') {
                    // YZ View: Looking along X axis - cylinder appears as rectangle
                    // Width = D (diameter along Y), Height = pile length
                    const topL = this.project(p.X, p.Y - r, topZ);
                    const topR = this.project(p.X, p.Y + r, topZ);
                    const botL = this.project(p.X, p.Y - r, botZ);
                    const botR = this.project(p.X, p.Y + r, botZ);
                    // Fill first (single path)
                    c.beginPath();
                    c.moveTo(topL.x, topL.y); c.lineTo(topR.x, topR.y);
                    c.lineTo(botR.x, botR.y); c.lineTo(botL.x, botL.y);
                    c.closePath();
                    c.globalAlpha = 0.3; c.fill(); c.globalAlpha = 1.0;
                    // Stroke all edges in single path
                    c.beginPath();
                    c.moveTo(topL.x, topL.y); c.lineTo(topR.x, topR.y);
                    c.moveTo(botL.x, botL.y); c.lineTo(botR.x, botR.y);
                    c.moveTo(topL.x, topL.y); c.lineTo(botL.x, botL.y);
                    c.moveTo(topR.x, topR.y); c.lineTo(botR.x, botR.y);
                    c.stroke();

                  } else {
                    // 3D/ISO Views - Draw proper ellipse caps
                    // Sample 8 points around the circle for accurate ellipse fitting
                    const numSamples = 8;
                    const topPoints = [];
                    const botPoints = [];
                    for (let i = 0; i < numSamples; i++) {
                      const angle = (i / numSamples) * Math.PI * 2;
                      const dx = r * Math.cos(angle);
                      const dy = r * Math.sin(angle);
                      topPoints.push(this.project(p.X + dx, p.Y + dy, topZ));
                      botPoints.push(this.project(p.X + dx, p.Y + dy, botZ));
                    }

                    // Find bounding box to estimate ellipse radii
                    let minTopX = Infinity, maxTopX = -Infinity, minTopY = Infinity, maxTopY = -Infinity;
                    let minBotX = Infinity, maxBotX = -Infinity, minBotY = Infinity, maxBotY = -Infinity;
                    topPoints.forEach(pt => {
                      minTopX = Math.min(minTopX, pt.x); maxTopX = Math.max(maxTopX, pt.x);
                      minTopY = Math.min(minTopY, pt.y); maxTopY = Math.max(maxTopY, pt.y);
                    });
                    botPoints.forEach(pt => {
                      minBotX = Math.min(minBotX, pt.x); maxBotX = Math.max(maxBotX, pt.x);
                      minBotY = Math.min(minBotY, pt.y); maxBotY = Math.max(maxBotY, pt.y);
                    });

                    const topRadX = (maxTopX - minTopX) / 2;
                    const topRadY = (maxTopY - minTopY) / 2;
                    const botRadX = (maxBotX - minBotX) / 2;
                    const botRadY = (maxBotY - minBotY) / 2;

                    // For silhouette edges, find the leftmost and rightmost points
                    let leftTopIdx = 0, rightTopIdx = 0;
                    let leftBotIdx = 0, rightBotIdx = 0;
                    topPoints.forEach((pt, i) => {
                      if (pt.x < topPoints[leftTopIdx].x) leftTopIdx = i;
                      if (pt.x > topPoints[rightTopIdx].x) rightTopIdx = i;
                    });
                    botPoints.forEach((pt, i) => {
                      if (pt.x < botPoints[leftBotIdx].x) leftBotIdx = i;
                      if (pt.x > botPoints[rightBotIdx].x) rightBotIdx = i;
                    });

                    // Draw shaft silhouette edges
                    c.beginPath();
                    c.moveTo(topPoints[leftTopIdx].x, topPoints[leftTopIdx].y);
                    c.lineTo(botPoints[leftTopIdx].x, botPoints[leftTopIdx].y);
                    c.moveTo(topPoints[rightTopIdx].x, topPoints[rightTopIdx].y);
                    c.lineTo(botPoints[rightTopIdx].x, botPoints[rightTopIdx].y);
                    c.stroke();

                    // Draw top ellipse cap
                    c.beginPath();
                    c.ellipse(top.x, top.y, Math.max(4, topRadX), Math.max(2, topRadY), 0, 0, Math.PI * 2);
                    c.globalAlpha = 0.6; c.fill(); c.globalAlpha = 1.0; c.stroke();

                    // Draw bottom ellipse cap
                    c.beginPath();
                    c.ellipse(bot.x, bot.y, Math.max(4, botRadX), Math.max(2, botRadY), 0, 0, Math.PI * 2);
                    c.stroke();
                  }
                }

              }
            });

            // Points - render as crosshairs (Dark Gray)
            App.State.points.forEach(p => {
              if (!isVisible('point', p.id)) return; // Isolate filter
              const pt = this.project(p.X, p.Y, p.Z || 0);
              const sel = App.State.isSelected('point', p.id);

              // Crosshair
              c.strokeStyle = sel ? '#ef4444' : '#374151';
              c.lineWidth = sel ? 2 : 1;
              const sz = 6;
              c.beginPath();
              c.moveTo(pt.x - sz, pt.y); c.lineTo(pt.x + sz, pt.y);
              c.moveTo(pt.x, pt.y - sz); c.lineTo(pt.x, pt.y + sz);
              c.stroke();

              // Dot
              c.fillStyle = sel ? '#ef4444' : '#374151';
              c.beginPath(); c.arc(pt.x, pt.y, 3, 0, Math.PI * 2); c.fill();

              // Name label if selected
              if (sel) {
                c.fillStyle = '#ef4444';
                c.font = '9px sans-serif';
                c.fillText(p.name || 'Point', pt.x + 8, pt.y - 4);
              }
            });

            // Machines
            App.State.machines.forEach(m => {
              if (!isVisible('machine', m.id)) return; // Isolate filter
              const pt = this.project(m.X, m.Y, m.Z);
              const sel = App.State.isSelected('machine', m.id);
              const sz = 12.5; // 25% larger than before
              const rot = (m.rotation || 0) * Math.PI / 180;

              c.save();
              c.translate(pt.x, pt.y);

              // Determine if we show machine profile based on rotation and current view
              // rotation 0° = facing +X (show in XZ view)
              // rotation 90° = facing +Y (show in YZ view)
              // rotation 180° = facing -X (show in XZ view)
              // rotation 270° = facing -Y (show in YZ view)

              const rotDeg = (m.rotation || 0) % 360;
              const showProfile =
                (App.State.viewMode === 'XZ' && (rotDeg < 45 || rotDeg > 315 || (rotDeg > 135 && rotDeg < 225))) ||
                (App.State.viewMode === 'YZ' && ((rotDeg > 45 && rotDeg < 135) || (rotDeg > 225 && rotDeg < 315)));

              if (App.State.viewMode === 'XY') {
                // Plan view: Diamond shape with rotation indicator
                c.rotate(rot);
                c.beginPath();
                c.moveTo(0, -sz);
                c.lineTo(sz, 0);
                c.lineTo(0, sz);
                c.lineTo(-sz, 0);
                c.closePath();
                c.fillStyle = sel ? '#c026d3' : '#e879f9';
                c.fill();
                c.strokeStyle = sel ? '#7c3aed' : '#a855f7';
                c.lineWidth = sel ? 2 : 1;
                c.stroke();

                // Direction indicator (arrow)
                c.beginPath();
                c.moveTo(0, -sz * 0.3);
                c.lineTo(sz * 0.5, 0);
                c.lineTo(0, sz * 0.3);
                c.strokeStyle = 'white';
                c.lineWidth = 1.5;
                c.stroke();
              } else if (showProfile) {
                // Elevation view matching rotation: Show machine profile (cross-section)
                const baseH = sz * 0.5;

                // Base/foundation (trapezoidal)
                c.beginPath();
                c.moveTo(-sz, 0);
                c.lineTo(sz, 0);
                c.lineTo(sz * 0.7, baseH);
                c.lineTo(-sz * 0.7, baseH);
                c.closePath();
                c.fillStyle = '#6b7280';
                c.fill();

                // Machine body (circle)
                c.beginPath();
                c.arc(0, -sz * 0.5, sz * 0.8, 0, Math.PI * 2);
                c.fillStyle = sel ? '#c026d3' : '#e879f9';
                c.fill();
                c.strokeStyle = sel ? '#7c3aed' : '#a855f7';
                c.lineWidth = sel ? 2 : 1;
                c.stroke();

                // Shaft (horizontal line)
                c.beginPath();
                c.moveTo(-sz * 0.6, -sz * 0.5);
                c.lineTo(sz * 0.6, -sz * 0.5);
                c.strokeStyle = 'white';
                c.lineWidth = 2;
                c.stroke();
              } else {
                // Other elevation views: Use diamond shape
                c.beginPath();
                c.moveTo(0, -sz);
                c.lineTo(sz * 0.6, 0);
                c.lineTo(0, sz);
                c.lineTo(-sz * 0.6, 0);
                c.closePath();
                c.fillStyle = sel ? '#c026d3' : '#e879f9';
                c.fill();
                c.strokeStyle = sel ? '#7c3aed' : '#a855f7';
                c.lineWidth = sel ? 2 : 1;
                c.stroke();
              }

              c.restore();

              // Machine name label
              if (App.State.showNames) {
                c.fillStyle = '#6b21a8';
                c.font = '9px sans-serif';
                c.textAlign = 'center';
                c.fillText(m.name, pt.x, pt.y + sz + 8);
              }
            });

            // Draw Assemblies (Anchor + Wireframe) - only if visible
            if (App.State.showAssemblies) {
              App.State.assemblies.forEach(asm => {
                if (!isVisible('assembly', asm.id)) return; // Isolate filter
                const anchor = this.project(asm.X, asm.Y, asm.Z);
                const sel = App.State.isSelected('assembly', asm.id);

                // Anchor point - crosshair + dot (orange)
                c.fillStyle = sel ? '#f59e0b' : '#fb923c';
                c.strokeStyle = sel ? '#d97706' : '#ea580c';
                c.lineWidth = sel ? 2 : 1;

                // Crosshair
                const sz = 7;
                c.beginPath();
                c.moveTo(anchor.x - sz, anchor.y); c.lineTo(anchor.x + sz, anchor.y);
                c.moveTo(anchor.x, anchor.y - sz); c.lineTo(anchor.x, anchor.y + sz);
                c.stroke();

                // Center dot
                c.beginPath();
                c.arc(anchor.x, anchor.y, 4, 0, Math.PI * 2);
                c.fill();

                // Wireframe to components (dashed lines)
                c.setLineDash([2, 2]);
                c.strokeStyle = '#fdba74';
                c.lineWidth = 1;
                asm.components.forEach(comp => {
                  const rad = (asm.rotation || 0) * Math.PI / 180;
                  const cx = asm.X + (comp.dx * Math.cos(rad) - comp.dy * Math.sin(rad));
                  const cy = asm.Y + (comp.dx * Math.sin(rad) + comp.dy * Math.cos(rad));
                  const cz = asm.Z + comp.dz;
                  const compPt = this.project(cx, cy, cz);

                  // Line from anchor to component
                  c.beginPath();
                  c.moveTo(anchor.x, anchor.y);
                  c.lineTo(compPt.x, compPt.y);
                  c.stroke();

                  // Component dot (small)
                  c.fillStyle = '#fb923c';
                  c.beginPath();
                  c.arc(compPt.x, compPt.y, 3, 0, Math.PI * 2);
                  c.fill();

                  // Component name label (at offset position)
                  if (App.State.showNames && comp.name) {
                    c.fillStyle = '#c2410c';
                    c.font = '8px sans-serif';
                    c.textAlign = 'left';
                    c.fillText(comp.name, compPt.x + 5, compPt.y + 3);
                  }
                });
                c.setLineDash([]);

                // Label (name only, subtle)
                if (App.State.showNames || sel) {
                  c.fillStyle = '#9a3412';
                  c.font = '9px sans-serif';
                  c.textAlign = 'left';
                  c.fillText(asm.name, anchor.x + 10, anchor.y - 8);
                }
              });
            }

            // Draw Blocks
            const blocks = App.State.blocks; // Declare blocks variable
            blocks.forEach(b => {
              if (!isVisible('block', b.id)) return; // Isolate filter
              const v = [
                this.project(b.X, b.Y, b.Z),
                this.project(b.X + b.L, b.Y, b.Z),
                this.project(b.X + b.L, b.Y + b.W, b.Z),
                this.project(b.X, b.Y + b.W, b.Z),
                this.project(b.X, b.Y, b.Z + b.H),
                this.project(b.X + b.L, b.Y, b.Z + b.H),
                this.project(b.X + b.L, b.Y + b.W, b.Z + b.H),
                this.project(b.X, b.Y + b.W, b.Z + b.H)
              ];

              const sel = App.State.isSelected('block', b.id);
              const hov = App.Interaction.hover.id === b.id;

              // Render style for Subtract block
              c.beginPath();
              if (b.op === -1) {
                c.setLineDash([5, 5]);
                c.strokeStyle = sel ? '#ef4444' : '#94a3b8'; // Red if selected, Gray if not
              } else {
                c.setLineDash([]);
                c.strokeStyle = sel ? '#f59e0b' : '#0f172a';
              }
              c.lineWidth = sel ? 2 : 1;

              // Edges
              const edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [1, 5], [2, 6], [3, 7]];
              c.beginPath(); edges.forEach(e => { c.moveTo(v[e[0]].x, v[e[0]].y); c.lineTo(v[e[1]].x, v[e[1]].y); }); c.stroke();

              // Face
              c.fillStyle = sel ? 'rgba(245, 158, 11, 0.2)' : (hov ? 'rgba(59, 130, 246, 0.1)' : 'rgba(59, 130, 246, 0.05)');
              c.beginPath();
              if (App.State.viewMode === 'XY') { c.moveTo(v[0].x, v[0].y); c.lineTo(v[1].x, v[1].y); c.lineTo(v[2].x, v[2].y); c.lineTo(v[3].x, v[3].y); }
              else if (App.State.viewMode === 'XZ') { c.moveTo(v[0].x, v[0].y); c.lineTo(v[1].x, v[1].y); c.lineTo(v[5].x, v[5].y); c.lineTo(v[4].x, v[4].y); }
              else { c.moveTo(v[0].x, v[0].y); c.lineTo(v[1].x, v[1].y); c.lineTo(v[2].x, v[2].y); c.lineTo(v[3].x, v[3].y); }
              c.fill();

              // Highlight Hover Edge (Cạnh sáng xanh khi hover)
              if (App.State.viewMode === 'XY' && App.Interaction.hover.edge && hov) {
                c.beginPath(); c.strokeStyle = '#3b82f6'; c.lineWidth = 4; c.lineCap = 'round';
                if (App.Interaction.hover.edge === 'E') { c.moveTo(v[1].x, v[1].y); c.lineTo(v[2].x, v[2].y); }
                if (App.Interaction.hover.edge === 'W') { c.moveTo(v[0].x, v[0].y); c.lineTo(v[3].x, v[3].y); }
                if (App.Interaction.hover.edge === 'S') { c.moveTo(v[2].x, v[2].y); c.lineTo(v[3].x, v[3].y); }
                if (App.Interaction.hover.edge === 'N') { c.moveTo(v[0].x, v[0].y); c.lineTo(v[1].x, v[1].y); }
                c.stroke(); c.lineWidth = 1; c.lineCap = 'butt';
              }
            });

            // === LOAD POINTS VISUALIZATION ===
            // Render each load point as red circle with force arrows
            const machineType = App.State.projectInfo.machineType || 'C';
            const arrowLen = 40;
            const arrowHead = 8;

            // Helper: draw arrow
            const drawLoadArrow = (sx, sy, ex, ey, color, isSecondary = false) => {
              c.save();
              c.strokeStyle = color;
              c.fillStyle = color;
              c.lineWidth = isSecondary ? 1.5 : 2;
              if (isSecondary) c.setLineDash([4, 2]);
              c.beginPath();
              c.moveTo(sx, sy);
              c.lineTo(ex, ey);
              c.stroke();
              c.setLineDash([]);
              const ang = Math.atan2(ey - sy, ex - sx);
              c.beginPath();
              c.moveTo(ex, ey);
              c.lineTo(ex - arrowHead * Math.cos(ang - Math.PI / 6), ey - arrowHead * Math.sin(ang - Math.PI / 6));
              c.lineTo(ex - arrowHead * Math.cos(ang + Math.PI / 6), ey - arrowHead * Math.sin(ang + Math.PI / 6));
              c.closePath();
              c.fill();
              c.restore();
            };

            // Get arrow end based on view
            const getLoadArrowEnd = (lpPt, lp, axis, sign) => {
              const len = sign > 0 ? arrowLen : -arrowLen;
              if (App.State.viewMode === 'XY') {
                if (axis === 'X') return { x: lpPt.x + len, y: lpPt.y };
                if (axis === 'Y') return { x: lpPt.x, y: lpPt.y - len };
                if (axis === 'Z') return null;
              } else if (App.State.viewMode === 'XZ') {
                if (axis === 'X') return { x: lpPt.x + len, y: lpPt.y };
                if (axis === 'Y') return null;
                if (axis === 'Z') return { x: lpPt.x, y: lpPt.y - len };
              } else if (App.State.viewMode === 'YZ') {
                if (axis === 'X') return null;
                if (axis === 'Y') return { x: lpPt.x + len, y: lpPt.y };
                if (axis === 'Z') return { x: lpPt.x, y: lpPt.y - len };
              } else {
                const d = len * 0.02;
                let pt;
                if (axis === 'X') pt = this.project(lp.X + d, lp.Y, lp.Z);
                if (axis === 'Y') pt = this.project(lp.X, lp.Y + d, lp.Z);
                if (axis === 'Z') pt = this.project(lp.X, lp.Y, lp.Z + d);
                const dx = pt.x - lpPt.x, dy = pt.y - lpPt.y;
                const mag = Math.hypot(dx, dy) || 1;
                return { x: lpPt.x + (dx / mag) * arrowLen, y: lpPt.y + (dy / mag) * arrowLen };
              }
            };

            App.State.loadPoints.forEach(lp => {
              if (!isVisible('load', lp.id)) return; // Isolate filter
              const lpPt = this.project(lp.X, lp.Y, lp.Z);
              const selLP = App.State.isSelected('load', lp.id);

              // Draw red circle at load point
              c.save();
              c.fillStyle = selLP ? '#f59e0b' : '#dc2626'; // Amber if selected, Red otherwise
              c.strokeStyle = selLP ? '#f59e0b' : '#991b1b';
              c.lineWidth = selLP ? 3 : 2;
              c.beginPath();
              c.arc(lpPt.x, lpPt.y, 6, 0, Math.PI * 2);
              c.fill();
              c.stroke();
              c.restore();

              // Draw primary force arrows
              if (lp.Fx && lp.Fx !== 0) {
                const end = getLoadArrowEnd(lpPt, lp, 'X', Math.sign(lp.Fx));
                if (end) drawLoadArrow(lpPt.x, lpPt.y, end.x, end.y, '#ef4444');
              }
              if (lp.Fy && lp.Fy !== 0) {
                const end = getLoadArrowEnd(lpPt, lp, 'Y', Math.sign(lp.Fy));
                if (end) drawLoadArrow(lpPt.x, lpPt.y, end.x, end.y, '#22c55e');
              }
              if (lp.Fz && lp.Fz !== 0) {
                const end = getLoadArrowEnd(lpPt, lp, 'Z', Math.sign(lp.Fz));
                if (end) drawLoadArrow(lpPt.x, lpPt.y, end.x, end.y, '#3b82f6');
              }

              // Secondary arrows for Type R
              if (machineType === 'R') {
                if (lp.Fx2 && lp.Fx2 !== 0) {
                  const end = getLoadArrowEnd(lpPt, lp, 'X', Math.sign(lp.Fx2));
                  if (end) drawLoadArrow(lpPt.x + 4, lpPt.y, end.x + 4, end.y, '#ef4444', true);
                }
                if (lp.Fy2 && lp.Fy2 !== 0) {
                  const end = getLoadArrowEnd(lpPt, lp, 'Y', Math.sign(lp.Fy2));
                  if (end) drawLoadArrow(lpPt.x + 4, lpPt.y, end.x + 4, end.y, '#22c55e', true);
                }
                if (lp.Fz2 && lp.Fz2 !== 0) {
                  const end = getLoadArrowEnd(lpPt, lp, 'Z', Math.sign(lp.Fz2));
                  if (end) drawLoadArrow(lpPt.x + 4, lpPt.y, end.x + 4, end.y, '#3b82f6', true);
                }
              }

              // Compact label: Type X Y Z (e.g. "C 4 4 4" or "R 4 4 4 / 5 5 5")
              c.save();
              c.font = 'bold 9px monospace';
              let labelX = lpPt.x + 10;
              let labelY = lpPt.y - 5;
              const lpType = lp.type || 'C';

              // Primary forces line: "C 4.0 4.0 4.0" or "R 4.0 4.0 4.0"
              c.fillStyle = '#333';
              let primaryLabel = `${lpType} `;
              c.fillText(primaryLabel, labelX, labelY);
              let xOff = 12;
              c.fillStyle = '#ef4444'; c.fillText((lp.Fx || 0).toFixed(1), labelX + xOff, labelY); xOff += 28;
              c.fillStyle = '#22c55e'; c.fillText((lp.Fy || 0).toFixed(1), labelX + xOff, labelY); xOff += 28;
              c.fillStyle = '#3b82f6'; c.fillText((lp.Fz || 0).toFixed(1), labelX + xOff, labelY);

              // Secondary line for Type R: "  / 5.0 5.0 5.0"
              if (lpType === 'R') {
                labelY += 10;
                c.fillStyle = '#999';
                c.fillText('  / ', labelX, labelY);
                xOff = 12;
                c.fillStyle = '#ef4444'; c.fillText((lp.Fx2 || 0).toFixed(1), labelX + xOff, labelY); xOff += 28;
                c.fillStyle = '#22c55e'; c.fillText((lp.Fy2 || 0).toFixed(1), labelX + xOff, labelY); xOff += 28;
                c.fillStyle = '#3b82f6'; c.fillText((lp.Fz2 || 0).toFixed(1), labelX + xOff, labelY);
              }
              c.restore();
            });

            // 4. Snap Guides (Đường gióng Magenta)
            if (App.Interaction.snapInfo && App.Interaction.snapInfo.guides) {
              c.save();
              App.Interaction.snapInfo.guides.forEach(g => {
                const p1 = this.project(g.p1.x, g.p1.y, g.p1.z);
                const p2 = this.project(g.p2.x, g.p2.y, g.p2.z);
                c.beginPath(); c.setLineDash([4, 4]); c.strokeStyle = g.color; c.lineWidth = 1.5;
                c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y); c.stroke();
              });
              c.restore();
            }

            // 5. Active Snap Point (Vòng tròn + Crosshair)
            if (App.Interaction.snapInfo && App.Interaction.snapInfo.pt) {
              const pt = this.project(App.Interaction.snapInfo.pt.x, App.Interaction.snapInfo.pt.y, App.Interaction.snapInfo.pt.z);
              c.beginPath(); c.strokeStyle = 'rgba(255, 0, 0, 0.5)'; c.lineWidth = 2; c.arc(pt.x, pt.y, 6, 0, Math.PI * 2); c.stroke(); // Faint Red Circle
              c.beginPath(); c.lineWidth = 1; c.moveTo(pt.x - 10, pt.y); c.lineTo(pt.x + 10, pt.y); c.moveTo(pt.x, pt.y - 10); c.lineTo(pt.x, pt.y + 10); c.stroke();
            }

            // 6. Block Names (nếu enabled - cho TẤT CẢ views)
            if (App.State.showNames) {
              c.save();
              c.fillStyle = '#1e293b';
              c.font = '10px sans-serif';
              c.textAlign = 'center';
              c.textBaseline = 'middle';
              App.State.blocks.forEach(b => {
                const center = this.project(b.X + b.L / 2, b.Y + b.W / 2, b.Z);
                c.fillText(b.name, center.x, center.y);
              });
              c.restore();
            }

            // 7. Sweep Node Highlight (Red Circle for selected analysis point)
            if (App.UI.resultMode && App.UI.currentResTab === 'graphs' && App.UI.lastResults?.result?.pointResults) {
              const selIdx = App.UI.selectedSweepNode || 0;
              const selectedPt = App.UI.lastResults.result.pointResults[selIdx];
              if (selectedPt) {
                const pt = this.project(selectedPt.X, selectedPt.Y, selectedPt.Z);
                c.save();
                // Outer glow
                c.beginPath();
                c.arc(pt.x, pt.y, 12, 0, Math.PI * 2);
                c.fillStyle = 'rgba(239, 68, 68, 0.2)';
                c.fill();
                // Main circle
                c.beginPath();
                c.arc(pt.x, pt.y, 8, 0, Math.PI * 2);
                c.strokeStyle = '#dc2626';
                c.lineWidth = 3;
                c.stroke();
                // Inner dot
                c.beginPath();
                c.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
                c.fillStyle = '#dc2626';
                c.fill();
                // Label
                c.font = 'bold 10px sans-serif';
                c.fillStyle = '#dc2626';
                c.textAlign = 'left';
                c.fillText(selectedPt.name || 'Node', pt.x + 14, pt.y + 4);
                c.restore();
              }
            }

            // 7. Box Selection Rectangle
            if (App.Interaction.boxSelect.active) {
              const box = App.Interaction.boxSelect;
              c.save();
              c.beginPath();
              const x = Math.min(box.startX, box.endX);
              const y = Math.min(box.startY, box.endY);
              const w = Math.abs(box.endX - box.startX);
              const h = Math.abs(box.endY - box.startY);

              if (box.isLeftToRight) {
                // Blue solid for L→R (full containment)
                c.strokeStyle = '#3b82f6';
                c.fillStyle = 'rgba(59, 130, 246, 0.1)';
                c.setLineDash([]);
              } else {
                // Green dashed for R→L (intersection)
                c.strokeStyle = '#22c55e';
                c.fillStyle = 'rgba(34, 197, 94, 0.1)';
                c.setLineDash([5, 3]);
              }
              c.lineWidth = 1;
              c.rect(x, y, w, h);
              c.fill();
              c.stroke();
              c.restore();
            }
          }
        },

        Interaction: {
          drag: { active: false, startScreen: { x: 0, y: 0 }, startObj: null, startObjs: [] },
          hover: { id: null, edge: null },
          snapInfo: null,
          isPan: false,
          isRotate: false,
          lastMousePos: { x: 0, y: 0 },
          boxSelect: { active: false, startX: 0, startY: 0, endX: 0, endY: 0, isLeftToRight: true },
          pendingDraw: false,
          // RAF-throttled draw to ensure 60fps max
          requestDraw() {
            if (this.pendingDraw) return;
            this.pendingDraw = true;
            requestAnimationFrame(() => {
              this.pendingDraw = false;
              App.Renderer.draw();
            });
          },

          onDown(e) {
            const r = e.target.getBoundingClientRect();
            const mx = e.clientX - r.left, my = e.clientY - r.top;

            // Block all interactions if model disabled
            if (!App.State.enableModel) {
              e.preventDefault();
              return;
            }

            // Shift + Middle = Xoay 3D (block if rotate disabled)
            if (e.button === 1 && e.shiftKey) {
              if (!App.State.enableRotate) return; // Block rotation
              App.Interaction.isRotate = true;
              App.Interaction.lastMousePos = { x: mx, y: my };
              e.target.style.cursor = 'move';
              e.preventDefault();
              return;
            }

            // Middle only = Pan
            if (e.button === 1 || e.ctrlKey && e.button !== 0) { App.Interaction.isPan = true; e.target.style.cursor = 'grabbing'; return; }

            const w = App.Renderer.unproject(mx, my);

            // Hit Test - Priority: LoadPoint > Points > Machines > Piles > Blocks
            let hit = null;

            // Check loadPoints first (highest priority)
            for (let lp of App.State.loadPoints) {
              const lpPt = App.Renderer.project(lp.X, lp.Y, lp.Z);
              if (Math.hypot(mx - lpPt.x, my - lpPt.y) < 12) { hit = { type: 'load', id: lp.id, obj: { ...lp } }; break; }
            }

            // Check points next
            if (!hit) {
              for (let p of App.State.points) {
                const pt = App.Renderer.project(p.X, p.Y, p.Z || 0);
                if (Math.hypot(mx - pt.x, my - pt.y) < 10) { hit = { type: 'point', id: p.id, obj: { ...p } }; break; }
              }
            }

            // Check assemblies (only if visible)
            if (!hit && App.State.showAssemblies) {
              for (let asm of App.State.assemblies) {
                const pt = App.Renderer.project(asm.X, asm.Y, asm.Z);
                if (Math.hypot(mx - pt.x, my - pt.y) < 10) { hit = { type: 'assembly', id: asm.id, obj: { ...asm } }; break; }
              }
            }

            // Check machines
            if (!hit) {
              for (let m of App.State.machines) {
                const pt = App.Renderer.project(m.X, m.Y, m.Z);
                if (Math.hypot(mx - pt.x, my - pt.y) < 12) { hit = { type: 'machine', id: m.id, obj: { ...m } }; break; }
              }
            }

            // Then check piles
            if (!hit) {
              for (let p of App.State.piles) {
                const pt = App.Renderer.project(p.X, p.Y, p.Z || 0);
                const size = p.size || 0.4;
                const r = size / 2;
                const pR = App.Renderer.project(p.X + r, p.Y, p.Z || 0);
                const radPx = Math.max(8, Math.hypot(pR.x - pt.x, pR.y - pt.y));
                if (Math.hypot(mx - pt.x, my - pt.y) < radPx + 2) { hit = { type: 'pile', id: p.id, obj: { ...p } }; break; }
              }
            }

            // Finally check blocks
            if (!hit) {
              for (let i = App.State.blocks.length - 1; i >= 0; i--) {
                let b = App.State.blocks[i];
                // Simple bounding box of projection for hit test
                const v = [b.X, b.X + b.L, b.X + b.L, b.X, b.X, b.X + b.L, b.X + b.L, b.X].map((val, k) => {
                  const vy = k < 4 ? b.Y : b.Y + b.W; const vz = k < 4 ? b.Z : b.Z + b.H;
                  return App.Renderer.project(val, vy, vz);
                });
                const minX = Math.min(...v.map(k => k.x)), maxX = Math.max(...v.map(k => k.x));
                const minY = Math.min(...v.map(k => k.y)), maxY = Math.max(...v.map(k => k.y));
                if (mx >= minX && mx <= maxX && my >= minY && my <= maxY) { hit = { type: 'block', id: b.id, obj: { ...b } }; break; }
              }
            }

            if (hit) {
              // Ctrl+click for multi-select toggle
              if (e.ctrlKey) {
                App.State.toggleSelection(hit.type, hit.id, true);
                // Only start drag if NOT locked
                if (App.State.enableDrag && App.State.isSelected(hit.type, hit.id)) {
                  // Capture initial positions of ALL selected objects
                  const startObjs = App.State.selectedIds.map(s => {
                    let obj = null;
                    if (s.type === 'block') obj = App.State.blocks.find(x => x.id === s.id);
                    if (s.type === 'pile') obj = App.State.piles.find(x => x.id === s.id);
                    if (s.type === 'machine') obj = App.State.machines.find(x => x.id === s.id);
                    if (s.type === 'point') obj = App.State.points.find(x => x.id === s.id);
                    if (s.type === 'load') obj = App.State.loadPoints.find(x => x.id === s.id);
                    return obj ? { type: s.type, id: s.id, startX: obj.X, startY: obj.Y, startZ: obj.Z || 0 } : null;
                  }).filter(Boolean);
                  App.Interaction.drag = { active: true, startScreen: { x: w.u, y: w.v }, startObj: hit.obj, startObjs };
                }
              } else {
                // If clicking on an already selected object, start multi-drag (if not locked)
                if (App.State.enableDrag && App.State.isSelected(hit.type, hit.id) && App.State.selectedIds.length > 1) {
                  const startObjs = App.State.selectedIds.map(s => {
                    let obj = null;
                    if (s.type === 'block') obj = App.State.blocks.find(x => x.id === s.id);
                    if (s.type === 'pile') obj = App.State.piles.find(x => x.id === s.id);
                    if (s.type === 'machine') obj = App.State.machines.find(x => x.id === s.id);
                    if (s.type === 'point') obj = App.State.points.find(x => x.id === s.id);
                    if (s.type === 'load') obj = App.State.loadPoints.find(x => x.id === s.id);
                    return obj ? { type: s.type, id: s.id, startX: obj.X, startY: obj.Y, startZ: obj.Z || 0 } : null;
                  }).filter(Boolean);
                  App.Interaction.drag = { active: true, startScreen: { x: w.u, y: w.v }, startObj: hit.obj, startObjs };
                } else {
                  // Single selection case - drag only if not locked
                  App.State.setSelection(hit.type, hit.id);
                  if (App.State.enableDrag) {
                    App.Interaction.drag = { active: true, startScreen: { x: w.u, y: w.v }, startObj: hit.obj, startObjs: [{ type: hit.type, id: hit.id, startX: hit.obj.X, startY: hit.obj.Y, startZ: hit.obj.Z || 0 }] };
                  }
                }
              }
              App.UI.render();
            } else {
              // Start box selection when clicking empty space
              if (!e.ctrlKey) {
                App.State.clearSelection();
              }
              App.Interaction.boxSelect = {
                active: true,
                startX: mx,
                startY: my,
                endX: mx,
                endY: my,
                isLeftToRight: true
              };
            }
            App.Renderer.draw();
          },

          onMove(e) {
            const r = e.target.getBoundingClientRect();
            const mx = e.clientX - r.left, my = e.clientY - r.top;

            // Xoay 3D liên tục
            if (App.Interaction.isRotate) {
              const dx = mx - App.Interaction.lastMousePos.x;
              const dy = my - App.Interaction.lastMousePos.y;
              App.Interaction.lastMousePos = { x: mx, y: my };

              // Cập nhật góc xoay 3D
              App.Renderer.angle3D.azimuth += dx * 0.01;
              App.Renderer.angle3D.elevation = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, App.Renderer.angle3D.elevation + dy * 0.01));

              // Chuyển sang 3D mode nếu chưa
              if (App.State.viewMode !== '3D') {
                App.State.viewMode = '3D';
                // Update button styles
                document.querySelectorAll('#view-XY, #view-XZ, #view-YZ, #view-ISO_SE, #view-ISO_SW, #view-ISO_NE, #view-ISO_NW').forEach(b => {
                  if (b) b.className = "px-2 py-0.5 text-[10px] font-bold rounded text-slate-500 hover:bg-slate-50";
                });
              }

              App.Interaction.requestDraw();
              return;
            }

            if (App.Interaction.isPan) { App.Renderer.pan.x += e.movementX; App.Renderer.pan.y += e.movementY; App.Interaction.requestDraw(); return; }

            App.Interaction.snapInfo = null;
            const w = App.Renderer.unproject(mx, my);

            // Update Cursor Coords Display (Approx based on view)
            let cx = w.u, cy = -w.v;
            if (App.State.viewMode !== 'XY') { cx = 0; cy = 0; } // Hide or simple for non-XY
            document.getElementById('cursorCoords').innerText = `${cx.toFixed(2)}, ${cy.toFixed(2)}`;

            if (App.Interaction.drag.active) {
              const sel = App.State.selection;
              const du = w.u - App.Interaction.drag.startScreen.x;
              const dv = w.v - App.Interaction.drag.startScreen.y;

              // Resize Block (single object only)
              if (sel.type === 'block' && sel.id && App.Interaction.hover.edge && App.State.viewMode === 'XY') {
                const b = App.State.blocks.find(x => x.id === sel.id);
                let nL = App.Interaction.drag.startObj.L, nW = App.Interaction.drag.startObj.W;
                let nX = App.Interaction.drag.startObj.X, nY = App.Interaction.drag.startObj.Y;

                if (App.Interaction.hover.edge === 'E') nL = Math.max(0.1, nL + du);
                if (App.Interaction.hover.edge === 'W') { nL = Math.max(0.1, nL - du); nX += du; }
                if (App.Interaction.hover.edge === 'S') { nW = Math.max(0.1, nW - dv); }
                if (App.Interaction.hover.edge === 'N') { nW = Math.max(0.1, nW + dv); nY -= dv; }

                const step = App.State.gridStep > 0 ? App.State.gridStep : 0.01;
                nL = Math.round(nL / step) * step;
                nW = Math.round(nW / step) * step;
                nX = Math.round(nX / step) * step;
                nY = Math.round(nY / step) * step;
                nL = Math.max(0.1, nL);
                nW = Math.max(0.1, nW);

                App.State.updateBlockSilent({ ...b, X: nX, Y: nY, L: nL, W: nW });
                App.Renderer.draw();
              } else {
                // Multi-Object Move & Snap Logic
                // 1. Calculate tentative position for the PRIMARY object
                const delta = App.Renderer.unprojectDelta(du, dv, App.State.viewMode);
                let tx = App.Interaction.drag.startObj.X + delta.dx;
                let ty = App.Interaction.drag.startObj.Y + delta.dy;
                let tz = App.Interaction.drag.startObj.Z + delta.dz;

                // 2. Apply Grid Rounding to tentative position
                if (App.State.gridStep > 0) {
                  tx = Math.round(tx / App.State.gridStep) * App.State.gridStep;
                  ty = Math.round(ty / App.State.gridStep) * App.State.gridStep;
                  tz = Math.round(tz / App.State.gridStep) * App.State.gridStep;
                }

                // 3. Solve Snap (Magnetic) for PRIMARY object
                // We need the original object to pass its ID/dimensions to solveSnap
                const pObj = App.Interaction.drag.startObj;
                const res = App.Physics.solveSnap(
                  pObj,
                  { x: tx, y: ty, z: tz },
                  App.State.blocks, App.State.piles, App.State.machines,
                  App.State.snapStep, App.State.viewMode,
                  sel.type
                );

                // 4. Calculate Effective Delta (Final Position - Start Position)
                const effDx = res.x - pObj.X;
                const effDy = res.y - pObj.Y;
                const effDz = res.z - (pObj.Z || 0);

                // 5. Apply Effective Delta to ALL selected objects
                App.Interaction.drag.startObjs.forEach(so => {
                  let nx = so.startX + effDx;
                  let ny = so.startY + effDy;
                  let nz = so.startZ + effDz;

                  if (so.type === 'block') {
                    const b = App.State.blocks.find(x => x.id === so.id);
                    if (b) {
                      // Move hosted points first
                      App.State.points.forEach(pt => {
                        if (pt.hostType === 'block' && pt.hostId === b.id) {
                          pt.X = nx + (pt.offsetX || 0);
                          pt.Y = ny + (pt.offsetY || 0);
                          pt.Z = nz + (pt.offsetZ || 0);
                        }
                      });
                      // Move hosted loads
                      App.State.loadPoints.forEach(lp => {
                        if (lp.hostType === 'block' && lp.hostId === b.id) {
                          lp.X = nx + (lp.offsetX || 0);
                          lp.Y = ny + (lp.offsetY || 0);
                          lp.Z = nz + (lp.offsetZ || 0);
                        }
                      });
                      App.State.updateBlockSilent({ ...b, X: nx, Y: ny, Z: nz });
                    }
                  }
                  if (so.type === 'pile') {
                    const p = App.State.piles.find(x => x.id === so.id);
                    if (p) {
                      App.State.points.forEach(pt => {
                        if (pt.hostType === 'pile' && pt.hostId === p.id) {
                          pt.X = nx + (pt.offsetX || 0);
                          pt.Y = ny + (pt.offsetY || 0);
                        }
                      });
                      App.State.updatePileSilent({ ...p, X: nx, Y: ny });
                    }
                  }
                  if (so.type === 'machine') {
                    const m = App.State.machines.find(x => x.id === so.id);
                    if (m) {
                      // Move hosted loads
                      App.State.loadPoints.forEach(lp => {
                        if (lp.hostType === 'machine' && lp.hostId === m.id) {
                          lp.X = nx;
                          lp.Y = ny;
                          lp.Z = nz;
                        }
                      });
                      App.State.updateMachineSilent({ ...m, X: nx, Y: ny, Z: nz });
                    }
                  }
                  if (so.type === 'point') {
                    const pt = App.State.points.find(x => x.id === so.id);
                    if (pt) App.State.updatePointSilent({ ...pt, X: nx, Y: ny, Z: nz });
                  }
                  if (so.type === 'load') {
                    // Update loadPoint position in loadPoints array
                    const lp = App.State.loadPoints.find(x => x.id === so.id);
                    if (lp) { lp.X = nx; lp.Y = ny; lp.Z = nz; }
                  }
                  if (so.type === 'assembly') {
                    // Move assembly anchor point and recalculate I for all generated machines
                    const asm = App.State.assemblies.find(x => x.id === so.id);
                    if (asm) {
                      asm.X = nx; asm.Y = ny; asm.Z = nz;
                      // Recalculate I using parallel axis theorem for all generated machines
                      const rad = (asm.rotation || 0) * Math.PI / 180;
                      const cosR = Math.cos(rad), sinR = Math.sin(rad);
                      const g = App.State.params.gravity || 9.81;

                      App.State.machines.forEach(m => {
                        if (m.isGenerated && m.sourceId === asm.id && m.componentIndex !== undefined) {
                          const comp = asm.components[m.componentIndex];
                          if (comp) {
                            // Keep machine at anchor position
                            m.X = asm.X; m.Y = asm.Y; m.Z = asm.Z;

                            // Recalculate I with parallel axis theorem - respect considerI/lockI flags
                            const dxRot = comp.dx * cosR - comp.dy * sinR;
                            const dyRot = comp.dx * sinR + comp.dy * cosR;
                            const dzRot = comp.dz || 0;
                            const mass = (comp.W || 0) / g;

                            // Only recalculate if considerI is true
                            if (comp.considerI) {
                              // Distance squared for parallel axis
                              const distYZ_sq = dyRot * dyRot + dzRot * dzRot;
                              const distXZ_sq = dxRot * dxRot + dzRot * dzRot;
                              const distXY_sq = dxRot * dxRot + dyRot * dyRot;

                              // Get local I (with rotation transform if needed)
                              let Ix_local = comp.Ix || 0, Iy_local = comp.Iy || 0, Iz_local = comp.Iz || 0;
                              if (!comp.lockI) {
                                Ix_local = (comp.Ix || 0) * cosR * cosR + (comp.Iy || 0) * sinR * sinR;
                                Iy_local = (comp.Ix || 0) * sinR * sinR + (comp.Iy || 0) * cosR * cosR;
                              }

                              m.Ix = Ix_local + mass * distYZ_sq;
                              m.Iy = Iy_local + mass * distXZ_sq;
                              m.Iz = Iz_local + mass * distXY_sq;
                            }
                            // If considerI is false, keep existing I values (no change)
                          }
                        }
                      });
                    }
                  }
                });

                // 6. Update Visual Snap Feedback
                App.Interaction.snapInfo = res;
                document.getElementById('snapInfo').innerText = res.snapped ? "MAGNET: " + res.info : "";
                App.Interaction.requestDraw();
              }
            } else {
              // Hover Check (only when not dragging)
              let hID = null, hEdge = null;
              if (App.State.viewMode === 'XY') {
                // Chỉ check block đang được chọn để tránh resize nhầm
                let targets = [];
                if (App.State.selection && App.State.selection.type === 'block') {
                  const b = App.State.blocks.find(x => x.id === App.State.selection.id);
                  targets = b ? [b] : [];
                }

                for (let b of targets) {
                  const v0 = App.Renderer.project(b.X, b.Y, b.Z);
                  const v2 = App.Renderer.project(b.X + b.L, b.Y + b.W, b.Z);
                  const minX = Math.min(v0.x, v2.x), maxX = Math.max(v0.x, v2.x);
                  const minY = Math.min(v0.y, v2.y), maxY = Math.max(v0.y, v2.y);

                  const hitMargin = 15;
                  if (mx >= minX - hitMargin && mx <= maxX + hitMargin && my >= minY - hitMargin && my <= maxY + hitMargin) {
                    hID = b.id;
                    const threshold = 12;
                    const distE = Math.abs(mx - maxX);
                    const distW = Math.abs(mx - minX);
                    const distN = Math.abs(my - maxY);
                    const distS = Math.abs(my - minY);
                    const minDist = Math.min(distE, distW, distS, distN);

                    if (minDist < threshold) {
                      if (minDist === distE) hEdge = 'E';
                      else if (minDist === distW) hEdge = 'W';
                      else if (minDist === distN) hEdge = 'N';
                      else if (minDist === distS) hEdge = 'S';
                    }
                    break;
                  }
                }
              }

              App.Interaction.hover = { id: hID, edge: hEdge };
              document.body.style.cursor = hEdge ? (['E', 'W'].includes(hEdge) ? 'ew-resize' : 'ns-resize') : 'default';
              App.Interaction.requestDraw();
            }

            // Box selection update
            if (App.Interaction.boxSelect.active) {
              App.Interaction.boxSelect.endX = mx;
              App.Interaction.boxSelect.endY = my;
              App.Interaction.boxSelect.isLeftToRight = mx >= App.Interaction.boxSelect.startX;
              App.Interaction.requestDraw();
            }
          },

          onUp(e) { // Pass event e needs strictly for ctrl check? onUp triggers from window listener usually.
            // Check global event or store IsCtrl logic? Window listener passes e.
            const isCtrl = e && e.ctrlKey;

            // Complete box selection
            if (App.Interaction.boxSelect.active) {
              const box = App.Interaction.boxSelect;
              const left = Math.min(box.startX, box.endX);
              const right = Math.max(box.startX, box.endX);
              const top = Math.min(box.startY, box.endY);
              const bottom = Math.max(box.startY, box.endY);
              const isLeftToRight = box.isLeftToRight;

              // Only select if box has meaningful size
              if (right - left > 5 || bottom - top > 5) {
                let selected = [];

                // Check blocks
                App.State.blocks.forEach(b => {
                  const v = [
                    App.Renderer.project(b.X, b.Y, b.Z),
                    App.Renderer.project(b.X + b.L, b.Y, b.Z),
                    App.Renderer.project(b.X + b.L, b.Y + b.W, b.Z),
                    App.Renderer.project(b.X, b.Y + b.W, b.Z)
                  ];
                  const minX = Math.min(...v.map(p => p.x)), maxX = Math.max(...v.map(p => p.x));
                  const minY = Math.min(...v.map(p => p.y)), maxY = Math.max(...v.map(p => p.y));

                  if (isLeftToRight) {
                    // Full containment required
                    if (minX >= left && maxX <= right && minY >= top && maxY <= bottom) {
                      selected.push({ type: 'block', id: b.id });
                    }
                  } else {
                    // Intersection only
                    if (!(maxX < left || minX > right || maxY < top || minY > bottom)) {
                      selected.push({ type: 'block', id: b.id });
                    }
                  }
                });

                // Check piles
                App.State.piles.forEach(p => {
                  const pt = App.Renderer.project(p.X, p.Y, p.Z || 0);
                  if (isLeftToRight) {
                    if (pt.x >= left && pt.x <= right && pt.y >= top && pt.y <= bottom) {
                      selected.push({ type: 'pile', id: p.id });
                    }
                  } else {
                    if (pt.x >= left - 8 && pt.x <= right + 8 && pt.y >= top - 8 && pt.y <= bottom + 8) {
                      selected.push({ type: 'pile', id: p.id });
                    }
                  }
                });

                // Check machines
                App.State.machines.forEach(m => {
                  const pt = App.Renderer.project(m.X, m.Y, m.Z);
                  if (isLeftToRight) {
                    if (pt.x >= left && pt.x <= right && pt.y >= top && pt.y <= bottom) {
                      selected.push({ type: 'machine', id: m.id });
                    }
                  } else {
                    if (pt.x >= left - 10 && pt.x <= right + 10 && pt.y >= top - 10 && pt.y <= bottom + 10) {
                      selected.push({ type: 'machine', id: m.id });
                    }
                  }
                });

                // Check points
                App.State.points.forEach(p => {
                  const pt = App.Renderer.project(p.X, p.Y, p.Z || 0);
                  if (isLeftToRight) {
                    if (pt.x >= left && pt.x <= right && pt.y >= top && pt.y <= bottom) {
                      selected.push({ type: 'point', id: p.id });
                    }
                  } else {
                    if (pt.x >= left - 6 && pt.x <= right + 6 && pt.y >= top - 6 && pt.y <= bottom + 6) {
                      selected.push({ type: 'point', id: p.id });
                    }
                  }
                });

                // Check loadPoints
                App.State.loadPoints.forEach(lp => {
                  const pt = App.Renderer.project(lp.X, lp.Y, lp.Z || 0);
                  if (isLeftToRight) {
                    if (pt.x >= left && pt.x <= right && pt.y >= top && pt.y <= bottom) {
                      selected.push({ type: 'load', id: lp.id });
                    }
                  } else {
                    if (pt.x >= left - 8 && pt.x <= right + 8 && pt.y >= top - 8 && pt.y <= bottom + 8) {
                      selected.push({ type: 'load', id: lp.id });
                    }
                  }
                });

                // Check assemblies
                App.State.assemblies.forEach(a => {
                  const pt = App.Renderer.project(a.X, a.Y, a.Z || 0);
                  if (isLeftToRight) {
                    if (pt.x >= left && pt.x <= right && pt.y >= top && pt.y <= bottom) {
                      selected.push({ type: 'assembly', id: a.id });
                    }
                  } else {
                    if (pt.x >= left - 10 && pt.x <= right + 10 && pt.y >= top - 10 && pt.y <= bottom + 10) {
                      selected.push({ type: 'assembly', id: a.id });
                    }
                  }
                });

                if (selected.length > 0) {
                  if (isCtrl) {
                    // Add to existing selection logic
                    // Check unique before pushing? toggleSelection allows add.
                    // setMultiSelection overrides.
                    // We need to merge.
                    const current = App.State.selectedIds;
                    selected.forEach(s => {
                      if (!current.some(curr => curr.type === s.type && curr.id === s.id)) {
                        current.push(s);
                      }
                    });
                    App.State.setMultiSelection(current);
                  } else {
                    App.State.setMultiSelection(selected);
                  }
                }
              }

              App.Interaction.boxSelect.active = false;
            }

            if (App.Interaction.drag.active) App.State.notify(); // Add to history ONLY on drop
            App.Interaction.drag.active = false;
            App.Interaction.isPan = false;
            App.Interaction.isRotate = false;
            App.Interaction.snapInfo = null;
            document.body.style.cursor = '';
            const cvs = document.getElementById('mainCanvas');
            if (cvs) cvs.style.cursor = '';
            document.getElementById('snapInfo').innerText = "";
            App.Interaction.requestDraw();
          },
          onDblClick() {
            if (App.State.selection.type === 'block') {
              const b = App.State.blocks.find(x => x.id === App.State.selection.id);
              if (b) App.UI.openEdit(b);
            } else if (App.State.selection.type === 'machine') {
              const m = App.State.machines.find(x => x.id === App.State.selection.id);
              if (m) App.UI.openMachineEdit(m);
            } else if (App.State.selection.type === 'pile') {
              const p = App.State.piles.find(x => x.id === App.State.selection.id);
              if (p) App.UI.openPileEdit(p);
            } else if (App.State.selection.type === 'assembly') {
              const a = App.State.assemblies.find(x => x.id === App.State.selection.id);
              if (a) App.Assembly.openWizard(a);
            }
          },
          onWheel(e) {
            e.preventDefault();
            const s = Math.exp(e.deltaY < 0 ? 0.1 : -0.1);
            const r = e.target.getBoundingClientRect();
            const mx = e.clientX - r.left, my = e.clientY - r.top;
            // Zoom towards mouse: pan + (mouse - pan) * (1 - scale_ratio)
            App.Renderer.pan.x = mx - (mx - App.Renderer.pan.x) * s;
            App.Renderer.pan.y = my - (my - App.Renderer.pan.y) * s;
            App.Renderer.scale *= s;
            App.Interaction.requestDraw();
          }
        },

        Actions: {
          addBlock() {
            const b = {
              id: 'b' + Date.now(), name: 'Block ' + (App.State.blocks.length + 1),
              L: +document.getElementById('add-L').value, W: +document.getElementById('add-W').value, H: +document.getElementById('add-H').value,
              X: +document.getElementById('add-X').value, Y: +document.getElementById('add-Y').value, Z: +document.getElementById('add-Z').value,
              density: App.State.params.concreteDensity, op: 1 // 1: Add, -1: Subtract
            };
            App.State.blocks.push(b); App.State.notify();
          },
          genPiles() {
            const r = +document.getElementById('gen-rows').value, c = +document.getElementById('gen-cols').value;
            const sx = +document.getElementById('gen-sx').value, sy = +document.getElementById('gen-sy').value;
            const ox = -(c - 1) * sx / 2, oy = -(r - 1) * sy / 2;
            for (let i = 0; i < c; i++) for (let j = 0; j < r; j++) {
              const pid = 'p' + Date.now() + i + j;
              // Name will be handled by UI default P{index} or we can set it here?
              // If we set it here, deletions might make P1, P3... which is fine.
              // But let's leave it undefined to rely on dynamic P{index} or set it?
              // User likes P1, P2... let's let UI handle dynamic index naming for consistency if name is empty.
              // Just creating the object:
              App.State.piles.push({
                id: pid, X: ox + i * sx, Y: oy + j * sy,
                Kv: App.State.params.defaultKv || 1289491,
                Kh: App.State.params.defaultKh || 228309
              });
            }
            App.State.notify();
          },
          deleteSelected() {
            if (App.State.selectedIds.length === 0) return;
            App.State.selectedIds.forEach(s => {
              if (s.type === 'block') App.State.blocks = App.State.blocks.filter(b => b.id !== s.id);
              if (s.type === 'pile') App.State.piles = App.State.piles.filter(p => p.id !== s.id);
              if (s.type === 'machine') App.State.machines = App.State.machines.filter(m => m.id !== s.id);
              if (s.type === 'point') App.State.points = App.State.points.filter(p => p.id !== s.id);
              if (s.type === 'load') App.State.loadPoints = App.State.loadPoints.filter(lp => lp.id !== s.id);
              if (s.type === 'assembly') {
                // Remove assembly and all its generated machines
                App.State.assemblies = App.State.assemblies.filter(a => a.id !== s.id);
                App.State.machines = App.State.machines.filter(m => m.sourceId !== s.id);
              }
            });
            App.State.clearSelection();
            App.State.notify();
          },
          filterSelection(type) {
            if (App.State.selectedIds.length === 0) return;
            // Sub-filter: keep only items of 'type' from the CURRENT selection
            const filtered = App.State.selectedIds.filter(s => s.type === type);
            // If filtering results in empty, maybe keep original? No, user wants to filter.
            // If filtered is same length, maybe user wants to select ALL of that type?
            // Requirement: "filter buttons functionality (Refine current selection)"

            if (filtered.length > 0) {
              App.State.setMultiSelection(filtered);
            } else {
              // If nothing implies, maybe select all of that type?
              // Let's stick to strict sub-filter. If none selected, do nothing.
            }
          },
          copy() {
            if (!App.State.selection.id) return;
            const list = App.State.selection.type === 'block' ? App.State.blocks : App.State.piles;
            const obj = list.find(x => x.id === App.State.selection.id);
            if (obj) App.State.clipboard = { type: App.State.selection.type, data: obj };
          },
          paste() {
            if (!App.State.clipboard) return;
            const n = { ...App.State.clipboard.data, id: (App.State.clipboard.type === 'block' ? 'b' : 'p') + Date.now(), X: App.State.clipboard.data.X + 0.5, Y: App.State.clipboard.data.Y + 0.5 };
            if (App.State.clipboard.type === 'block') { n.name += "_cp"; App.State.blocks.push(n); }
            else App.State.piles.push(n);
            App.State.setSelection(App.State.clipboard.type, n.id); App.State.notify();
          },
          saveEdit() {
            const id = document.getElementById('editId').value;
            const b = App.State.blocks.find(x => x.id === id);
            if (b) {
              b.name = document.getElementById('editName').value;
              ['L', 'W', 'H', 'X', 'Y', 'Z'].forEach(k => b[k] = parseFloat(document.getElementById('edit' + k).value));
              b.density = parseFloat(document.getElementById('editDensity').value);
              b.op = document.getElementById('editOp').checked ? -1 : 1;
              App.State.notify(); App.UI.closeModal();
            }
          },
          // updateLoad removed - loads now managed via loadPoints array
          addMachine() {
            const m = {
              id: 'm' + Date.now(),
              name: document.getElementById('add-machine-name').value,
              W: +document.getElementById('add-machine-W').value,
              X: +document.getElementById('add-machine-X').value,
              Y: +document.getElementById('add-machine-Y').value,
              Z: +document.getElementById('add-machine-Z').value,
              rotation: +document.getElementById('add-machine-rot').value,
              Ix: +document.getElementById('add-machine-Ix').value || 0,
              Iy: +document.getElementById('add-machine-Iy').value || 0,
              Iz: +document.getElementById('add-machine-Iz').value || 0
            };
            App.State.machines.push(m);
            App.State.notify();
          },
          deleteMachine(id) {
            App.State.machines = App.State.machines.filter(m => m.id !== id);
            App.State.notify();
          },
          updateSettings(k, v) {
            App.State.params[k] = +v;
            App.State.notify();
          },
          saveMachineEdit() {
            const id = document.getElementById('editMachineId').value;
            const m = App.State.machines.find(x => x.id === id);
            if (m) {
              m.name = document.getElementById('editMachineName').value;
              m.W = +document.getElementById('editMachineW').value;
              m.X = +document.getElementById('editMachineX').value;
              m.Y = +document.getElementById('editMachineY').value;
              m.Z = +document.getElementById('editMachineZ').value;
              m.rotation = +document.getElementById('editMachineRot').value;
              m.Ix = +document.getElementById('editMachineIx')?.value || 0;
              m.Iy = +document.getElementById('editMachineIy')?.value || 0;
              m.Iz = +document.getElementById('editMachineIz')?.value || 0;

              // Bidirectional sync: if generated machine, update parent assembly component
              if (m.isGenerated && m.sourceId && m.componentIndex !== undefined) {
                const asm = App.State.assemblies.find(a => a.id === m.sourceId);
                if (asm && asm.components[m.componentIndex]) {
                  const comp = asm.components[m.componentIndex];
                  comp.name = m.name;
                  comp.W = m.W;
                  comp.considerI = true; // Enable I consideration since user manually set values
                  comp.lockI = true; // Set lockI to preserve manual I values
                  comp.Ix = m.Ix;
                  comp.Iy = m.Iy;
                  comp.Iz = m.Iz;
                }
              }

              App.State.notify();
              App.UI.closeMachineModal();
            }
          },
          updateGravity(v) {
            // Synchronize both header input and settings input
            App.State.params.gravity = +v;
            document.getElementById('inpG').value = v;
            document.getElementById('set-gravity').value = v;
            App.State.notify();
          },
          updateUnit(u) {
            // Update unit and auto-adjust gravity
            App.State.params.unit = u;
            App.State.projectInfo.unit = u;
            document.getElementById('inpUnit').value = u;
            // Auto-update gravity based on unit system
            const newG = u === 'E' ? (App.State.params.gravityEnglish || 32.2) : (App.State.params.gravityMetric || 9.81);
            this.updateGravity(newG);
          },
          savePileEdit() {
            const id = document.getElementById('editPileId').value;
            const p = App.State.piles.find(x => x.id === id);
            if (p) {
              p.name = document.getElementById('editPileName').value || p.name;
              p.X = +document.getElementById('editPileX').value;
              p.Y = +document.getElementById('editPileY').value;
              p.Z = +document.getElementById('editPileZ').value;
              p.Kv = +document.getElementById('editPileKv').value;
              p.Kh = +document.getElementById('editPileKh').value;
              p.shape = document.getElementById('editPileShape').value;
              p.size = +document.getElementById('editPileSize').value;
              p.length = +document.getElementById('editPileLen').value;
              App.State.notify();
              App.UI.closePileModal();
            }
          },
          addSinglePile() {
            const p = {
              id: Date.now().toString(),
              name: document.getElementById('add-pile-name').value || 'P' + (App.State.piles.length + 1),
              X: +document.getElementById('add-pile-X').value,
              Y: +document.getElementById('add-pile-Y').value,
              Z: 0,
              Kv: App.State.params.defaultKv || 100000,
              Kh: App.State.params.defaultKh || 50000,
              shape: 'round', size: 0.4, length: 15
            };
            App.State.piles.push(p);
            App.State.notify();
          },
          deletePile(id) {
            App.State.piles = App.State.piles.filter(p => p.id !== id);
            App.State.notify();
          },
          deletePoint(id) {
            App.State.points = App.State.points.filter(p => p.id !== id);
            App.State.notify();
          },
          addPoint() {
            const getUniqueName = (base) => {
              let name = base;
              let counter = 1;
              while (App.State.points.some(p => p.name === name)) {
                name = `${base}_${counter++}`;
              }
              return name;
            };
            const rawName = 'Pt ' + (App.State.points.length + 1);
            const p = {
              id: 'pt' + Date.now(),
              name: getUniqueName(rawName),
              X: +document.getElementById('add-point-X').value,
              Y: +document.getElementById('add-point-Y').value,
              Z: +document.getElementById('add-point-Z').value
            };
            App.State.points.push(p);
            App.State.notify();
          },
          genPointsFromBlocks() {
            const selBlocks = App.State.selectedIds.filter(s => s.type === 'block');
            if (selBlocks.length === 0) {
              App.UI.showCanvasMsg('Please select blocks first');
              return;
            }
            let count = 0;
            const getUniqueName = (base) => {
              let name = base;
              let counter = 1;
              while (App.State.points.some(p => p.name === name)) {
                name = `${base}_${counter++}`;
              }
              return name;
            };
            selBlocks.forEach(s => {
              const b = App.State.blocks.find(x => x.id === s.id);
              if (!b) return;
              const pts = App.Physics.getInterestPoints(b).filter(p => p.type === 'corner');
              pts.forEach((pt, i) => {
                const rawName = `${b.name}_C${i + 1}`;
                App.State.points.push({
                  id: 'pt_b' + b.id + '_' + i + '_' + Date.now(),
                  name: getUniqueName(rawName),
                  X: pt.x, Y: pt.y, Z: pt.z,
                  hostType: 'block', hostId: b.id,
                  offsetX: pt.x - b.X, offsetY: pt.y - b.Y, offsetZ: pt.z - b.Z
                });
                count++;
              });
            });
            App.UI.showCanvasMsg(`Generated ${count} points from ${selBlocks.length} blocks`);
            App.State.notify();
          },
          genPointsFromPiles() {
            const selPiles = App.State.selectedIds.filter(s => s.type === 'pile');
            if (selPiles.length === 0) {
              App.UI.showCanvasMsg('Please select piles first');
              return;
            }
            let count = 0;
            const getUniqueName = (base) => {
              let name = base;
              let counter = 1;
              while (App.State.points.some(p => p.name === name)) {
                name = `${base}_${counter++}`;
              }
              return name;
            };
            selPiles.forEach(s => {
              const p = App.State.piles.find(x => x.id === s.id);
              if (!p) return;
              const idx = App.State.piles.indexOf(p);
              const rawName = p.name || `P${idx + 1}_Head`;
              App.State.points.push({
                id: 'pt_p' + p.id + '_' + Date.now(),
                name: getUniqueName(rawName + '_Head'),
                X: p.X, Y: p.Y, Z: p.Z || 0,
                hostType: 'pile', hostId: p.id,
                offsetX: 0, offsetY: 0, offsetZ: 0
              });
              count++;
            });
            App.UI.showCanvasMsg(`Generated ${count} points from ${selPiles.length} piles`);
            App.State.notify();
          },
          savePointEdit() {
            const id = document.getElementById('editPointId').value;
            const p = App.State.points.find(x => x.id === id);
            if (p) {
              p.name = document.getElementById('editPointName').value;
              p.X = +document.getElementById('editPointX').value;
              p.Y = +document.getElementById('editPointY').value;
              p.Z = +document.getElementById('editPointZ').value;
              // Save Host
              p.hostType = document.getElementById('editPointHostType').value || null;
              p.hostId = document.getElementById('editPointHostId').value || null;

              App.State.notify();
              App.UI.closePointModal();
            }
          },
          // === LOAD POINT ACTIONS ===
          addLoadPoint() {
            const lp = {
              id: 'load' + Date.now(),
              name: document.getElementById('add-load-name').value || 'Load ' + (App.State.loadPoints.length + 1),
              X: +document.getElementById('add-load-X').value,
              Y: +document.getElementById('add-load-Y').value,
              Z: +document.getElementById('add-load-Z').value,
              hostType: null, hostId: null,
              type: 'C',
              Fx: +document.getElementById('add-load-Fx').value || 0,
              Fy: +document.getElementById('add-load-Fy').value || 0,
              Fz: +document.getElementById('add-load-Fz').value || 0,
              Mx: +document.getElementById('add-load-Mx').value || 0,
              My: +document.getElementById('add-load-My').value || 0,
              Mz: +document.getElementById('add-load-Mz').value || 0,
              Fx2: 0, Fy2: 0, Fz2: 0, Mx2: 0, My2: 0, Mz2: 0
            };
            App.State.loadPoints.push(lp);
            App.State.notify();
          },
          addLoadFromBlocks() {
            const selBlocks = App.State.selectedIds.filter(s => s.type === 'block');
            if (selBlocks.length === 0) {
              App.UI.showCanvasMsg('Please select blocks first');
              return;
            }

            let added = 0;
            selBlocks.forEach(s => {
              const b = App.State.blocks.find(x => x.id === s.id);
              if (b) {
                // Check if load already exists at this position with this host
                const exists = App.State.loadPoints.some(lp =>
                  lp.hostType === 'block' && lp.hostId === b.id
                );
                if (!exists) {
                  const lp = {
                    id: 'load' + Date.now() + '_' + b.id,
                    name: 'L@' + b.name,
                    type: 'C',
                    X: b.X + b.L / 2,
                    Y: b.Y + b.W / 2,
                    Z: b.Z + b.H,
                    hostType: 'block', hostId: b.id,
                    offsetX: b.L / 2, offsetY: b.W / 2, offsetZ: b.H,
                    Fx: 0, Fy: 0, Fz: 0, Mx: 0, My: 0, Mz: 0,
                    Fx2: 0, Fy2: 0, Fz2: 0, Mx2: 0, My2: 0, Mz2: 0
                  };
                  App.State.loadPoints.push(lp);
                  added++;
                }
              }
            });
            if (added > 0) App.State.notify();
          },
          addLoadFromMachines() {
            const selMachines = App.State.selectedIds.filter(s => s.type === 'machine');
            if (selMachines.length === 0) {
              App.UI.showCanvasMsg('Please select machines first');
              return;
            }

            let added = 0;
            const machineType = App.State.projectInfo.machineType || 'C';
            selMachines.forEach(s => {
              const m = App.State.machines.find(x => x.id === s.id);
              if (m) {
                // Check if load already exists with this host
                const exists = App.State.loadPoints.some(lp =>
                  lp.hostType === 'machine' && lp.hostId === m.id
                );
                if (!exists) {
                  const lp = {
                    id: 'load' + Date.now() + '_' + m.id,
                    name: 'L@' + (m.name || 'Machine'),
                    type: machineType, // Sync with machine type
                    X: m.X, Y: m.Y, Z: m.Z,
                    hostType: 'machine', hostId: m.id,
                    offsetX: 0, offsetY: 0, offsetZ: 0,
                    Fx: 0, Fy: 0, Fz: 0, Mx: 0, My: 0, Mz: 0,
                    Fx2: 0, Fy2: 0, Fz2: 0, Mx2: 0, My2: 0, Mz2: 0
                  };
                  App.State.loadPoints.push(lp);
                  added++;
                }
              }
            });
            if (added > 0) App.State.notify();
          },
          deleteLoad(id) {
            App.State.loadPoints = App.State.loadPoints.filter(lp => lp.id !== id);
            App.State.notify();
          },
          updateLoadPoint(id, prop, value) {
            const lp = App.State.loadPoints.find(x => x.id === id);
            if (lp) { lp[prop] = +value; App.State.notify(false); App.Renderer.draw(); }
          },
          saveLoadEdit() {
            const id = document.getElementById('editLoadId').value;
            const lp = App.State.loadPoints.find(x => x.id === id);
            if (lp) {
              lp.name = document.getElementById('editLoadName').value;
              lp.X = +document.getElementById('editLoadX').value;
              lp.Y = +document.getElementById('editLoadY').value;
              lp.Z = +document.getElementById('editLoadZ').value;
              lp.type = document.getElementById('editLoadType').value || 'C';
              lp.Fx = +document.getElementById('editLoadFx').value || 0;
              lp.Fy = +document.getElementById('editLoadFy').value || 0;
              lp.Fz = +document.getElementById('editLoadFz').value || 0;
              lp.Mx = +document.getElementById('editLoadMx').value || 0;
              lp.My = +document.getElementById('editLoadMy').value || 0;
              lp.Mz = +document.getElementById('editLoadMz').value || 0;
              lp.Fx2 = +document.getElementById('editLoadFx2').value || 0;
              lp.Fy2 = +document.getElementById('editLoadFy2').value || 0;
              lp.Fz2 = +document.getElementById('editLoadFz2').value || 0;
              lp.Mx2 = +document.getElementById('editLoadMx2').value || 0;
              lp.My2 = +document.getElementById('editLoadMy2').value || 0;
              lp.Mz2 = +document.getElementById('editLoadMz2').value || 0;
              lp.hostType = document.getElementById('editLoadHostType').value || null;

              // Validate Host ID if hostType is set
              const hostIdInput = +document.getElementById('editLoadHostId').value;
              if (lp.hostType && hostIdInput) {
                let arr = lp.hostType === 'block' ? App.State.blocks :
                  lp.hostType === 'machine' ? App.State.machines : [];
                if (hostIdInput > 0 && hostIdInput <= arr.length) {
                  lp.hostId = arr[hostIdInput - 1].id; // Convert ID# to actual ID
                } else {
                  alert(`Invalid Host ID #${hostIdInput}. ${lp.hostType} has only ${arr.length} items.`);
                  return;
                }
              } else {
                lp.hostId = null;
              }

              App.State.notify();
              App.UI.closeLoadModal();
            }
          }
        },

        IO: {
          save() {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([JSON.stringify({
              blocks: App.State.blocks,
              piles: App.State.piles,
              machines: App.State.machines,
              assemblies: App.State.assemblies,
              points: App.State.points,
              loadPoints: App.State.loadPoints,
              loadsConfig: App.State.loadsConfig,
              projectInfo: App.State.projectInfo,
              params: App.State.params
            })], { type: 'application/json' }));
            a.download = (App.State.projectInfo.jobName || 'project') + '.dts';
            a.click();
          },
          load(el) {
            const fr = new FileReader();
            fr.onload = e => {
              const d = JSON.parse(e.target.result);
              App.State.blocks = d.blocks || [];
              App.State.piles = d.piles || [];
              App.State.machines = d.machines || [];
              App.State.assemblies = d.assemblies || [];
              App.State.points = d.points || [];
              App.State.loadPoints = d.loadPoints || [];
              App.State.loadsConfig = d.loadsConfig || { freq: 3000 };
              if (d.projectInfo) App.State.projectInfo = d.projectInfo;
              if (d.params) Object.assign(App.State.params, d.params);
              App.State.notify();
            };
            fr.readAsText(el.files[0]);
          },
          // Centralized WCVL output generator - returns string (used by both Export popup and download)
          getWCVLOutput() {
            const p = App.State.projectInfo;
            const params = App.State.params;
            const machineType = p.machineType;
            const freq = App.State.loadsConfig.freq;

            // Line 1-3: Header (Control Flags: Machine/Cap/Arrangement/Stiffness/Head/Unit)
            let s = 'PILE\n';
            s += `${p.jobName}\n`;
            const capType = p.capType;
            const arrangement = p.arrangement;
            const stiffness = p.stiffness;
            const pileHead = p.pileHead;
            const unit = p.unit;
            s += `${machineType}${capType}${arrangement}${stiffness}${pileHead}${unit}\n`;

            // Line 4: Material constants (strict - no fallbacks)
            const density = params.concreteDensity;
            const g = params.gravity;
            const fc = params.concreteStrength;
            const dz = params.dampingZ;
            const dx = params.dampingX;
            const dr = params.dampingRock;
            const dt = params.dampingTor;
            s += `${density.toFixed(3)} ${g.toFixed(2)} ${fc} ${dz} ${dx} ${dr} ${dt}\n`;

            // Line 5+: Machine data
            const machines = App.State.machines;
            s += `${machines.length} ${freq}\n`;
            machines.forEach(m => {
              // Strict values - no fallbacks (Audit validates)
              const w = m.W ?? 0;
              const x = m.X ?? 0;
              const y = m.Y ?? 0;
              const z = m.Z ?? 0;
              const ix = m.Ix ?? 0, iy = m.Iy ?? 0, iz = m.Iz ?? 0;
              s += `\t${w.toFixed(4)}  ${x.toFixed(4)}  ${y.toFixed(4)}  ${z.toFixed(4)}  ${ix.toFixed(4)}  ${iy.toFixed(4)}  ${iz.toFixed(4)}\n`;
            });

            // Forces: Sum all loadPoints
            let Fx = 0, Fy = 0, Fz = 0, Mx = 0, My = 0, Mz = 0;
            let Fx2 = 0, Fy2 = 0, Fz2 = 0, Mx2 = 0, My2 = 0, Mz2 = 0;
            let Zc = 0, Yc = 0, Xc = 0;

            App.State.loadPoints.forEach(lp => {
              Fx += lp.Fx ?? 0; Fy += lp.Fy ?? 0; Fz += lp.Fz ?? 0;
              Mx += lp.Mx ?? 0; My += lp.My ?? 0; Mz += lp.Mz ?? 0;
              Fx2 += lp.Fx2 ?? 0; Fy2 += lp.Fy2 ?? 0; Fz2 += lp.Fz2 ?? 0;
              Mx2 += lp.Mx2 ?? 0; My2 += lp.My2 ?? 0; Mz2 += lp.Mz2 ?? 0;
              // Use first load point position as lever arm center
              if (Zc === 0) { Zc = lp.Z ?? 0; Yc = lp.Y ?? 0; Xc = lp.X ?? 0; }
            });

            // Primary forces (Fx Zc Yc; Fy Zc Xc; Fz Yc Xc; Mx My Mz)
            s += `${Fx.toFixed(4)} ${Zc.toFixed(4)} ${Yc.toFixed(4)}\n`;
            s += `${Fy.toFixed(4)} ${Zc.toFixed(4)} ${Xc.toFixed(4)}\n`;
            s += `${Fz.toFixed(4)} ${Yc.toFixed(4)} ${Xc.toFixed(4)}\n`;
            s += `${Mx.toFixed(4)} ${My.toFixed(4)} ${Mz.toFixed(4)}\n`;

            // Secondary forces for Type R
            if (machineType === 'R') {
              s += `${Fx2.toFixed(4)} ${Zc.toFixed(4)} ${Yc.toFixed(4)}\n`;
              s += `${Fy2.toFixed(4)} ${Zc.toFixed(4)} ${Xc.toFixed(4)}\n`;
              s += `${Fz2.toFixed(4)} ${Yc.toFixed(4)} ${Xc.toFixed(4)}\n`;
              s += `${Mx2.toFixed(4)} ${My2.toFixed(4)} ${Mz2.toFixed(4)}\n`;
            }

            // Geometry: Depends on capType (A=Arbitrary, R=Rectangular, C=Composited)
            const allBlocks = App.State.blocks;

            if (capType === 'A') {
              // Arbitrary cap: Weight Ixx Iyy Izz Cx Cy Cz
              const capA = params.capAParams || {};
              s += `${capA.Weight || 0} ${capA.Ixx || 0} ${capA.Iyy || 0} ${capA.Izz || 0} ${capA.Cx || 0} ${capA.Cy || 0} ${capA.Cz || 0}\n`;
            } else if (capType === 'R' && allBlocks.length === 1) {
              // Rectangular cap: Single line Lx Ly T Cx Cy Cz
              const b = allBlocks[0];
              const cx = b.X + b.L / 2, cy = b.Y + b.W / 2, cz = b.Z + b.H / 2;
              s += `${b.L.toFixed(4)} ${b.W.toFixed(4)} ${b.H.toFixed(4)} ${cx.toFixed(4)} ${cy.toFixed(4)} ${cz.toFixed(4)}\n`;
            } else {
              // Composited cap: Nodes and Blocks (include subtract blocks with Op=-1)
              const numNodes = allBlocks.length * 4;
              const numBlocks = allBlocks.length;
              s += `\t${numNodes} ${numBlocks}\n`;

              // Generate nodes (4 corners per block)
              let nodeId = 1;
              allBlocks.forEach(b => {
                const x = b.X, y = b.Y, z = b.Z, l = b.L, w = b.W, h = b.H;
                s += `\t${nodeId++}    ${x.toFixed(4)}   ${y.toFixed(4)}   ${z.toFixed(4)}\n`;
                s += `\t${nodeId++}    ${(x + l).toFixed(4)}   ${y.toFixed(4)}   ${z.toFixed(4)}\n`;
                s += `\t${nodeId++}    ${x.toFixed(4)}   ${(y + w).toFixed(4)}   ${z.toFixed(4)}\n`;
                s += `\t${nodeId++}    ${x.toFixed(4)}   ${y.toFixed(4)}   ${(z + h).toFixed(4)}\n`;
              });

              // Generate blocks (node references with Op: 1=ADD, -1=SUBTRACT)
              allBlocks.forEach((b, i) => {
                const n1 = i * 4 + 1, n2 = n1 + 1, n3 = n1 + 2, n4 = n1 + 3;
                const op = b.op === -1 ? -1 : 1;
                s += `\t${i + 1}    ${n1}   ${n2}   ${n3}   ${n4}   ${op}\n`;
              });
            }

            // Pile data - depends on stiffness type (I=Input, C=Computed)
            const piles = App.State.piles;
            const stiffType = App.State.projectInfo.stiffness || 'I';

            if (piles.length > 0) {
              if (stiffType === 'C') {
                // Computed stiffness: D L Es f
                const stiffC = params.stiffnessCParams || {};
                s += `${stiffC.D || 0.4} ${stiffC.L || 15} ${stiffC.Es || 30000} ${stiffC.f || 1.0}\n`;
              } else {
                // Input stiffness: Kv Kh (using strategy)
                let Kv = 0, Kh = 0;
                const strategy = params.stiffnessStrategy ?? 'global';

                if (strategy === 'global') {
                  Kv = params.globalKv ?? 0;
                  Kh = params.globalKh ?? 0;
                } else if (strategy === 'first') {
                  Kv = piles[0].Kv ?? 0;
                  Kh = piles[0].Kh ?? 0;
                } else if (strategy === 'average') {
                  Kv = piles.reduce((sum, p) => sum + (p.Kv ?? 0), 0) / piles.length;
                  Kh = piles.reduce((sum, p) => sum + (p.Kh ?? 0), 0) / piles.length;
                } else if (strategy === 'max') {
                  Kv = Math.max(...piles.map(p => p.Kv ?? 0));
                  Kh = Math.max(...piles.map(p => p.Kh ?? 0));
                } else if (strategy === 'min') {
                  Kv = Math.min(...piles.map(p => p.Kv ?? 0));
                  Kh = Math.min(...piles.map(p => p.Kh ?? 0));
                }

                s += `${Math.round(Kv)}  ${Math.round(Kh)}\n`;
              }

              // Pile positions - depends on arrangement (R=Rectangular, A=Array)
              if (arrangement === 'R') {
                // Rectangular grid: NC NR, X1..Xnc, Y1..Ynr
                const uniqueX = [...new Set(piles.map(p => p.X))].sort((a, b) => a - b);
                const uniqueY = [...new Set(piles.map(p => p.Y))].sort((a, b) => a - b);
                s += `${uniqueX.length} ${uniqueY.length}\n`;
                s += uniqueX.map(x => x.toFixed(4)).join(' ') + '\n';
                s += uniqueY.map(y => y.toFixed(4)).join(' ') + '\n';
              } else {
                // Array: Per-pile XY
                s += `${piles.length}\n`;
                piles.forEach(pile => {
                  s += `\t${pile.X.toFixed(4)}  ${pile.Y.toFixed(4)}\n`;
                });
              }
              // Bottom of pile cap - use override or auto calculate
              const minZ = params.zBottomOverride ?? Math.min(...allBlocks.map(b => b.Z));
              s += `\t${minZ.toFixed(4)}\n`;
            }

            // Check points
            const points = App.State.points;
            s += `${points.length}\n`;
            points.forEach((pt, i) => {
              s += `\t${i + 1}     ${pt.X.toFixed(4)}  ${pt.Y.toFixed(4)}  ${pt.Z.toFixed(4)}\n`;
            });

            return s;
          },
          // Download WCVL file (uses getWCVLOutput)
          exportWCVL() {
            const s = this.getWCVLOutput();
            const p = App.State.projectInfo;
            const filename = `${(p.jobName || 'export').replace(/[^a-zA-Z0-9]/g, '_')}_in.txt`;
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([s], { type: 'text/plain' }));
            a.download = filename;
            a.click();
            App.UI.showCanvasMsg(`Exported ${filename}`);
          }
        },

        UI: {
          init() {
            App.State.subscribe(this.render);
            // Subscribe result panel to state changes so it refreshes when model changes
            App.State.subscribe(() => {
              if (document.getElementById('result-sidebar') && !document.getElementById('result-sidebar').classList.contains('hidden')) {
                this.renderResults();
              }
            });
            App.History.push(); // Init State
            this.render();

            window.addEventListener('keydown', e => {
              if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
              if (e.key === 'Delete') App.Actions.deleteSelected();
              if (e.key === 'Escape') App.State.clearSelection();
              if (e.ctrlKey && e.key === 'c') App.Actions.copy();
              if (e.ctrlKey && e.key === 'v') App.Actions.paste();
              if (e.ctrlKey && e.key === 'z') App.History.undo();
              if (e.ctrlKey && e.key === 'y') App.History.redo();
              // Ctrl+A: Select all elements
              if (e.ctrlKey && e.key === 'a') {
                e.preventDefault(); // Prevent browser's select-all-text
                const allItems = [];
                App.State.blocks.forEach(b => allItems.push({ type: 'block', id: b.id }));
                App.State.piles.forEach(p => allItems.push({ type: 'pile', id: p.id }));
                App.State.machines.forEach(m => allItems.push({ type: 'machine', id: m.id }));
                App.State.points.forEach(p => allItems.push({ type: 'point', id: p.id }));
                App.State.loadPoints.forEach(l => allItems.push({ type: 'load', id: l.id }));
                App.State.setMultiSelection(allItems);
                App.UI.showCanvasMsg(`Selected ${allItems.length} elements`);
              }
            });
          },
          // Run Mode Toggle: Switch between Input and Results view
          resultMode: false,
          currentResTab: 'summary',
          lastResults: null,
          toggleRunMode(active) {
            this.resultMode = active;
            const resSidebar = document.getElementById('result-sidebar');
            const propsPanel = document.getElementById('props-panel');
            if (active) {
              // Run analysis first
              this.runAnalysis();
              // Auto-run frequency sweep
              this.runFrequencySweep();
              // Show Result Sidebar
              resSidebar.classList.remove('hidden');
              // Move Properties panel left to avoid overlap (initial: summary tab at 320px)
              if (propsPanel) {
                propsPanel.style.right = '340px';
              }
            } else {
              // Hide Result Sidebar
              resSidebar.classList.add('hidden');
              // Move Properties panel back to original position
              if (propsPanel) {
                propsPanel.style.right = '8px'; // right-2 = 0.5rem = 8px
              }
            }
          },
          // Helper: Aggregate all loads from model
          getAggregatedLoads() {
            const firstLP = App.State.loadPoints[0] || { X: 0, Y: 0, Z: 0 };
            const loads = {
              freq: App.State.loadsConfig.freq || 0,
              // Primary forces
              Fx: 0, Fy: 0, Fz: 0, Mx: 0, My: 0, Mz: 0,
              // Secondary forces (for Reciprocating machines)
              Fx_s: 0, Fy_s: 0, Fz_s: 0, Mx_s: 0, My_s: 0, Mz_s: 0,
              // Force CG
              X: firstLP.X || 0, Y: firstLP.Y || 0, Z: firstLP.Z || 0
            };
            App.State.loadPoints.forEach(lp => {
              // Primary
              loads.Fx += lp.Fx || 0;
              loads.Fy += lp.Fy || 0;
              loads.Fz += lp.Fz || 0;
              loads.Mx += lp.Mx || 0;
              loads.My += lp.My || 0;
              loads.Mz += lp.Mz || 0;
              // Secondary (Fx2, Fy2, Fz2 → Fx_s, Fy_s, Fz_s)
              loads.Fx_s += lp.Fx2 || 0;
              loads.Fy_s += lp.Fy2 || 0;
              loads.Fz_s += lp.Fz2 || 0;
              loads.Mx_s += lp.Mx2 || 0;
              loads.My_s += lp.My2 || 0;
              loads.Mz_s += lp.Mz2 || 0;
            });
            return loads;
          },
          runAnalysis() {
            const sys = App.Physics.calcSystem(App.State.blocks, App.State.machines, App.State.params);
            const stiff = App.Physics.calcStiffness(App.State.piles, sys.cg);
            const loads = this.getAggregatedLoads();
            const result = App.Physics.solve(sys, stiff, loads, App.State.params);
            this.lastResults = { sys, stiff, loads, result };
            this.renderResults();
          },
          // Helper: Format frequency as "RPM (Hz)"
          fmtFreq(rpm) {
            if (!rpm || rpm === 0) return '0';
            const hz = rpm / 60;
            return `${rpm.toFixed(1)} (${hz.toFixed(2)}Hz)`;
          },
          switchResTab(tab) {
            this.currentResTab = tab;
            const sidebar = document.getElementById('result-sidebar');
            const propsPanel = document.getElementById('props-panel');
            // Toggle sidebar width for graphs/report tabs (wider)
            if (tab === 'graphs' || tab === 'report') {
              sidebar.style.width = '600px';
              if (propsPanel) propsPanel.style.right = '620px';
            } else {
              sidebar.style.width = '320px';
              if (propsPanel) propsPanel.style.right = '340px';
            }
            ['summary', 'vertical', 'coupled', 'graphs', 'report'].forEach(t => {
              const btn = document.getElementById(`rtab-${t}`);
              if (!btn) return;
              if (t === tab) {
                btn.className = 'rtab-btn flex-1 py-2 text-xs font-bold text-indigo-600 border-b-2 border-indigo-600';
              } else {
                btn.className = 'rtab-btn flex-1 py-2 text-xs font-bold text-slate-500 hover:text-indigo-600 border-b-2 border-transparent';
              }
            });
            this.renderResults();
          },
          renderResults() {
            // Always refresh analysis to ensure lastResults matches current App.State
            // This prevents stale data mismatch when report tables (calculated from App.State)
            // differ from totals (calculated from lastResults.sys)
            const sys = App.Physics.calcSystem(App.State.blocks, App.State.machines, App.State.params);
            const stiff = App.Physics.calcStiffness(App.State.piles, sys.cg);
            const loads = this.getAggregatedLoads();
            const result = App.Physics.solve(sys, stiff, loads, App.State.params);
            this.lastResults = { sys, stiff, loads, result };

            const container = document.getElementById('res-content');
            const v = result.vertical || {};
            const yxx = result.coupled_YXX || {};
            const xyy = result.coupled_XYY || {};
            const tor = result.torsion || {};
            const pts = result.pointResults || [];
            let html = '';

            if (this.currentResTab === 'summary') {
              // Find max displacements
              let maxZ = 0, maxX = 0, maxY = 0;
              pts.forEach(p => { maxZ = Math.max(maxZ, p.dispZ); maxX = Math.max(maxX, p.dispX); maxY = Math.max(maxY, p.dispY); });
              html = `
              <div class="bg-slate-50 p-3 rounded border"><h3 class="font-bold text-slate-700 mb-2 uppercase text-[10px]">System Properties</h3>
                <table class="w-full text-[11px]">
                  <tr><td class="text-slate-500">Total Mass</td><td class="font-bold text-right">${sys.mass.toFixed(2)} T <span class="text-slate-400 font-normal">(B:${sys.massBlocks.toFixed(2)} | M:${sys.massMachines.toFixed(2)})</span></td></tr>
                  <tr><td class="text-slate-500">CG (X, Y, Z)</td><td class="font-bold text-right">${sys.cg.x.toFixed(3)}, ${sys.cg.y.toFixed(3)}, ${sys.cg.z.toFixed(3)} m</td></tr>
                  <tr><td class="text-slate-500">Ibx_x (about base)</td><td class="font-bold text-right">${(result.Ibx_x || 0).toFixed(2)} T·m²</td></tr>
                  <tr><td class="text-slate-500">Iby_y (about base)</td><td class="font-bold text-right">${(result.Iby_y || 0).toFixed(2)} T·m²</td></tr>
                  <tr><td class="text-slate-500">Izz</td><td class="font-bold text-right">${sys.Izz.toFixed(2)} T·m²</td></tr>
                </table></div>
              <div class="bg-indigo-50 p-3 rounded border border-indigo-200"><h3 class="font-bold text-indigo-700 mb-2 uppercase text-[10px]">Natural Frequencies @ ${this.fmtFreq(loads.freq)}</h3>
                <table class="w-full text-[11px]">
                  <tr class="border-b"><td class="text-indigo-600 py-1">Vertical Fn(z)</td><td class="font-bold text-right">${this.fmtFreq(v.fn)}</td></tr>
                  <tr class="border-b"><td class="text-indigo-600 py-1">Coupled Y+XX (Fn1,Fn2)</td><td class="font-bold text-right">${this.fmtFreq(yxx.fn1)}, ${this.fmtFreq(yxx.fn2)}</td></tr>
                  <tr class="border-b"><td class="text-indigo-600 py-1">Coupled X+YY (Fn1,Fn2)</td><td class="font-bold text-right">${this.fmtFreq(xyy.fn1)}, ${this.fmtFreq(xyy.fn2)}</td></tr>
                  <tr><td class="text-indigo-600 py-1">Torsion Fn(ψ)</td><td class="font-bold text-right">${this.fmtFreq(tor.fn)}</td></tr>
                </table></div>
              <div class="bg-green-50 p-3 rounded border border-green-200"><h3 class="font-bold text-green-700 mb-2 uppercase text-[10px]">Max Displacement</h3>
                <table class="w-full text-[11px]">
                  <tr><td class="text-green-600">Max Vertical</td><td class="font-bold text-right">${(maxZ * 1e6).toFixed(3)} μm</td></tr>
                  <tr><td class="text-green-600">Max Horizontal X</td><td class="font-bold text-right">${(maxX * 1e6).toFixed(3)} μm</td></tr>
                  <tr><td class="text-green-600">Max Horizontal Y</td><td class="font-bold text-right">${(maxY * 1e6).toFixed(3)} μm</td></tr>
                </table></div>`;

              // === FOUNDATION CHECKS SECTION ===
              const checks = App.Physics.runStaticChecks(sys, App.State.piles, App.State.params);
              const mr = checks.massRatio || {};
              const ecc = checks.eccentricity || {};
              const pr = checks.pileReaction || {};
              const fmtCheck = (pass) => pass ? '<span class="text-green-600 font-bold">✅</span>' : '<span class="text-red-600 font-bold">❌</span>';
              html += `
              <div class="bg-fuchsia-50 p-3 rounded border border-fuchsia-200">
                <h3 class="font-bold text-fuchsia-700 mb-2 uppercase text-[10px]"><i class="fa-solid fa-clipboard-check mr-1"></i>Foundation Checks</h3>
                <table class="w-full text-[10px]">
                  <tr><td class="text-fuchsia-600">Mass Ratio (ACI)</td>
                      <td class="font-bold text-right">${mr.ratio?.toFixed(1) || 'N/A'} : 1</td>
                      <td class="text-right">${fmtCheck(mr.pass)} (≥${mr.limit})</td></tr>
                  <tr><td class="text-fuchsia-600">Eccentricity X</td>
                      <td class="font-bold text-right">${ecc.exPercent?.toFixed(1) || 0}%</td>
                      <td class="text-right">${fmtCheck(ecc.exPercent < ecc.limit)} (<${ecc.limit}%)</td></tr>
                  <tr><td class="text-fuchsia-600">Eccentricity Y</td>
                      <td class="font-bold text-right">${ecc.eyPercent?.toFixed(1) || 0}%</td>
                      <td class="text-right">${fmtCheck(ecc.eyPercent < ecc.limit)} (<${ecc.limit}%)</td></tr>
                  <tr><td class="text-fuchsia-600">Qmax (Comp)</td>
                      <td class="font-bold text-right">${pr.Qmax?.toFixed(0) || 0} kN</td>
                      <td class="text-right">${fmtCheck(pr.passComp)} (≤${pr.compLimit})</td></tr>
                  <tr><td class="text-fuchsia-600">Qmin (Tens)</td>
                      <td class="font-bold text-right">${pr.Qmin?.toFixed(0) || 0} kN</td>
                      <td class="text-right">${fmtCheck(pr.passTens)} (≥-${pr.tensLimit})</td></tr>
                </table>
              </div>`;
            } else if (this.currentResTab === 'vertical') {
              html = `
              <div class="bg-blue-50 p-3 rounded border border-blue-200"><h3 class="font-bold text-blue-700 mb-2 uppercase text-[10px]">Vertical Vibration Analysis</h3>
                <table class="w-full text-[11px]">
                  <tr><td class="text-slate-600 py-1">Natural Freq Fn</td><td class="font-bold text-right">${this.fmtFreq(v.fn)}</td></tr>
                  <tr><td class="text-slate-600 py-1">Resonant Freq Fr</td><td class="font-bold text-right">${this.fmtFreq(v.fr)}</td></tr>
                  <tr><td class="text-slate-600 py-1">Frequency Ratio γ</td><td class="font-bold text-right">${v.gamma?.toFixed(4) || 0}</td></tr>
                  <tr><td class="text-slate-600 py-1">Damping ξz</td><td class="font-bold text-right">${(App.State.params.dampingZ || 0.25).toFixed(2)}</td></tr>
                  <tr class="bg-blue-100"><td class="text-blue-700 py-1 font-bold">DMF</td><td class="font-bold text-right text-blue-800">${v.DMF?.toFixed(6) || 0}</td></tr>
                  <tr class="bg-blue-100"><td class="text-blue-700 py-1 font-bold">Amplitude Dz</td><td class="font-bold text-right text-blue-800">${((v.amp || 0) * 1e9).toFixed(4)} nm</td></tr>
                </table></div>
              <div class="bg-slate-50 p-3 rounded border mt-2"><h3 class="font-bold text-slate-700 mb-2 uppercase text-[10px]">Stiffness</h3>
                <table class="w-full text-[11px]">
                  <tr><td class="text-slate-600">Kz</td><td class="font-bold text-right">${(stiff.Kz).toFixed(0)} kN/m</td></tr>
                  <tr><td class="text-slate-600">Static Force Fz</td><td class="font-bold text-right">${(loads.Fz || 0).toFixed(3)} kN</td></tr>
                </table></div>`;
            } else if (this.currentResTab === 'coupled') {
              html = `
              <div class="bg-purple-50 p-3 rounded border border-purple-200 mb-2"><h3 class="font-bold text-purple-700 mb-2 uppercase text-[10px]">Y-Direction + X-X Rotation (Coupled)</h3>
                <table class="w-full text-[11px]">
                  <tr><td class="text-slate-600 py-1">Fn1 (Low)</td><td class="font-bold text-right">${this.fmtFreq(yxx.fn1)}</td></tr>
                  <tr><td class="text-slate-600 py-1">Fn2 (High)</td><td class="font-bold text-right">${this.fmtFreq(yxx.fn2)}</td></tr>
                  <tr class="bg-purple-100"><td class="text-purple-700 py-1 font-bold">Dy (Y-trans)</td><td class="font-bold text-right text-purple-800">${((yxx.Dy || 0) * 1e9).toFixed(4)} nm</td></tr>
                  <tr class="bg-purple-100"><td class="text-purple-700 py-1 font-bold">Rxx (X-rot)</td><td class="font-bold text-right text-purple-800">${((yxx.Rxx || 0) * 1e9).toFixed(4)} nrad</td></tr>
                </table></div>
              <div class="bg-pink-50 p-3 rounded border border-pink-200 mb-2"><h3 class="font-bold text-pink-700 mb-2 uppercase text-[10px]">X-Direction + Y-Y Rotation (Coupled)</h3>
                <table class="w-full text-[11px]">
                  <tr><td class="text-slate-600 py-1">Fn1 (Low)</td><td class="font-bold text-right">${this.fmtFreq(xyy.fn1)}</td></tr>
                  <tr><td class="text-slate-600 py-1">Fn2 (High)</td><td class="font-bold text-right">${this.fmtFreq(xyy.fn2)}</td></tr>
                  <tr class="bg-pink-100"><td class="text-pink-700 py-1 font-bold">Dx (X-trans)</td><td class="font-bold text-right text-pink-800">${((xyy.Dx || 0) * 1e9).toFixed(4)} nm</td></tr>
                  <tr class="bg-pink-100"><td class="text-pink-700 py-1 font-bold">Ryy (Y-rot)</td><td class="font-bold text-right text-pink-800">${((xyy.Ryy || 0) * 1e9).toFixed(4)} nrad</td></tr>
                </table></div>
              <div class="bg-amber-50 p-3 rounded border border-amber-200"><h3 class="font-bold text-amber-700 mb-2 uppercase text-[10px]">Torsional Vibration (Z-Z)</h3>
                <table class="w-full text-[11px]">
                  <tr><td class="text-slate-600 py-1">Fn</td><td class="font-bold text-right">${this.fmtFreq(tor.fn)}</td></tr>
                  <tr><td class="text-slate-600 py-1">Fr (Resonant)</td><td class="font-bold text-right">${this.fmtFreq(tor.fr)}</td></tr>
                  <tr><td class="text-slate-600 py-1">γ (Freq Ratio)</td><td class="font-bold text-right">${tor.gamma?.toFixed(4) || 0}</td></tr>
                  <tr class="bg-amber-100"><td class="text-amber-700 py-1 font-bold">DMF</td><td class="font-bold text-right text-amber-800">${tor.DMF?.toFixed(6) || 0}</td></tr>
                  <tr class="bg-amber-100"><td class="text-amber-700 py-1 font-bold">Rzz (Torsion)</td><td class="font-bold text-right text-amber-800">${((tor.Rzz || 0) * 1e9).toFixed(4)} nrad</td></tr>
                </table></div>`;
            } else if (this.currentResTab === 'graphs') {
              // Build node options from points
              const points = this.lastResults?.result?.pointResults || [];
              const nodeOptions = '<option value="ALL">-- ALL NODES --</option>' + points.map((p, i) => `<option value="${i}">${p.name}</option>`).join('');
              const dirOptions = '<option value="Z">Vertical (Z)</option><option value="X">Horizontal X</option><option value="Y">Horizontal Y</option><option value="R">Resultant</option>';
              const sweepTable = this.sweepData && this.sweepData.length > 0 ? `
                <div class="bg-white p-2 rounded border mt-2 max-h-32 overflow-y-auto">
                  <table class="w-full text-[9px]">
                    <thead class="bg-slate-100 sticky top-0"><tr><th class="p-1">Freq(RPM)</th><th class="p-1">Disp(μm)</th><th class="p-1">Vel(mm/s)</th><th class="p-1">Accel(m/s²)</th></tr></thead>
                    <tbody>${this.sweepData.map(d => {
                const selIdx = this.selectedSweepNode;
                const dir = this.selectedSweepDir || 'Z';
                const disp = this._getDirectionalDisp(d.nodeDisp, selIdx, dir) * 1e6;
                const omega = (d.freq / 60) * 2 * Math.PI;
                const vel = disp * omega / 1000; // mm/s
                const acc = disp * omega * omega / 1e6; // m/s²
                return `<tr class="border-b"><td class="p-1 text-center">${d.freq}</td><td class="p-1 text-right">${disp.toFixed(4)}</td><td class="p-1 text-right">${vel.toFixed(4)}</td><td class="p-1 text-right">${acc.toFixed(4)}</td></tr>`;
              }).join('')}</tbody>
                  </table>
                </div>` : '';
              // Preserve selected states
              const selNode = this.selectedSweepNode;
              const selDir = this.selectedSweepDir || 'Z';
              const peakZoneOnly = this.peakZoneOnly ?? false;
              const nodeOpts = '<option value="ALL"' + (selNode === 'ALL' ? ' selected' : '') + '>-- ALL NODES --</option>' + points.map((p, i) => `<option value="${i}"${selNode === i ? ' selected' : ''}>${p.name}</option>`).join('');
              const dirOpts = [['Z', 'Vertical (Z)'], ['X', 'Horizontal X'], ['Y', 'Horizontal Y'], ['R', 'Resultant']].map(([v, t]) => `<option value="${v}"${selDir === v ? ' selected' : ''}>${t}</option>`).join('');
              // Track active element to restore focus
              const activeEl = document.activeElement?.id;
              html = `
              <div class="bg-indigo-50 p-2 rounded border border-indigo-200 mb-2">
                <div class="flex items-center gap-2 flex-wrap">
                  <label class="text-[10px] font-bold text-indigo-700">Node:</label>
                  <select id="sweep-node-select" onchange="App.UI.selectedSweepNode=this.value==='ALL'?'ALL':parseInt(this.value); App.UI.updateChartsOnly();" class="text-xs border rounded px-1 py-0.5 w-32">
                    ${nodeOpts || '<option>No nodes</option>'}
                  </select>
                  <label class="text-[10px] font-bold text-indigo-700 ml-2">Dir:</label>
                  <select id="sweep-dir-select" onchange="App.UI.selectedSweepDir=this.value; App.UI.updateChartsOnly();" class="text-xs border rounded px-1 py-0.5 w-28">
                    ${dirOpts}
                  </select>
                  <label class="text-[10px] text-slate-600 ml-4">Peak Zone ±</label>
                  <input type="number" id="peak-zone-pct" value="${this.peakZonePercent || 0}" min="0" max="50" step="5" 
                    onchange="App.UI.peakZonePercent=parseInt(this.value)||0; App.UI.updateChartsOnly();" 
                    class="w-10 text-xs border rounded px-1 py-0.5 text-center">
                  <span class="text-[10px] text-slate-500">%</span>
                  <label class="text-[10px] text-red-600 ml-2"><input type="checkbox" id="show-limits" ${this.showLimits !== false ? 'checked' : ''} onchange="App.UI.showLimits=this.checked; App.UI.updateChartsOnly();"> Limits</label>
                </div>
              </div>
              <div id="charts-container" class="relative select-none" onmousemove="App.UI.handleChartHover(event)" onmouseleave="App.UI.hideChartCrosshair()" onmousedown="App.UI.handleChartMouseDown(event)" onmouseup="App.UI.handleChartMouseUp(event)" ondblclick="App.UI.handleChartDoubleClick()" onwheel="App.UI.handleChartWheel(event)" oncontextmenu="return false;">
                <div id="chart-crosshair" class="absolute w-px bg-red-500 pointer-events-none hidden" style="top:0;bottom:0;"></div>
                <div id="chart-drag-box" class="absolute bg-cyan-400/20 border border-cyan-500 pointer-events-none hidden" style="top:0;bottom:0;"></div>
                <div id="chart-tooltip" class="absolute bg-white/90 text-slate-800 text-[9px] px-2 py-1 rounded border border-slate-300 pointer-events-none hidden z-10 whitespace-nowrap shadow-sm"></div>
                <div class="bg-slate-100 p-2 rounded border text-center mb-1">
                  <h3 class="font-bold text-indigo-700 mb-1 uppercase text-[9px]">Displacement vs Frequency</h3>
                  <canvas id="chart-disp" class="bg-white border rounded mx-auto" style="width:540px;height:130px;"></canvas>
                </div>
                <div class="bg-slate-100 p-2 rounded border text-center mb-1">
                  <h3 class="font-bold text-green-700 mb-1 uppercase text-[9px]">Velocity vs Frequency</h3>
                  <canvas id="chart-vel" class="bg-white border rounded mx-auto" style="width:540px;height:130px;"></canvas>
                </div>
                <div class="bg-slate-100 p-2 rounded border text-center">
                  <h3 class="font-bold text-red-700 mb-1 uppercase text-[9px]">Acceleration vs Frequency</h3>
                  <canvas id="chart-acc" class="bg-white border rounded mx-auto" style="width:540px;height:130px;"></canvas>
                </div>
              </div>
              ${sweepTable}
              <div class="bg-slate-50 p-2 rounded border mt-2 flex gap-2">
                <button onclick="App.UI.runFrequencySweep()" class="flex-1 py-1.5 bg-indigo-600 text-white rounded font-bold text-[10px] hover:bg-indigo-500">
                  <i class="fa-solid fa-wave-square mr-1"></i>Run Sweep
                </button>
              <button onclick="App.UI.openCalSettings()" class="px-3 py-1.5 bg-slate-600 text-white rounded font-bold text-[10px] hover:bg-slate-500">
                  <i class="fa-solid fa-cog"></i>
                </button>
              </div>`;
            } else if (this.currentResTab === 'report') {
              // Legacy-style formatted report - exact match to 0224_A_8800_out.txt
              const p = App.State.projectInfo || {};
              const fmtF = (v, d = 4) => (v || 0).toFixed(d);
              const fmtE = (v) => {
                if (!v || v === 0) return '0.0000000E+00';
                return (v).toExponential(7).toUpperCase();
              };
              const fmtE4 = (v) => {
                if (!v || v === 0) return '0.0000E+00';
                return (v).toExponential(4).toUpperCase();
              };
              const Fp = loads.freq || 0;
              const w_op = (Fp / 60) * 2 * Math.PI;
              const w_op_sq = w_op ** 2;
              const Fz = loads.Fz || 0;
              const Fy = loads.Fy || 0;
              const Fx = loads.Fx || 0;
              const Dz = App.State.params.dampingZ || 0.25;
              const Dx = App.State.params.dampingX || 0.25;
              const Dr = App.State.params.dampingRock || 0.25;
              const Dt = App.State.params.dampingTor || 0.25;
              const isRecip = p.machineType === 'R'; // Reciprocating machine
              const Fs = Fp * 2; // Secondary frequency = 2× primary
              const w_sec = (Fs / 60) * 2 * Math.PI;
              const w_sec_sq = w_sec ** 2;
              const h = result.h || 0;
              const Wt = sys.mass * (App.State.params.gravity || 9.81);
              const Kh = stiff.Kx;

              // Y-XX mode intermediate calculations
              const Kr_yxx = stiff.Kphi_x;
              const It_yxx = sys.Ixx;
              const Ib_yxx = result.Ibx_x;
              const Wtrans_sq_yxx = sys.mass > 0 ? Kh / sys.mass : 0;
              const Wrotat_sq_yxx = Ib_yxx > 0 ? (Kr_yxx - Wt * h) / Ib_yxx : 0;
              const MU_yxx = Wrotat_sq_yxx > 0 ? Wtrans_sq_yxx / Wrotat_sq_yxx : 0;
              const GAMA_yxx = Ib_yxx > 0 ? It_yxx / Ib_yxx : 0;

              // X-YY mode intermediate calculations
              const Kr_xyy = stiff.Kphi_y;
              const It_xyy = sys.Iyy;
              const Ib_xyy = result.Iby_y;
              const Wtrans_sq_xyy = sys.mass > 0 ? Kh / sys.mass : 0;
              const Wrotat_sq_xyy = Ib_xyy > 0 ? (Kr_xyy - Wt * h) / Ib_xyy : 0;
              const MU_xyy = Wrotat_sq_xyy > 0 ? Wtrans_sq_xyy / Wrotat_sq_xyy : 0;
              const GAMA_xyy = Ib_xyy > 0 ? It_xyy / Ib_xyy : 0;

              // Y-XX mode detailed calculations (from solver)
              const wn1_yxx = yxx.fn1 ? (yxx.fn1 / 60) * 2 * Math.PI : 0;
              const wn2_yxx = yxx.fn2 ? (yxx.fn2 / 60) * 2 * Math.PI : 0;
              const Wn1_sq_yxx = wn1_yxx ** 2;
              const Wn2_sq_yxx = wn2_yxx ** 2;
              const Delta_yxx = sys.mass * It_yxx * (Wn1_sq_yxx - w_op_sq) * (Wn2_sq_yxx - w_op_sq);
              const A11_yxx = Math.abs(Delta_yxx) > 1e-10 ? Math.abs(Kh * h * h + Kr_yxx - Wt * h - It_yxx * w_op_sq) / Math.abs(Delta_yxx) : 0;
              const A12_yxx = Math.abs(Delta_yxx) > 1e-10 ? Math.abs(Kh * h) / Math.abs(Delta_yxx) : 0;
              const A22_yxx = Math.abs(Delta_yxx) > 1e-10 ? Math.abs(Kh - sys.mass * w_op_sq) / Math.abs(Delta_yxx) : 0;
              const r_trans_yxx = yxx.fn1 > 0 ? Fp / yxx.fn1 : 0;
              const r_rot_yxx = yxx.fn2 > 0 ? Fp / yxx.fn2 : 0;
              const Ch_yxx = Math.sqrt(Math.pow(1 - r_trans_yxx * r_trans_yxx, 2) + Math.pow(2 * Dx * r_trans_yxx, 2)) > 0 ? Math.abs(1 - r_trans_yxx * r_trans_yxx) / Math.sqrt(Math.pow(1 - r_trans_yxx * r_trans_yxx, 2) + Math.pow(2 * Dx * r_trans_yxx, 2)) : 0;
              const Cr_yxx = Math.sqrt(Math.pow(1 - r_rot_yxx * r_rot_yxx, 2) + Math.pow(2 * Dr * r_rot_yxx, 2)) > 0 ? Math.abs(1 - r_rot_yxx * r_rot_yxx) / Math.sqrt(Math.pow(1 - r_rot_yxx * r_rot_yxx, 2) + Math.pow(2 * Dr * r_rot_yxx, 2)) : 0;

              // X-YY mode detailed calculations  
              const wn1_xyy = xyy.fn1 ? (xyy.fn1 / 60) * 2 * Math.PI : 0;
              const wn2_xyy = xyy.fn2 ? (xyy.fn2 / 60) * 2 * Math.PI : 0;
              const Wn1_sq_xyy = wn1_xyy ** 2;
              const Wn2_sq_xyy = wn2_xyy ** 2;
              const Delta_xyy = sys.mass * It_xyy * (Wn1_sq_xyy - w_op_sq) * (Wn2_sq_xyy - w_op_sq);
              const A11_xyy = Math.abs(Delta_xyy) > 1e-10 ? Math.abs(Kh * h * h + Kr_xyy - Wt * h - It_xyy * w_op_sq) / Math.abs(Delta_xyy) : 0;
              const A12_xyy = Math.abs(Delta_xyy) > 1e-10 ? Math.abs(Kh * h) / Math.abs(Delta_xyy) : 0;
              const A22_xyy = Math.abs(Delta_xyy) > 1e-10 ? Math.abs(Kh - sys.mass * w_op_sq) / Math.abs(Delta_xyy) : 0;
              const r_trans_xyy = xyy.fn1 > 0 ? Fp / xyy.fn1 : 0;
              const r_rot_xyy = xyy.fn2 > 0 ? Fp / xyy.fn2 : 0;
              const Ch_xyy = Math.sqrt(Math.pow(1 - r_trans_xyy * r_trans_xyy, 2) + Math.pow(2 * Dx * r_trans_xyy, 2)) > 0 ? Math.abs(1 - r_trans_xyy * r_trans_xyy) / Math.sqrt(Math.pow(1 - r_trans_xyy * r_trans_xyy, 2) + Math.pow(2 * Dx * r_trans_xyy, 2)) : 0;
              const Cr_xyy = Math.sqrt(Math.pow(1 - r_rot_xyy * r_rot_xyy, 2) + Math.pow(2 * Dr * r_rot_xyy, 2)) > 0 ? Math.abs(1 - r_rot_xyy * r_rot_xyy) / Math.sqrt(Math.pow(1 - r_rot_xyy * r_rot_xyy, 2) + Math.pow(2 * Dr * r_rot_xyy, 2)) : 0;

              // === SECONDARY FREQUENCY COEFFICIENTS (2× Fp) for Reciprocating ===
              // Y-XX at secondary frequency
              const Delta_yxx_s = sys.mass * It_yxx * (Wn1_sq_yxx - w_sec_sq) * (Wn2_sq_yxx - w_sec_sq);
              const A11_yxx_s = Math.abs(Delta_yxx_s) > 1e-10 ? Math.abs(Kh * h * h + Kr_yxx - Wt * h - It_yxx * w_sec_sq) / Math.abs(Delta_yxx_s) : 0;
              const A12_yxx_s = Math.abs(Delta_yxx_s) > 1e-10 ? Math.abs(Kh * h) / Math.abs(Delta_yxx_s) : 0;
              const A22_yxx_s = Math.abs(Delta_yxx_s) > 1e-10 ? Math.abs(Kh - sys.mass * w_sec_sq) / Math.abs(Delta_yxx_s) : 0;
              const r_trans_yxx_s = yxx.fn1 > 0 ? Fs / yxx.fn1 : 0;
              const r_rot_yxx_s = yxx.fn2 > 0 ? Fs / yxx.fn2 : 0;
              const Ch_yxx_s = Math.sqrt(Math.pow(1 - r_trans_yxx_s * r_trans_yxx_s, 2) + Math.pow(2 * Dx * r_trans_yxx_s, 2)) > 0 ? Math.abs(1 - r_trans_yxx_s * r_trans_yxx_s) / Math.sqrt(Math.pow(1 - r_trans_yxx_s * r_trans_yxx_s, 2) + Math.pow(2 * Dx * r_trans_yxx_s, 2)) : 0;
              const Cr_yxx_s = Math.sqrt(Math.pow(1 - r_rot_yxx_s * r_rot_yxx_s, 2) + Math.pow(2 * Dr * r_rot_yxx_s, 2)) > 0 ? Math.abs(1 - r_rot_yxx_s * r_rot_yxx_s) / Math.sqrt(Math.pow(1 - r_rot_yxx_s * r_rot_yxx_s, 2) + Math.pow(2 * Dr * r_rot_yxx_s, 2)) : 0;

              // X-YY at secondary frequency
              const Delta_xyy_s = sys.mass * It_xyy * (Wn1_sq_xyy - w_sec_sq) * (Wn2_sq_xyy - w_sec_sq);
              const A11_xyy_s = Math.abs(Delta_xyy_s) > 1e-10 ? Math.abs(Kh * h * h + Kr_xyy - Wt * h - It_xyy * w_sec_sq) / Math.abs(Delta_xyy_s) : 0;
              const A12_xyy_s = Math.abs(Delta_xyy_s) > 1e-10 ? Math.abs(Kh * h) / Math.abs(Delta_xyy_s) : 0;
              const A22_xyy_s = Math.abs(Delta_xyy_s) > 1e-10 ? Math.abs(Kh - sys.mass * w_sec_sq) / Math.abs(Delta_xyy_s) : 0;
              const r_trans_xyy_s = xyy.fn1 > 0 ? Fs / xyy.fn1 : 0;
              const r_rot_xyy_s = xyy.fn2 > 0 ? Fs / xyy.fn2 : 0;
              const Ch_xyy_s = Math.sqrt(Math.pow(1 - r_trans_xyy_s * r_trans_xyy_s, 2) + Math.pow(2 * Dx * r_trans_xyy_s, 2)) > 0 ? Math.abs(1 - r_trans_xyy_s * r_trans_xyy_s) / Math.sqrt(Math.pow(1 - r_trans_xyy_s * r_trans_xyy_s, 2) + Math.pow(2 * Dx * r_trans_xyy_s, 2)) : 0;
              const Cr_xyy_s = Math.sqrt(Math.pow(1 - r_rot_xyy_s * r_rot_xyy_s, 2) + Math.pow(2 * Dr * r_rot_xyy_s, 2)) > 0 ? Math.abs(1 - r_rot_xyy_s * r_rot_xyy_s) / Math.sqrt(Math.pow(1 - r_rot_xyy_s * r_rot_xyy_s, 2) + Math.pow(2 * Dr * r_rot_xyy_s, 2)) : 0;

              // BMx_x and BMy_y moment calculations
              // XCT, YCT, ZCT = System CG position
              const XCT = sys.cg?.x || 0;
              const YCT = sys.cg?.y || 0;
              const ZCT = sys.cg?.z || 0;
              // Xc, Yc, Zc = Force CG position (from first load point)
              const firstLoad = (App.State.loadPoints || [])[0] || {};
              const Xc_force = firstLoad.X ?? XCT;
              const Yc_force = firstLoad.Y ?? YCT;
              const Zc_force = firstLoad.Z ?? ZCT;
              // BMx_x = Mx + Fy*|Zc-ZCT| + Fz*|Yc-YCT|
              const BMx_x = (loads.Mx || 0) + Math.abs(Fy) * Math.abs(Zc_force - ZCT) + Math.abs(Fz) * Math.abs(Yc_force - YCT);
              // BMy_y = My + Fx*|Zc-ZCT| + Fz*|Xc-XCT|
              const BMy_y = (loads.My || 0) + Math.abs(Fx) * Math.abs(Zc_force - ZCT) + Math.abs(Fz) * Math.abs(Xc_force - XCT);

              // Machine displacements table - offsets from system CG (XCT, YCT, ZCT)
              const machineDispsData = (App.State.machines || []).map((m, i) => {
                const dxm = m.X - XCT;
                const dym = m.Y - YCT;
                const dzm = m.Z - ZCT;
                const vDisp = Math.abs(v.amp || 0) + Math.abs(yxx.Rxx || 0) * Math.abs(dym) + Math.abs(xyy.Ryy || 0) * Math.abs(dxm);
                const xDisp = Math.abs(xyy.Dx || 0) + Math.abs(tor.Rzz || 0) * Math.abs(dym) + Math.abs(xyy.Ryy || 0) * Math.abs(dzm);
                const yDisp = Math.abs(yxx.Dy || 0) + Math.abs(tor.Rzz || 0) * Math.abs(dxm) + Math.abs(yxx.Rxx || 0) * Math.abs(dzm);
                return { i, dxm, dym, dzm, vDisp, xDisp, yDisp };
              });

              const machDisps = machineDispsData.map(d =>
                '       ' + (d.i + 1).toString().padStart(4) + '      ' + fmtF(d.dxm, 3).padStart(6) + '  ' + fmtF(d.dym, 3).padStart(6) + '   ' + fmtF(d.dzm, 3).padStart(6) + '  ' + fmtE4(d.vDisp) + '  ' + fmtE4(d.xDisp) + '  ' + fmtE4(d.yDisp)
              ).join('\n');

              const maxMachHoriz = Math.max(...machineDispsData.map(d => Math.max(d.xDisp, d.yDisp)), 0);
              const maxMachVert = Math.max(...machineDispsData.map(d => d.vDisp), 0);

              // Piles list
              const pilesTable = (App.State.piles || []).map((pl, i) =>
                '       ' + (i + 1).toString().padStart(2) + '        ' + fmtF(pl.X, 3).padStart(8) + '       ' + fmtF(pl.Y, 3).padStart(8)
              ).join('\n');

              const machinesTable = (App.State.machines || []).map((m, i) =>
                '       ' + fmtF(m.W, 2).padStart(8) + '   ' + fmtF(m.X, 3).padStart(7) + ' ' + fmtF(m.Y, 3).padStart(7) + ' ' + fmtF(m.Z, 3).padStart(7) + '   ' + fmtF(m.Ix || 0, 3) + '       ' + fmtF(m.Iy || 0, 3) + '       ' + fmtF(m.Iz || 0, 3)
              ).join('\n');

              // Number of piles
              const nPiles = (App.State.piles || []).length || 1;

              // Force CG - already defined above as Xc_force, Yc_force, Zc_force
              const Xc_load = Xc_force;
              const Yc_load = Yc_force;
              const Zc_load = Zc_force;

              // Block mass table - first moment of inertia
              const g = App.State.params.gravity || 9.81;
              const blockMassTable = (App.State.blocks || []).filter(b => b.op !== -1).map((b, i) => {
                const V = b.L * b.W * b.H;
                const wc = (App.State.params.concreteDensity || 24);
                const mass = V * wc / g;
                const xc = b.X + b.L / 2;
                const yc = b.Y + b.W / 2;
                const zc = b.Z + b.H / 2;
                const Qx = mass * xc;
                const Qy = mass * yc;
                const Qz = mass * zc;
                return '     ' + (i + 1).toString().padStart(2) + '  ' + fmtF(mass, 4).padStart(8) + '   ' + fmtF(xc, 4).padStart(8) + '  ' + fmtF(yc, 4).padStart(8) + '  ' + fmtF(zc, 4).padStart(8) + fmtF(Qx, 4).padStart(10) + fmtF(Qy, 4).padStart(10) + fmtF(Qz, 4).padStart(10);
              }).join('\n');

              // Machine mass table - first moment of inertia
              const machineMassTable = (App.State.machines || []).map((m, i) => {
                const mass = m.W / g;
                const Qx = mass * m.X;
                const Qy = mass * m.Y;
                const Qz = mass * m.Z;
                return '     ' + (i + 1).toString().padStart(2) + '    ' + fmtF(mass, 4).padStart(6) + '   ' + fmtF(m.X, 4).padStart(8) + '  ' + fmtF(m.Y, 4).padStart(8) + '  ' + fmtF(m.Z, 4).padStart(8) + fmtF(Qx, 4).padStart(10) + fmtF(Qy, 4).padStart(10) + fmtF(Qz, 4).padStart(10);
              }).join('\n');

              // Block inertia table - second moment about system CG
              const blockInertiaTable = (App.State.blocks || []).filter(b => b.op !== -1).map((b, i) => {
                const V = b.L * b.W * b.H;
                const wc = (App.State.params.concreteDensity || 24);
                const mass = V * wc / g;
                const xc = b.X + b.L / 2;
                const yc = b.Y + b.W / 2;
                const zc = b.Z + b.H / 2;
                const dx = xc - sys.cg.x;
                const dy = yc - sys.cg.y;
                const dz = zc - sys.cg.z;
                // Local inertia (solid rectangular block)
                const Ixx_local = mass * (b.W * b.W + b.H * b.H) / 12;
                const Iyy_local = mass * (b.L * b.L + b.H * b.H) / 12;
                const Izz_local = mass * (b.L * b.L + b.W * b.W) / 12;
                // Parallel axis theorem
                const Itx_x = Ixx_local + mass * (dy * dy + dz * dz);
                const Ity_y = Iyy_local + mass * (dx * dx + dz * dz);
                const Itz_z = Izz_local + mass * (dx * dx + dy * dy);
                return '     ' + (i + 1).toString().padStart(2) + ' ' + fmtF(mass, 4).padStart(7) + '  ' + fmtF(dx, 4).padStart(7) + '  ' + fmtF(dy, 4).padStart(7) + '  ' + fmtF(dz, 4).padStart(7) + '  ' + fmtE4(Itx_x) + '  ' + fmtE4(Ity_y) + '  ' + fmtE4(Itz_z);
              }).join('\n');

              // Block local inertia table - second moment of inertia
              const blockLocalInertiaTable = (App.State.blocks || []).filter(b => b.op !== -1).map((b, i) => {
                const V = b.L * b.W * b.H;
                const wc = (App.State.params.concreteDensity || 24);
                const mass = V * wc / g;
                const xc = b.X + b.L / 2;
                const yc = b.Y + b.W / 2;
                const zc = b.Z + b.H / 2;
                // Local inertia (solid rectangular block)
                const Ixx_local = mass * (b.W * b.W + b.H * b.H) / 12;
                const Iyy_local = mass * (b.L * b.L + b.H * b.H) / 12;
                const Izz_local = mass * (b.L * b.L + b.W * b.W) / 12;
                return '     ' + (i + 1).toString().padStart(2) + '  ' + fmtF(mass, 4).padStart(7) + ' ' + fmtF(xc, 3).padStart(5) + ' ' + fmtF(yc, 3).padStart(5) + ' ' + fmtF(zc, 3).padStart(5) + '    ' + fmtE4(Ixx_local) + '    ' + fmtE4(Iyy_local) + '    ' + fmtE4(Izz_local);
              }).join('\n');

              // Machine inertia table - second moment about system CG
              const machineInertiaTable = (App.State.machines || []).map((m, i) => {
                const mass = m.W / g;
                const dx = m.X - sys.cg.x;
                const dy = m.Y - sys.cg.y;
                const dz = m.Z - sys.cg.z;
                // Machine local inertia (from input) + parallel axis
                const Itx_x = (m.Ix || 0) + mass * (dy * dy + dz * dz);
                const Ity_y = (m.Iy || 0) + mass * (dx * dx + dz * dz);
                const Itz_z = (m.Iz || 0) + mass * (dx * dx + dy * dy);
                return '     ' + (i + 1).toString().padStart(2) + '   ' + fmtF(mass, 4).padStart(6) + '   ' + fmtF(dx, 4).padStart(6) + '  ' + fmtF(dy, 4).padStart(7) + '  ' + fmtF(dz, 4).padStart(7) + '  ' + fmtE4(Itx_x) + '  ' + fmtE4(Ity_y) + '  ' + fmtE4(Itz_z);
              }).join('\n');


              html = '<div class="relative border rounded overflow-hidden">' +
                '<div class="sticky top-0 z-10 flex justify-end p-1 bg-white border-b">' +
                '<button onclick="App.UI.copyReportToClipboard()" class="px-2 py-1 bg-slate-700 text-white rounded text-[9px] hover:bg-slate-600" title="Copy to Clipboard">' +
                '<i class="fa-solid fa-copy mr-1"></i>Copy' +
                '</button>' +
                '</div>' +
                '<div id="report-text-container" tabindex="0" class="bg-white p-3 font-mono text-[9px] leading-tight whitespace-pre overflow-y-auto" style="max-height:calc(100vh - 230px); user-select: text; cursor: text;">' +
                ' **************************************************************\n' +
                ' *                                                            *\n' +
                ' * DYNAMICAL ANALYSIS OF VIBRATING MACHINE FOUNDATION ON PILE *\n' +
                ' *                                                            *\n' +
                ' *              PilePro Application                           *\n' +
                ' *                                                            *\n' +
                ' **************************************************************\n\n\n' +
                ' *****************\n' +
                ' *  INPUT  DATA  *\n' +
                ' *****************\n\n' +
                ' TITLE : ' + (p.jobName || 'Untitled') + '\n\n' +
                ' GRAVITATIONAL CONSTANT (GRAV) =     ' + fmtF(App.State.params.gravity || 9.81, 4) + ' M/SEC**2\n' +
                ' STRENGTH OF CONCRETE FOR PILE  (Fc\')  =   ' + fmtF(App.State.params.concreteStrength || 280, 4) + ' KG/CM**2\n' +
                ' UNIT WEIGHT OF CONCRETE  (WC) =    ' + fmtF(App.State.params.concreteDensity || 24, 4) + ' KN/M**3\n' +
                ' DAMPING RATIO FOR VERTI.  VIB. =     ' + fmtF(Dz) + '\n' +
                '               FOR HORIZ.  VIB. =     ' + fmtF(Dx) + '\n' +
                '               FOR ROCKING VIB. =     ' + fmtF(Dr) + '\n' +
                '               FOR TORSION VIB. =     ' + fmtF(Dt) + '\n\n' +
                '  **  DATA FOR MACHINE **\n\n' +
                ' TYPE OF MACHINE   :' + (p.machineType || 'CENTRIFUGAL') + '\n\n' +
                ' OPERATION FREQUENCY (PRIMARY)   (Fp) =  ' + fmtF(Fp, 4) + ' rpm\n\n' +
                '    CONCENTRATED             LOCATION                 I ABOUT C.G.\n' +
                '  (MACHINE) WEIGHT      XCM     YCM     ZCM    Ix_x        Iy_y        Iz_z\n' +
                '       (KN)             (M)     (M)     (M)  (T-M**2)    (T-M**2)    (T-M**2)\n' +
                ' -------------------------------------------------------------------------------\n' +
                machinesTable + '\n' +
                ' ===============================================================================\n\n' +
                '  **  DATA FOR ACTION FORCES **\n\n' +
                ' MAX X-DIR PRIMARY FORCE        FX(p) =     ' + fmtF(Fx, 4) + ' KN\n' +
                ' C.G. OF THE FORCE (Yc,Zc)            =     ' + fmtF(Yc_load, 4) + ' M           ' + fmtF(Zc_load, 4) + ' M\n\n' +
                ' MAX Y-DIR PRIMARY  FORCE       FY(p) =     ' + fmtF(Fy, 4) + ' KN\n' +
                ' C.G. OF THE FORCE (Zc,Xc)            =     ' + fmtF(Zc_load, 4) + ' M          ' + fmtF(Xc_load, 4) + ' M\n\n' +
                ' MAX Z-DIR PRIMARY  FORCE       FZ(p) =     ' + fmtF(Fz, 4) + ' KN\n' +
                ' C.G. OF THE FORCE (Xc,Yc)            =    ' + fmtF(Xc_load, 4) + ' M           ' + fmtF(Yc_load, 4) + ' M\n\n' +
                ' MAX PRIMARY   MOMENT ABOUT X-X AXIS Mx_x(p) =     ' + fmtF(loads.Mx || 0, 4) + ' KN-M\n\n' +
                ' MAX PRIMARY   MOMENT ABOUT Y-Y AXIS My_y(p) =     ' + fmtF(loads.My || 0, 4) + ' KN-M\n\n' +
                ' MAX TORSIONAL PRIMARY MOMENT        Mz_z(p) =     ' + fmtF(loads.Mz || 0, 4) + ' KN-M\n\n' +
                ' ** DATA FOR FOUNDATION **\n\n' +
                '  ELEV. OF BOTTOM OF PILE CAP (H) =  ' + fmtF(App.State.params.zBottomOverride || result.zBottom || 0, 7) + '     M\n\n' +
                '       NODE           X         Y         Z\n' +
                '                     (M)       (M)       (M)\n' +
                ' --------------------------------------------------\n' +
                (App.State.points || []).map((pt, i) => '         ' + (i + 1).toString().padStart(2) + '        ' + fmtF(pt.X, 3).padStart(6) + '   ' + fmtF(pt.Y, 3).padStart(6) + '   ' + fmtF((pt.Z || 0), 3).padStart(6)).join('\n') + '\n' +
                ' ==================================================\n\n\n' +
                '     BLOCK                         NODE                   CONTRIBUTION\n' +
                '        ID              1         2         3         4\n' +
                ' ------------------------------------------------------------------------\n' +
                (App.State.blocks || []).filter(b => b.op !== -1).map((b, i) => '         ' + (i + 1).toString().padStart(2) + '              ' + (i * 4 + 1) + '         ' + (i * 4 + 2) + '         ' + (i * 4 + 3) + '         ' + (i * 4 + 4) + '        1.').join('\n') + '\n' +
                ' ========================================================================\n\n' +
                '  **  DATA FOR PILES  **\n\n' +
                '  VERTICAL   STIFNESS OF PILE =    ' + fmtF(stiff.Kz / nPiles, 0) + '\n\n' +
                '  HORIZONTAL STIFNESS OF PILE =    ' + fmtF(stiff.Kx / nPiles, 1) + '\n\n' +
                '  ** LOCATION OF PILE **\n\n' +
                '    PILE NO               X                   Y\n' +
                '                         (M)                 (M)\n' +
                ' -----------------------------------------------------\n' +
                pilesTable + '\n' +
                ' =====================================================\n\n' +
                '  ** POINTS TO CACULATE DISPLACEMENT **\n\n' +
                '    POINT         X              Y              Z\n' +
                ' -------------------------------------------------------\n' +
                (App.State.points || []).map((pt, i) => '       ' + (i + 1).toString().padStart(2) + '        ' + fmtF(pt.X, 4).padStart(8) + '       ' + fmtF(pt.Y, 4).padStart(8) + '       ' + fmtF((pt.Z || 0), 4).padStart(8)).join('\n') + '\n\n' +
                ' **************************************\n' +
                ' *  GEOMETRICAL PROPERTIES OF SYSTEM  *\n' +
                ' **************************************\n\n' +
                '  ** FIRST MOMENT OF MASS INERTIA OF FOUNDATION\n\n' +
                ' BLOCK      MASS        XC        YC        ZC        QX        QY        QZ\n' +
                '             (T)       (M)       (M)       (M)     (T-M)     (T-M)     (T-M)\n' +
                ' -------------------------------------------------------------------------------\n' +
                blockMassTable + '\n' +
                ' -------------------------------------------------------------------------------\n' +
                ' total  ' + fmtF(sys.massBlocks || 0, 4).padStart(8) + '                              ' + fmtF(sys.QxBlocks || 0, 4).padStart(10) + fmtF(sys.QyBlocks || 0, 4).padStart(10) + fmtF(sys.QzBlocks || 0, 4).padStart(10) + '\n\n\n' +
                '  ** FIRST MOMENT OF MASS INERTIA OF CONCENTRATED MASS OF MACHINE\n\n' +
                '    NO      MASS        XC        YC        ZC        QX        QY        QZ\n' +
                '             (T)       (M)       (M)       (M)     (T-M)     (T-M)     (T-M)\n' +
                ' -------------------------------------------------------------------------------\n' +
                machineMassTable + '\n' +
                ' -------------------------------------------------------------------------------\n' +
                ' total   ' + fmtF(sys.massMachines || 0, 4).padStart(7) + '                                ' + fmtF(sys.QxMachines || 0, 4).padStart(10) + fmtF(sys.QyMachines || 0, 4).padStart(10) + fmtF(sys.QzMachines || 0, 4).padStart(10) + '\n\n' +
                '                          WT\n' +
                '  TOTAL MASS   (MT) =    ----   =    ' + fmtF(sys.mass, 4) + '     T\n' +
                '                         GRAV\n\n' +
                '  TOTAL    QX =   ' + fmtF(sys.Qx, 4).padStart(10) + '     T-M\n\n' +
                '  TOTAL    QY =    ' + fmtF(sys.Qy, 4).padStart(9) + '     T-M\n\n' +
                '  TOTAL    QZ =   ' + fmtF(sys.Qz, 4).padStart(10) + '     T-M\n\n' +
                '  ** SYSTEM C.G. :\n\n' +
                '  XCT = QX/MT =   ' + fmtF(sys.cg.x, 6) + '     M\n\n' +
                '  YCT = QY/MT =    ' + fmtF(sys.cg.y, 6) + '     M\n\n' +
                '  ZCT = QZ/MT =   ' + fmtF(sys.cg.z, 6) + '     M\n\n\n' +
                '  ** LOCAL SECOND MOMENT OF MASS INERTIA OF FOUNDATION\n\n' +
                '  BLOCK      MASS    XC    YC    ZC        Ixx           Iyy           Izz\n' +
                '              (T)   (M)   (M)   (M)      (T-M**2)      (T-M**2)      (T-M**2)\n' +
                ' -------------------------------------------------------------------------------\n' +
                blockLocalInertiaTable + '\n\n\n' +
                '  ** SECOND MOMENT OF MASS INERTIA ABOUT SYSTEM C.G.\n\n' +
                '  (1) FOUNDATION\n\n' +
                ' BLOCK     MASS   XC-XCT   YC-YCT   ZC-ZCT       Itx_x       Ity_y       Itz_z\n' +
                '            (T)      (M)      (M)      (M)    (T-M**2)    (T-M**2)    (T-M**2)\n' +
                ' -------------------------------------------------------------------------------\n' +
                blockInertiaTable + '\n' +
                ' -------------------------------------------------------------------------------\n' +
                ' total                                      ' + fmtE4(sys.Ixx_blocks || sys.Ixx) + '  ' + fmtE4(sys.Iyy_blocks || sys.Iyy) + '  ' + fmtE4(sys.Izz_blocks || sys.Izz) + '\n\n' +
                '  (2) CONCENTRATED MASS OF MACHINE\n\n' +
                '    NO     MASS   XC-XCT   YC-YCT   ZC-ZCT       Itx_x       Ity_y       Itz_z\n' +
                '            (T)      (M)      (M)      (M)    (T-M**2)    (T-M**2)    (T-M**2)\n' +
                ' -------------------------------------------------------------------------------\n' +
                machineInertiaTable + '\n' +
                ' -------------------------------------------------------------------------------\n' +
                ' total                                      ' + fmtE4(sys.Ixx_machines || 0) + '  ' + fmtE4(sys.Iyy_machines || 0) + '  ' + fmtE4(sys.Izz_machines || 0) + '\n\n\n' +
                ' ===============================================================================\n' +
                ' TOTAL                                      ' + fmtE4(sys.Ixx) + '  ' + fmtE4(sys.Iyy) + '  ' + fmtE4(sys.Izz) + '\n\n' +
                '  ** ABOUT THE AXIS PASSING THROUGH THE CENTROID OF THE BASE AREA\n\n' +
                '  VERTICAL DISTANCE FROM C.G. TO BASE OF FDN (h) =   ' + fmtF(h, 6) + '     M\n\n' +
                '                        2\n' +
                '  Ibx_x = Itx_x + MT * h  =    ' + fmtF(result.Ibx_x, 3) + '     T-M**2\n\n' +
                '                        2\n' +
                '  Iby_y = Ity_y + MT * h  =    ' + fmtF(result.Iby_y, 3) + '     T-M**2\n\n' +
                ' ***************************\n' +
                ' *  STIFFNESS CALCULATION  *\n' +
                ' ***************************\n\n' +
                '  ** VERTICAL **\n\n' +
                '  INDIVIDUAL PILE STIFFNESS :\n\n' +
                '  Kvi =    ' + fmtF(stiff.Kz / nPiles, 0) + '.     KN/M\n\n' +
                '  TOTAL STIFFNESS :\n\n' +
                '  Kv = N x Kvi =    ' + fmtF(stiff.Kz, 0) + '.     KN/M\n\n' +
                '  ** HORIZONTAL **\n\n' +
                '  INDIVIDUAL PILE STIFFNESS :\n\n' +
                '  Khi =    ' + fmtF(stiff.Kx / nPiles, 1) + '     KN/M\n\n' +
                '  TOTAL STIFFNESS :\n\n' +
                '  Kh = N x Khi =    ' + fmtF(stiff.Kx, 1) + '     KN/M\n\n\n' +
                '  ** ROCKING **\n\n' +
                '  C.G. of pile (Xc,Yc) =   ' + fmtF(stiff.pileCgX || 0, 6) + '       ' + fmtF(stiff.pileCgY || 0, 6) + '\n\n' +
                '                           2\n' +
                '  Kx-x = SUM {Kvi x (Yi-Yc) } =   ' + fmtE(stiff.Kphi_x) + ' KN-M/RAD\n\n' +
                '                           2\n' +
                '  Ky_y = SUM {Kvi x (Xi-Xc) } =    ' + fmtF(stiff.Kphi_y, 0) + '.     KN-M/RAD\n\n' +
                '  ** TORSION **\n' +
                '                           2         2\n' +
                '  Kzz = SUM {Khi x [(Xi-Xc) + (Yi-Yc) ]} =    ' + fmtF(stiff.Kpsi, 0) + '.     KN-M/RAD\n\n\n' +
                ' ************************************\n' +
                ' *  SUMMARY OF DYNAMICAL PROPERTIS  *\n' +
                ' ************************************\n\n' +
                '     TOTAL MASS          Ibx_x          Iby_y          Itz_z\n\n' +
                '       ' + fmtF(sys.mass, 4).padStart(10) + '      ' + fmtF(result.Ibx_x, 4).padStart(10) + '      ' + fmtF(result.Iby_y, 4).padStart(10) + '      ' + fmtF(sys.Izz, 4).padStart(10) + '\n\n\n' +
                '  DAMPING RATIO\n\n' +
                '          Dx          Dy          Dz        Dx_x        Dy-y        Dz_z\n\n' +
                '      ' + fmtF(Dx) + '      ' + fmtF(Dx) + '      ' + fmtF(Dz) + '      ' + fmtF(Dr) + '      ' + fmtF(Dr) + '      ' + fmtF(Dt) + '\n\n\n' +
                '  STIFFNESS\n\n' +
                '     Kx   =    ' + fmtF(stiff.Kx, 4) + '\n' +
                '     Ky   =    ' + fmtF(stiff.Ky, 4) + '\n' +
                '     Kz   =   ' + fmtF(stiff.Kz, 4) + '\n' +
                '     Kx_x =  ' + fmtF(stiff.Kphi_x, 4) + '\n' +
                '     Ky_y =   ' + fmtF(stiff.Kphi_y, 4) + '\n' +
                '     Kz_z =   ' + fmtF(stiff.Kpsi, 4) + '\n\n' +
                ' *******************************\n' +
                ' *     VIBRATION ANALYSIS      *\n' +
                ' *******************************\n\n' +
                ' ** VERTICAL VIBRATION **\n\n' +
                '  NATURAL FREQUENCY :\n' +
                '                      ___\n' +
                '           60        / K\n' +
                '  Fn = ----------   / --- =    ' + fmtF(v.fn, 4) + '     (rpm)\n' +
                '       2 x 3.1416 \\/   Mt\n\n' +
                '  DAMPING RATIO  D =   ' + fmtF(Dz) + '\n\n' +
                '  RESONANT FREQUENCY :\n' +
                '              __________\n' +
                '             /         2\n' +
                '  Fr = Fn   / 1 - 2 x D  =    ' + fmtF(v.fr, 4) + '     (rpm)\n' +
                '          \\/\n\n' +
                '                              Fp\n' +
                '  RESONANCE FREQUENCY RATIO  ---- =    ' + fmtF(v.fr > 0 ? Fp / v.fr : 0, 6) + '\n' +
                '                              Fr\n\n\n' +
                '  AT PRIMARY FREQUENCY :\n' +
                '  ======================\n\n' +
                '                             Fp\n' +
                '  FREQUENCY RATIO    GAMA = ---- =   ' + fmtF(v.gamma, 6) + '\n' +
                '                             Fn\n\n' +
                '  MAGNIFICATION FACTOR :\n' +
                '                    1\n' +
                '  MF = -------------------------- =   ' + fmtE(v.DMF) + '  ... EQ.(1)\n' +
                '          ----------------------\n' +
                '         /      2  2           2\n' +
                '       \\/(1-GAMA  ) + (2DxGAMA)\n\n' +
                // AT SECONDARY FREQUENCY - only show for Reciprocating machines
                (isRecip ? (
                  '\n  AT SECONDARY FREQUENCY :\n' +
                  '  ========================\n\n' +
                  '                             Fs\n' +
                  '  FREQUENCY RATIO    GAMA = ---- =    ' + fmtF(v.gamma_s, 6) + '\n' +
                  '                             Fn\n\n' +
                  '  BY EQ.(1) MAGNIFICATION FACTOR    MF(s)  =   ' + fmtE(v.DMF_s) + '\n\n'
                ) : '') +
                '\n  PRIMARY   VERTICAL FORCE FZ(p) =   ' + fmtF(Fz, 7) + '     KN\n\n' +
                '  SECONDARY VERTICAL FORCE FZ(s) =   ' + fmtE(loads.Fz_s || 0) + ' KN\n\n\n' +
                '  DISPLACEMENT :\n\n' +
                '        MF(p) x FZ(p) + MF(s) x FZ(s)\n' +
                '  DZ = ------------------------------ =   ' + fmtE(v.amp) + ' M\n' +
                '                      Kz\n\n\n' +
                ' **  COUPLED Y-DIR TRANSLATION AND X-X ROTATION  **\n\n' +
                '                          ___\n' +
                '               60        / Kh\n' +
                '  Ftrans = ----------   / --- =    ' + fmtF(yxx.Ftrans || 0, 4) + '     (rpm)\n' +
                '           2 x 3.1416 \\/   Mt\n' +
                '                          _____________\n' +
                '               60        / Kr - Wt x h\n' +
                '  Frotat = ----------   / ------------- =    ' + fmtF(yxx.Frotat || 0, 4) + '     (rpm)\n' +
                '          2 x 3.1416 \\/        Ib\n\n' +
                '                       2\n' +
                '  CIRCULAR FREQUENCY  Wtrans  =   ' + fmtF(Wtrans_sq_yxx, 4) + '     (RAD/SEC)**2\n' +
                '                       2\n' +
                '                      Wrotat  =   ' + fmtF(Wrotat_sq_yxx, 4) + '     (RAD/SEC)**2\n\n' +
                '          Wtrans   2\n' +
                '  MU = (----------) =   ' + fmtF(MU_yxx, 7) + '\n' +
                '          Wrotat\n\n' +
                '           It\n' +
                '  GAMA = -------- =   ' + fmtF(GAMA_yxx, 7) + '\n' +
                '           Ib\n\n' +
                '  NATURAL FREQUENCY OF THE COUPLED SYSTEM :\n\n' +
                '         2                 _______________________\n' +
                '   2    Wrotat            /       2\n' +
                '  Wn1 = ------ [1+ MU - \\/(1 + MU) - 4 GAMA x MU ] =    ' + fmtF(Wn1_sq_yxx, 3) + '\n' +
                '        2 GAMA\n\n' +
                '         2                 _______________________\n' +
                '   2    Wrotat            /       2\n' +
                '  Wn2 = ------ [1+ MU + \\/(1 + MU) - 4 GAMA x MU ] =    ' + fmtF(Wn2_sq_yxx, 3) + '\n' +
                '        2 GAMA\n\n' +
                '  Fn1 =    ' + fmtF(yxx.fn1, 4) + '     (RPM)\n\n' +
                '  Fn2 =    ' + fmtF(yxx.fn2, 4) + '     (RPM)\n\n' +
                '  AT PRIMARY FREQUENCY :\n' +
                '  =======================\n' +
                '                                2\n' +
                '  OPERATION CIRCULAR FREQENCY  Wp =    ' + fmtF(w_op_sq, 1) + '\n\n' +
                '  COEFFICIENTS FOR AMPLITUDES :\n\n' +
                '                     2    2      2    2\n' +
                '  DELTA = Mt It ( Wn1 - Wp ) (Wn2 - Wp ) =   ' + fmtE(Delta_yxx) + '\n\n' +
                '                2                       2\n' +
                '        | Kh x h + Kr - Wt x h - It x Wp |\n' +
                '  A11 = ----------------------------------- =  ' + fmtE(A11_yxx) + '\n' +
                '                     DELTA\n\n' +
                '               | Kh x h |\n' +
                '  A12 = A21 = ------------ = ' + fmtE(A12_yxx) + '\n' +
                '                  DELTA\n\n' +
                '                       2\n' +
                '         | Kh - Mt x Wp |\n' +
                '  A22 = ------------------- =  ' + fmtE(A22_yxx) + '\n' +
                '               DELTA\n\n' +
                '  APPROXIMATED DAMPING EFFECT:\n\n' +
                '                     2\n' +
                '             |  1 - r  |\n' +
                '  Ci =  ------------------------ ; (i = h or r)\n' +
                '         ____________________\n' +
                '        /    2 2            2\n' +
                '      \\/ (1-r )   + (2 Di r)\n\n\n' +
                '  FOR TRANSLATION:\n' +
                '          Fp\n' +
                '    r = ----- =    ' + fmtF(r_trans_yxx, 5) + '\n' +
                '         Fn1\n' +
                '    Ch =   ' + fmtF(Ch_yxx, 7) + '\n\n' +
                '  FOR ROTATION:\n' +
                '          Fp\n' +
                '    r = ------ =    ' + fmtF(r_rot_yxx, 5) + '\n' +
                '         Fn2\n' +
                '    Cr =   ' + fmtF(Cr_yxx, 7) + '\n\n' +
                // AT SECONDARY FREQUENCY for Y-XX - only for Reciprocating
                (isRecip ? (
                  '  AT SECONDARY FREQUENCY :\n' +
                  '  ========================\n' +
                  '                                2\n' +
                  '  OPERATION CIRCULAR FREQENCY  Wp =    ' + fmtF(w_sec_sq, 1) + '\n\n' +
                  '  COEFFICIENTS FOR AMPLITUDES :\n\n' +
                  '                     2    2      2    2\n' +
                  '  DELTA = Mt It ( Wn1 - Wp ) (Wn2 - Wp ) =   ' + fmtE(Delta_yxx_s) + '\n\n' +
                  '                2                       2\n' +
                  '        | Kh x h + Kr - Wt x h - It x Wp |\n' +
                  '  A11 = ----------------------------------- =  ' + fmtE(A11_yxx_s) + '\n' +
                  '                     DELTA\n\n' +
                  '               | Kh x h |\n' +
                  '  A12 = A21 = ------------ = ' + fmtE(A12_yxx_s) + '\n' +
                  '                  DELTA\n\n' +
                  '                       2\n' +
                  '         | Kh - Mt x Wp |\n' +
                  '  A22 = ------------------- =  ' + fmtE(A22_yxx_s) + '\n' +
                  '               DELTA\n\n' +
                  '  APPROXIMATED DAMPING EFFECT:\n\n' +
                  '                     2\n' +
                  '             |  1 - r  |\n' +
                  '  Ci =  ------------------------ ; (i = h or r)\n' +
                  '         ____________________\n' +
                  '        /    2 2            2\n' +
                  '      \\/ (1-r )   + (2 Di r)\n\n' +
                  '  FOR TRANSLATION:\n' +
                  '          Fp\n' +
                  '    r = ----- =    ' + fmtF(r_trans_yxx_s, 5) + '\n' +
                  '         Fn1\n' +
                  '    Ch =   ' + fmtF(Ch_yxx_s, 7) + '\n\n' +
                  '  FOR ROTATION:\n' +
                  '          Fp\n' +
                  '    r = ------ =    ' + fmtF(r_rot_yxx_s, 5) + '\n' +
                  '         Fn2\n' +
                  '    Cr =   ' + fmtF(Cr_yxx_s, 7) + '\n\n'
                ) : '') +
                '  PRIMARY   HORIZONTAL FORCE FY(p) =   ' + fmtF(Fy, 7) + '     KN\n\n' +
                '  SECONDARY HORIZONTAL FORCE FY(s) =   ' + fmtE(loads.Fy_s || 0) + ' KN\n\n' +
                ' PRIMARY   MOMENT :\n\n' +
                ' BMx_x(p)=Mx_x(p)+FY(p)x|Zc-ZCT|+FZ(p)x |Yc-YCT| =       ' + fmtF(BMx_x, 4) + ' KN-M\n\n' +
                ' SECONDARY MOMENT :\n\n' +
                ' BMx_x(s)=Mx_x(s)+FY(s)x|Zc-ZCT|+FZ(s)x |Yc-YCT| =       ' + fmtF((loads.Mx_s || 0) + Math.abs((loads.Fy_s || 0) * Math.abs(Zc_force - sys.cg.z)) + Math.abs((loads.Fz_s || 0) * Math.abs(Yc_force - sys.cg.y)), 4) + ' KN-M\n\n\n' +
                ' DISPLACEMENT :\n\n' +
                ' DY  = Ch (A11 x FY + A12 x BMx_x) + Ch (A11 x FY + A12 x BMx_x) = ' + fmtE4(yxx.Dy || 0) + ' M\n' +
                '                                 p                             s\n\n' +
                ' RXX = Cr (A21 x FY + A22 x BMx_x) + Cr (A21 x FY + A22 x BMx_x) = ' + fmtE4(yxx.Rxx || 0) + ' RAD\n' +
                '                                 p                             s\n\n\n' +
                ' **  COUPLED X-DIR TRANSLATION AND Y-Y ROTATION  **\n\n' +
                '                          ___\n' +
                '               60        / Kh\n' +
                '  Ftrans = ----------   / --- =    ' + fmtF(xyy.Ftrans || 0, 4) + '     (rpm)\n' +
                '           2 x 3.1416 \\/   Mt\n' +
                '                          _____________\n' +
                '               60        / Kr - Wt x h\n' +
                '  Frotat = ----------   / ------------- =    ' + fmtF(xyy.Frotat || 0, 4) + '     (rpm)\n' +
                '          2 x 3.1416 \\/        Ib\n\n' +
                '                       2\n' +
                '  CIRCULAR FREQUENCY  Wtrans  =   ' + fmtF(Wtrans_sq_xyy, 4) + '     (RAD/SEC)**2\n' +
                '                       2\n' +
                '                      Wrotat  =   ' + fmtF(Wrotat_sq_xyy, 4) + '     (RAD/SEC)**2\n\n' +
                '          Wtrans   2\n' +
                '  MU = (----------) =   ' + fmtF(MU_xyy, 7) + '\n' +
                '          Wrotat\n\n' +
                '           It\n' +
                '  GAMA = -------- =   ' + fmtF(GAMA_xyy, 7) + '\n' +
                '           Ib\n\n' +
                '  NATURAL FREQUENCY OF THE COUPLED SYSTEM :\n\n' +
                '         2                 _______________________\n' +
                '   2    Wrotat            /       2\n' +
                '  Wn1 = ------ [1+ MU - \\/(1 + MU) - 4 GAMA x MU ] =    ' + fmtF(Wn1_sq_xyy, 3) + '\n' +
                '        2 GAMA\n\n' +
                '         2                 _______________________\n' +
                '   2    Wrotat            /       2\n' +
                '  Wn2 = ------ [1+ MU + \\/(1 + MU) - 4 GAMA x MU ] =    ' + fmtF(Wn2_sq_xyy, 3) + '\n' +
                '        2 GAMA\n\n' +
                '  Fn1 =    ' + fmtF(xyy.fn1, 4) + '     (RPM)\n\n' +
                '  Fn2 =    ' + fmtF(xyy.fn2, 4) + '     (RPM)\n\n' +
                '  AT PRIMARY FREQUENCY :\n' +
                '  =======================\n' +
                '                                2\n' +
                '  OPERATION CIRCULAR FREQENCY  Wp =    ' + fmtF(w_op_sq, 1) + '\n\n' +
                '  COEFFICIENTS FOR AMPLITUDES :\n\n' +
                '                     2    2      2    2\n' +
                '  DELTA = Mt It ( Wn1 - Wp ) (Wn2 - Wp ) =   ' + fmtE(Delta_xyy) + '\n\n' +
                '                2                       2\n' +
                '        | Kh x h + Kr - Wt x h - It x Wp |\n' +
                '  A11 = ----------------------------------- =  ' + fmtE(A11_xyy) + '\n' +
                '                     DELTA\n\n' +
                '               | Kh x h |\n' +
                '  A12 = A21 = ------------ = ' + fmtE(A12_xyy) + '\n' +
                '                  DELTA\n\n' +
                '                       2\n' +
                '         | Kh - Mt x Wp |\n' +
                '  A22 = ------------------- =  ' + fmtE(A22_xyy) + '\n' +
                '               DELTA\n\n' +
                '  APPROXIMATED DAMPING EFFECT:\n\n' +
                '                     2\n' +
                '             |  1 - r  |\n' +
                '  Ci =  ------------------------ ; (i = h or r)\n' +
                '         ____________________\n' +
                '        /    2 2            2\n' +
                '      \\/ (1-r )   + (2 Di r)\n\n\n' +
                '  FOR TRANSLATION:\n' +
                '          Fp\n' +
                '    r = ----- =    ' + fmtF(r_trans_xyy, 5) + '\n' +
                '         Fn1\n' +
                '    Ch =   ' + fmtF(Ch_xyy, 7) + '\n\n' +
                '  FOR ROTATION:\n' +
                '          Fp\n' +
                '    r = ------ =    ' + fmtF(r_rot_xyy, 5) + '\n' +
                '         Fn2\n' +
                '    Cr =   ' + fmtF(Cr_xyy, 7) + '\n\n' +
                // AT SECONDARY FREQUENCY for X-YY - only for Reciprocating
                (isRecip ? (
                  '  AT SECONDARY FREQUENCY :\n' +
                  '  ========================\n' +
                  '                                2\n' +
                  '  OPERATION CIRCULAR FREQENCY  Wp =    ' + fmtF(w_sec_sq, 1) + '\n\n' +
                  '  COEFFICIENTS FOR AMPLITUDES :\n\n' +
                  '                     2    2      2    2\n' +
                  '  DELTA = Mt It ( Wn1 - Wp ) (Wn2 - Wp ) =   ' + fmtE(Delta_xyy_s) + '\n\n' +
                  '                2                       2\n' +
                  '        | Kh x h + Kr - Wt x h - It x Wp |\n' +
                  '  A11 = ----------------------------------- =  ' + fmtE(A11_xyy_s) + '\n' +
                  '                     DELTA\n\n' +
                  '               | Kh x h |\n' +
                  '  A12 = A21 = ------------ = ' + fmtE(A12_xyy_s) + '\n' +
                  '                  DELTA\n\n' +
                  '                       2\n' +
                  '         | Kh - Mt x Wp |\n' +
                  '  A22 = ------------------- =  ' + fmtE(A22_xyy_s) + '\n' +
                  '               DELTA\n\n' +
                  '  APPROXIMATED DAMPING EFFECT:\n\n' +
                  '                     2\n' +
                  '             |  1 - r  |\n' +
                  '  Ci =  ------------------------ ; (i = h or r)\n' +
                  '         ____________________\n' +
                  '        /    2 2            2\n' +
                  '      \\/ (1-r )   + (2 Di r)\n\n' +
                  '  FOR TRANSLATION:\n' +
                  '          Fp\n' +
                  '    r = ----- =    ' + fmtF(r_trans_xyy_s, 5) + '\n' +
                  '         Fn1\n' +
                  '    Ch =   ' + fmtF(Ch_xyy_s, 7) + '\n\n' +
                  '  FOR ROTATION:\n' +
                  '          Fp\n' +
                  '    r = ------ =    ' + fmtF(r_rot_xyy_s, 5) + '\n' +
                  '         Fn2\n' +
                  '    Cr =   ' + fmtF(Cr_xyy_s, 7) + '\n\n'
                ) : '') +
                '  PRIMARY   HORIZONTAL FORCE FX(p) =   ' + fmtE(Fx) + ' KN\n\n' +
                '  SECONDARY HORIZONTAL FORCE FX(s) =   ' + fmtE(loads.Fx_s || 0) + ' KN\n\n' +
                ' PRIMARY   MOMENT :\n\n' +
                ' BMy_y(p)=My_y(p)+FX(p)x|Zc-ZCT|+FZ(p)x|Xc-XCT| =       ' + fmtF(BMy_y, 4) + ' KN-M\n\n' +
                ' SECONDARY MOMENT :\n\n' +
                ' BMy_y(s)=My_y(s)+FX(s)x|Zc-ZCT|+FZ(s)x|Xc-XCT| =       ' + fmtF((loads.My_s || 0) + Math.abs((loads.Fx_s || 0) * Math.abs(Zc_force - sys.cg.z)) + Math.abs((loads.Fz_s || 0) * Math.abs(Xc_force - sys.cg.x)), 4) + ' KN-M\n\n\n' +
                ' DISPLACEMENT :\n\n' +
                ' DX  = Ch (A11 x FX + A12 x BMy_y) + Ch (A11 x FX + A12 x BMy_y) = ' + fmtE4(xyy.Dx || 0) + ' M\n' +
                '                                 p                             s\n\n' +
                ' RYY = Cr (A21 x FX + A22 x BMy_y) + Cr (A21 x FX + A22 x BMy_y) = ' + fmtE4(xyy.Ryy || 0) + ' RAD\n' +
                '                                 p                             s\n\n\n' +
                ' ** TORSIONAL VIBRATION **\n\n' +
                '  NATURAL FREQUENCY :\n' +
                '                      ___\n' +
                '           60        / K\n' +
                '  Fn = ----------   / --- =    ' + fmtF(tor.fn, 4) + '     (rpm)\n' +
                '       2 x 3.1416 \\/   It\n\n' +
                '  DAMPING RATIO  D =   ' + fmtF(Dt) + '\n\n' +
                '  RESONANT FREQUENCY :\n' +
                '            Fn\n' +
                '  Fr = --------------- =    ' + fmtF(tor.fr, 4) + '     (rpm)\n' +
                '          -----------\n' +
                '         /         2\n' +
                '       \\/ 1 - 2 x D\n\n' +
                '                              Fr\n\n\n' +
                '  AT PRIMARY FREQUENCY :\n' +
                '  ======================\n\n' +
                '                             Fp\n' +
                '  FREQUENCY RATIO    GAMA = ---- =   ' + fmtF(tor.gamma, 6) + '\n' +
                '                             Fn\n\n' +
                '  MAGNIFICATION FACTOR :\n' +
                '                    1\n' +
                '  MF = -------------------------- =   ' + fmtE(tor.DMF) + ' ... EQ.(1)\n' +
                '          ----------------------\n' +
                '         /      2  2           2\n' +
                '       \\/(1-GAMA  ) + (2DxGAMA)\n\n' +
                // AT SECONDARY FREQUENCY for Torsion - only for Reciprocating
                (isRecip ? (
                  '\n  AT SECONDARY FREQUENCY :\n' +
                  '  ========================\n\n' +
                  '                             Fs\n' +
                  '  FREQUENCY RATIO    GAMA = ---- =    ' + fmtF(tor.gamma_s, 6) + '\n' +
                  '                             Fn\n\n' +
                  '  BY EQ.(1) MAGNIFICATION FACTOR    MF(s)  =   ' + fmtE(tor.DMF_s) + '\n\n'
                ) : '') +
                '\n  PRIMARY   TORSIONAL MOMENT \n\n' +
                '  TMz_z(p) = Mz_z(p)+FX(p)x|Yc-YCT|+FY(p)x|Xc-XCT| =       ' + fmtF(loads.Mz || 0, 4) + ' KN-M\n\n' +
                '  SECONDARY TORSIONAL MOMENT \n\n' +
                '  TMz_z(s) = Mz_z(s)+FX(s)x|Yc-YCT|+FY(s)x|Xc-XCT| =       ' + fmtF((loads.Mz_s || 0) + Math.abs((loads.Fx_s || 0) * Math.abs(Yc_force - sys.cg.y)) + Math.abs((loads.Fy_s || 0) * Math.abs(Xc_force - sys.cg.x)), 4) + ' KN-M\n\n\n' +
                '  DISPLACEMENT :\n\n' +
                '        MF(p) x TMz_z(p) + MF(s) x TMz_z(s)\n' +
                '  RZZ = ----------------------------------- =   ' + fmtE(tor.Rzz || 0) + ' RAD\n' +
                '                       Kz_z\n\n\n' +
                ' ***********************************************************\n' +
                ' *  DISPLACEMENT ON CENTER OF CONCENTRATED MASS OF MACHINE *\n' +
                ' ***********************************************************\n\n' +
                '  THE FOLLOWING DISPLACEMENT SHOULD BE MULTIPLIED BY 2 TO GET TOTAL AMOUNT\n\n' +
                '  VERTICAL = | DZ | + |RXX (Ycm - YCT)| + |RYY (Xcm - XCT)|\n\n' +
                '  X-DIR    = | DX | + |RYY (Zcm - ZCT)| + |RZZ (Ycm - YCT)|\n\n' +
                '  Y-DIR    = | DY | + |RXX (Zcm - ZCT)| + |RZZ (Xcm - XCT)|\n\n\n' +
                '  CONCENTRATED   XCM-XCT   YCM-YCT   ZCM-ZCT    VERTICAL       X-DIR       Y-DIR\n' +
                '   MASS   ID         (M)       (M)       (M)         (M)         (M)         (M)\n' +
                ' -------------------------------------------------------------------------------\n' +
                machDisps + '\n' +
                ' ===============================================================================\n\n' +
                ' ** MAX HORIZONTAL DISPLACEMENT = ' + fmtE4(maxMachHoriz) + ' M\n\n' +
                ' ** MAX VERTICAL   DISPLACEMENT = ' + fmtE4(maxMachVert) + ' M\n\n\n\n' +
                ' ***************************************\n' +
                ' *   DISPLACEMENTS AT SELECTED POINTS  *\n' +
                ' ***************************************\n\n' +
                '  THE FOLLOWING DISPLACEMENT SHOULD BE MULTIPLIED BY 2 TO GET TOTAL AMOUNT\n\n' +
                '  VERTICAL = | DZ | + |RXX (Y - YCT)| + |RYY (X - XCT)|\n\n' +
                '  X-DIR    = | DX | + |RZZ (Y - YCT)| + |RYY (Z - ZCT)|\n\n' +
                '  Y-DIR    = | DY | + |RZZ (X - XCT)| + |RXX (Z - ZCT)|\n\n\n' +
                '  NODE   X-XCT   Y-YCT    Z-ZCT   VERTICAL       X-DIR      Y-DIR\n' +
                '   ID      (M)     (M)      (M)       (M)          (M)        (M)\n' +
                ' ----------------------------------------------------------------------\n' +
                pts.map(pt => '  ' + (pt.name || 'Pt').padEnd(6) + ' ' + fmtF(pt.dx, 3).padStart(7) + ' ' + fmtF(pt.dy, 3).padStart(7) + '  ' + fmtF(pt.dz, 3).padStart(7) + '  ' + fmtE4(pt.dispZ) + '  ' + fmtE4(pt.dispX) + '  ' + fmtE4(pt.dispY)).join('\n') + '\n' +
                ' ======================================================================\n\n' +
                ' ** MAX HORIZONTAL DISPLACEMENT = ' + fmtE4(Math.max(...pts.map(pt => Math.max(pt.dispX || 0, pt.dispY || 0)))) + ' M\n\n' +
                ' ** MAX VERTICAL   DISPLACEMENT = ' + fmtE4(Math.max(...pts.map(pt => pt.dispZ || 0))) + ' M\n\n' +
                '</div></div>';
            }
            container.innerHTML = html;
            // Draw graphs if on graphs tab
            if (this.currentResTab === 'graphs' && this.sweepData) {
              this.drawAllCharts();
            }
          },
          sweepData: null,
          selectedSweepNode: 0,
          runFrequencySweep() {
            // === VALIDATION GATE ===
            const auditResult = App.Audit.run();
            if (auditResult.errors.length > 0) {
              App.UI.showCanvasMsg('⚠️ Model has errors! Fix before running.');
              alert('Analysis blocked due to model errors:\n\n' + auditResult.errors.join('\n'));
              return;
            }

            const start = parseFloat(document.getElementById('cal-freqStart')?.value || 0);
            const end = parseFloat(document.getElementById('cal-freqEnd')?.value || 12000);
            const step = parseFloat(document.getElementById('cal-freqStep')?.value || 100);
            if (step <= 0) { App.UI.showCanvasMsg('Invalid step'); return; }

            const sys = App.Physics.calcSystem(App.State.blocks, App.State.machines, App.State.params);
            const stiff = App.Physics.calcStiffness(App.State.piles, sys.cg);
            const baseLoads = this.getAggregatedLoads();
            const f_op = baseLoads.freq || 1; // Avoid division by zero
            const isCentrifugal = (App.State.projectInfo?.machineType || 'C') === 'C';

            const data = [];
            for (let f = start; f <= end; f += step) {
              // Centrifugal machines: Force ~ freq^2. Others: constant force.
              const scale = isCentrifugal && f_op > 0 ? (f / f_op) ** 2 : 1;
              const loads = {
                freq: f,
                Fx: baseLoads.Fx * scale,
                Fy: baseLoads.Fy * scale,
                Fz: baseLoads.Fz * scale,
                Mx: baseLoads.Mx * scale,
                My: baseLoads.My * scale,
                Mz: baseLoads.Mz * scale,
                X: baseLoads.X, Y: baseLoads.Y, Z: baseLoads.Z // CG unchanged
              };
              const result = App.Physics.solve(sys, stiff, loads, App.State.params);
              data.push({
                freq: f,
                ampZ: result.vertical?.amp || 0,
                nodeDisp: result.pointResults || []
              });
            }
            this.sweepData = data;
            this.renderResults();
            App.Renderer.draw(); // Trigger redraw for highlight
            App.UI.showCanvasMsg(`Sweep: ${data.length} points (${isCentrifugal ? 'Centrifugal' : 'Constant Force'})`);
            // Update status badge to reflect calculated state
            const badge = document.getElementById('res-status-badge');
            if (badge && data.length > 0) {
              badge.innerText = '✓ Calculated';
              badge.className = 'text-[10px] bg-green-100 text-green-700 px-2 py-0.5 rounded-full font-bold';
            }
          },
          selectedSweepDir: 'Z',
          // Helper: Get directional displacement from node array
          _getDirectionalDisp(nodeArr, selIdx, dir) {
            if (!nodeArr || nodeArr.length === 0) return 0;
            if (selIdx === 'ALL') {
              // For table, return max across all nodes
              let maxVal = 0;
              nodeArr.forEach(n => {
                const val = dir === 'Z' ? (n.dispZ || 0) :
                  dir === 'X' ? (n.dispX || 0) :
                    dir === 'Y' ? (n.dispY || 0) :
                      Math.sqrt((n.dispX || 0) ** 2 + (n.dispY || 0) ** 2 + (n.dispZ || 0) ** 2);
                if (val > maxVal) maxVal = val;
              });
              return maxVal;
            }
            const node = nodeArr[selIdx];
            if (!node) return 0;
            if (dir === 'Z') return node.dispZ || 0;
            if (dir === 'X') return node.dispX || 0;
            if (dir === 'Y') return node.dispY || 0;
            return Math.sqrt((node.dispX || 0) ** 2 + (node.dispY || 0) ** 2 + (node.dispZ || 0) ** 2);
          },
          // Helper: Generate nice axis ticks
          _getNiceTicks(max, count = 5) {
            if (max <= 0) return [0];
            const rawStep = max / count;
            const mag = Math.pow(10, Math.floor(Math.log10(rawStep)));
            const niceSteps = [1, 2, 2.5, 5, 10];
            let step = mag;
            for (const ns of niceSteps) {
              if (mag * ns >= rawStep) { step = mag * ns; break; }
            }
            const ticks = [];
            for (let v = 0; v <= max * 1.1; v += step) ticks.push(v);
            return ticks;
          },
          drawAllCharts() {
            if (!this.sweepData || this.sweepData.length === 0) return;
            let data = this.sweepData;
            const selIdx = this.selectedSweepNode;
            const dir = this.selectedSweepDir || 'Z';
            const fullMaxFreq = Math.max(...data.map(d => d.freq)) || 1;
            const opFreq = App.State.loadsConfig?.freq || 0;

            // Get all Fn values from results
            const res = this.lastResults?.result || {};
            const fnZ = res.fn_z || 0;
            const yxx = res.coupled_YXX || {};
            const xyy = res.coupled_XYY || {};

            // Build Fn lines array based on direction
            let fnLines = [];
            if (dir === 'Z') {
              if (fnZ > 0) fnLines.push({ freq: fnZ, label: 'Fnz', color: '#ea580c' });
            } else if (dir === 'X') {
              if (xyy.fn1 > 0) fnLines.push({ freq: xyy.fn1, label: 'Fn1', color: '#ea580c' });
              if (xyy.fn2 > 0) fnLines.push({ freq: xyy.fn2, label: 'Fn2', color: '#f97316' });
            } else if (dir === 'Y') {
              if (yxx.fn1 > 0) fnLines.push({ freq: yxx.fn1, label: 'Fn1', color: '#ea580c' });
              if (yxx.fn2 > 0) fnLines.push({ freq: yxx.fn2, label: 'Fn2', color: '#f97316' });
            } else if (dir === 'R') {
              // Resultant: show all Fn lines
              if (fnZ > 0) fnLines.push({ freq: fnZ, label: 'Fnz', color: '#ea580c' });
              if (yxx.fn1 > 0) fnLines.push({ freq: yxx.fn1, label: 'FnY1', color: '#f97316' });
              if (yxx.fn2 > 0) fnLines.push({ freq: yxx.fn2, label: 'FnY2', color: '#fb923c' });
              if (xyy.fn1 > 0) fnLines.push({ freq: xyy.fn1, label: 'FnX1', color: '#0ea5e9' });
              if (xyy.fn2 > 0) fnLines.push({ freq: xyy.fn2, label: 'FnX2', color: '#38bdf8' });
            }

            // Apply zoom filter if set
            const zoomMin = this.chartZoom?.minFreq ?? 0;
            const zoomMax = this.chartZoom?.maxFreq ?? fullMaxFreq;
            const filteredData = data.filter(d => d.freq >= zoomMin && d.freq <= zoomMax);
            if (filteredData.length === 0) filteredData.push(data[0]); // Fallback

            const nodeCount = filteredData[0]?.nodeDisp?.length || 1;
            const isAllMode = selIdx === 'ALL';

            // Prepare data arrays (either single node or envelope for ALL)
            let dispVals, velVals, accVals;
            let allNodeData = []; // For multi-node lines in ALL mode

            if (isAllMode) {
              // For ALL mode: calculate per-node lines and envelope
              for (let ni = 0; ni < nodeCount; ni++) {
                const nodeDisps = filteredData.map(d => this._getDirectionalDisp(d.nodeDisp, ni, dir) * 1e6);
                const nodeVels = filteredData.map((d, i) => {
                  const omega = (d.freq / 60) * 2 * Math.PI;
                  return nodeDisps[i] * omega / 1000;
                });
                const nodeAccs = filteredData.map((d, i) => {
                  const omega = (d.freq / 60) * 2 * Math.PI;
                  return nodeDisps[i] * omega * omega / 1e6;
                });
                allNodeData.push({ disps: nodeDisps, vels: nodeVels, accs: nodeAccs });
              }
              // Envelope (max across all nodes at each freq step)
              dispVals = filteredData.map((_, i) => Math.max(...allNodeData.map(nd => nd.disps[i])));
              velVals = filteredData.map((_, i) => Math.max(...allNodeData.map(nd => nd.vels[i])));
              accVals = filteredData.map((_, i) => Math.max(...allNodeData.map(nd => nd.accs[i])));
            } else {
              dispVals = filteredData.map(d => this._getDirectionalDisp(d.nodeDisp, selIdx, dir) * 1e6);
              velVals = filteredData.map((d, i) => {
                const omega = (d.freq / 60) * 2 * Math.PI;
                return dispVals[i] * omega / 1000;
              });
              accVals = filteredData.map((d, i) => {
                const omega = (d.freq / 60) * 2 * Math.PI;
                return dispVals[i] * omega * omega / 1e6;
              });
            }

            // Draw each chart with limit lines (only if showLimits enabled)
            const limits = App.State.params.limits || {};
            const showLimits = this.showLimits !== false;
            const pct = this.peakZonePercent || 0;
            const peakZone = pct > 0 && opFreq > 0 ? [opFreq * (1 - pct / 100), opFreq * (1 + pct / 100)] : null;
            this._drawChart('chart-disp', filteredData, dispVals, 'μm', '#6366f1', zoomMax, opFreq, fnLines, isAllMode ? allNodeData.map(nd => nd.disps) : null, zoomMin, showLimits ? limits.displacement : null, peakZone);
            this._drawChart('chart-vel', filteredData, velVals, 'mm/s', '#22c55e', zoomMax, opFreq, fnLines, isAllMode ? allNodeData.map(nd => nd.vels) : null, zoomMin, showLimits ? limits.velocity : null, peakZone);
            this._drawChart('chart-acc', filteredData, accVals, 'm/s²', '#ef4444', zoomMax, opFreq, fnLines, isAllMode ? allNodeData.map(nd => nd.accs) : null, zoomMin, showLimits ? limits.acceleration : null, peakZone);
          },
          // Update charts only (no HTML rebuild, prevents focus loss)
          updateChartsOnly() {
            if (this.currentResTab === 'graphs' && this.sweepData && this.sweepData.length > 0) {
              this.drawAllCharts();
              // Update 3D marker position
              App.Renderer.draw();
              // Update sweep table content (if exists)
              this._updateSweepTable();
            }
          },
          // Helper to update sweep table without full re-render
          _updateSweepTable() {
            const tbody = document.querySelector('#res-content table tbody');
            if (!tbody || !this.sweepData) return;
            const selIdx = this.selectedSweepNode;
            const dir = this.selectedSweepDir || 'Z';
            tbody.innerHTML = this.sweepData.map(d => {
              const disp = this._getDirectionalDisp(d.nodeDisp, selIdx, dir) * 1e6;
              const omega = (d.freq / 60) * 2 * Math.PI;
              const vel = disp * omega / 1000;
              const acc = disp * omega * omega / 1e6;
              const fmtVal = (v) => Math.abs(v) < 0.001 && v !== 0 ? v.toExponential(2) : v.toFixed(4);
              return `<tr class="border-b"><td class="p-1 text-center">${d.freq}</td><td class="p-1 text-right">${fmtVal(disp)}</td><td class="p-1 text-right">${fmtVal(vel)}</td><td class="p-1 text-right">${fmtVal(acc)}</td></tr>`;
            }).join('');
          },
          peakZonePercent: 0, // Percentage for peak zone (0 = disabled)
          showLimits: true, // Flag for showing limit lines on charts
          _drawChart(canvasId, data, vals, unit, color, maxFreq, opFreq, fnLines, allNodeLines = null, minFreq = 0, limitValue = null, peakZone = null) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const c = ctx; // Alias

            // Handle high-DPI displays for sharp rendering
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const w = rect.width, h = rect.height;
            const padL = 38, padB = 18, padT = 8, padR = 5;
            const plotW = w - padL - padR;
            const plotH = h - padT - padB;
            const freqRange = maxFreq - minFreq || 1;

            // Calculate max values across all lines for consistent scale - PRIORITIZE PEAK
            let maxVal = Math.max(...vals) || 1;
            if (allNodeLines) {
              allNodeLines.forEach(line => {
                const lineMax = Math.max(...line);
                if (lineMax > maxVal) maxVal = lineMax;
              });
            }
            // Only include limit in scale if it's within 2x of peak (otherwise chart becomes flat)
            // If limit is much higher, scale to 2x peak and draw limit at top edge
            const limitInScale = limitValue && limitValue <= maxVal * 2;
            if (limitInScale) {
              maxVal = Math.max(maxVal, limitValue * 1.05);
            } else if (limitValue) {
              // Limit is too high, scale chart to show at least 2x peak for perspective
              maxVal = maxVal * 2;
            }
            maxVal = maxVal * 1.05; // 5% padding

            ctx.clearRect(0, 0, w, h);

            // Helper for smart number formatting (scientific for tiny numbers)
            const fmtNum = (v) => {
              if (v === 0) return '0';
              if (Math.abs(v) < 0.001) return v.toExponential(2);
              if (Math.abs(v) < 1) return v.toFixed(4);
              return v.toFixed(2);
            };

            // Adaptive Y-axis ticks
            const yTicks = this._getNiceTicks(maxVal, 4);
            c.strokeStyle = '#e2e8f0'; c.lineWidth = 0.5;
            c.fillStyle = '#94a3b8'; c.font = 'bold 9px sans-serif'; c.textAlign = 'right';
            yTicks.forEach(tickVal => {
              if (tickVal > maxVal) return;
              const y = padT + plotH - (tickVal / maxVal) * plotH;
              c.beginPath(); c.moveTo(padL, y); c.lineTo(w - padR, y); c.stroke();
              c.fillText(fmtNum(tickVal), padL - 3, y + 3);
            });

            // Adaptive X-axis ticks
            const xTicks = this._getNiceTicks(freqRange, 5);
            c.textAlign = 'center';
            xTicks.forEach(tickVal => {
              const absFreq = minFreq + tickVal;
              if (absFreq > maxFreq) return;
              const x = padL + (tickVal / freqRange) * plotW;
              c.beginPath(); c.moveTo(x, padT); c.lineTo(x, h - padB); c.stroke();
              c.fillText(absFreq.toFixed(0), x, h - 4);
            });

            // Axes
            c.strokeStyle = '#64748b'; c.lineWidth = 1;
            c.beginPath(); c.moveTo(padL, padT); c.lineTo(padL, h - padB); c.lineTo(w - padR, h - padB); c.stroke();

            // Unit label
            c.fillStyle = '#475569'; c.font = 'bold 7px sans-serif'; c.textAlign = 'left';
            c.fillText(unit, 2, padT + 8);

            // Helper to map (freq, val) to pixel coords (zoom-aware)
            const toX = (freq) => padL + ((freq - minFreq) / freqRange) * plotW;
            const toY = (val) => padT + plotH - (val / maxVal) * plotH;

            // Peak Zone visual indicator (light cyan fill + red dashed borders)
            if (peakZone && peakZone[0] >= minFreq && peakZone[1] <= maxFreq) {
              const xLow = toX(peakZone[0]);
              const xHigh = toX(peakZone[1]);
              // Light cyan fill
              c.fillStyle = 'rgba(6, 182, 212, 0.1)'; // cyan-500 at 10% opacity
              c.fillRect(xLow, padT, xHigh - xLow, plotH);
              // Thin red dashed borders
              c.strokeStyle = '#ef4444'; c.lineWidth = 1; c.setLineDash([3, 3]);
              c.beginPath(); c.moveTo(xLow, padT); c.lineTo(xLow, h - padB); c.stroke();
              c.beginPath(); c.moveTo(xHigh, padT); c.lineTo(xHigh, h - padB); c.stroke();
              c.setLineDash([]);
            }

            // Draw all node lines (faint) if in ALL mode
            if (allNodeLines && allNodeLines.length > 0) {
              c.globalAlpha = 0.25;
              c.strokeStyle = '#9ca3af'; c.lineWidth = 0.8;
              allNodeLines.forEach(line => {
                c.beginPath();
                data.forEach((d, i) => {
                  const x = toX(d.freq);
                  const y = toY(line[i]);
                  if (i === 0) c.moveTo(x, y); else c.lineTo(x, y);
                });
                c.stroke();
              });
              c.globalAlpha = 1.0;
            }

            // Draw main curve (envelope or single node)
            c.strokeStyle = color; c.lineWidth = allNodeLines ? 3 : 2;
            c.beginPath();
            let peakX = 0, peakY = h, peakVal = 0, peakFreq = 0;
            data.forEach((d, i) => {
              const val = vals[i];
              const x = toX(d.freq);
              const y = toY(val);
              if (i === 0) c.moveTo(x, y); else c.lineTo(x, y);
              // Peak detection (with optional zone restriction)
              const inZone = !peakZone || (d.freq >= peakZone[0] && d.freq <= peakZone[1]);
              if (inZone && val > peakVal) { peakVal = val; peakX = x; peakY = y; peakFreq = d.freq; }
            });
            c.stroke();

            // Peak marker with smart positioning
            if (peakVal > 0) {
              c.fillStyle = '#dc2626';
              c.beginPath(); c.arc(peakX, peakY, 3, 0, 2 * Math.PI); c.fill();
              c.font = 'bold 9px sans-serif';
              const peakText = `Peak: ${fmtNum(peakVal)} @ ${peakFreq.toFixed(0)} RPM`;
              const textW = c.measureText(peakText).width;
              // Right-align if peak is in right half of chart
              if (peakX > w / 2) {
                c.textAlign = 'right';
                c.fillText(peakText, peakX - 5, peakY - 3);
              } else {
                c.textAlign = 'left';
                c.fillText(peakText, peakX + 5, peakY - 3);
              }
            }

            // Op frequency line (green dashed)
            if (opFreq > 0 && opFreq <= maxFreq) {
              const xOp = toX(opFreq);
              c.strokeStyle = '#16a34a'; c.lineWidth = 1.5; c.setLineDash([4, 3]);
              c.beginPath(); c.moveTo(xOp, padT); c.lineTo(xOp, h - padB); c.stroke();
              c.setLineDash([]);
              c.fillStyle = '#16a34a'; c.font = '9px sans-serif'; c.textAlign = 'left';
              c.fillText(`Op: ${opFreq}`, xOp + 2, padT + 10);
            }

            // Fn lines (multiple, direction-specific)
            if (fnLines && fnLines.length > 0) {
              let labelOffset = 10;
              fnLines.forEach((fnLine, idx) => {
                if (fnLine.freq > 0 && fnLine.freq <= maxFreq && fnLine.freq >= minFreq) {
                  const xFn = toX(fnLine.freq);
                  c.strokeStyle = fnLine.color || '#ea580c'; c.lineWidth = 1.5; c.setLineDash([4, 3]);
                  c.beginPath(); c.moveTo(xFn, padT); c.lineTo(xFn, h - padB); c.stroke();
                  c.setLineDash([]);
                  c.fillStyle = fnLine.color || '#ea580c'; c.font = '8px sans-serif'; c.textAlign = 'right';
                  c.fillText(`${fnLine.label}: ${fnLine.freq.toFixed(0)}`, xFn - 2, padT + labelOffset);
                  labelOffset += 10; // Stagger labels vertically
                }
              });
            }

            // Limit line (horizontal red dashed)
            if (limitValue !== null && limitValue > 0) {
              if (limitValue <= maxVal) {
                // Limit is within scale - draw at actual position
                const yLimit = toY(limitValue);
                c.strokeStyle = '#dc2626'; c.lineWidth = 1.5; c.setLineDash([6, 4]);
                c.beginPath(); c.moveTo(padL, yLimit); c.lineTo(w - padR, yLimit); c.stroke();
                c.setLineDash([]);
                c.fillStyle = '#dc2626'; c.font = 'bold 8px sans-serif'; c.textAlign = 'right';
                c.fillText(`Limit: ${fmtNum(limitValue)}`, w - padR - 2, yLimit - 3);
              } else {
                // Limit is off-scale (too high) - draw at top edge with ↑ indicator
                c.strokeStyle = '#dc2626'; c.lineWidth = 1.5; c.setLineDash([6, 4]);
                c.beginPath(); c.moveTo(padL, padT + 2); c.lineTo(w - padR, padT + 2); c.stroke();
                c.setLineDash([]);
                c.fillStyle = '#dc2626'; c.font = 'bold 8px sans-serif'; c.textAlign = 'right';
                c.fillText(`↑ Limit: ${fmtNum(limitValue)} (off-scale)`, w - padR - 2, padT + 12);
              }
            }

            // Store chart metadata for hover
            if (!this._chartMeta) this._chartMeta = {};
            this._chartMeta[canvasId] = { maxFreq, maxVal, vals, data, unit, plotW, plotH, padL, padT };
          },
          _chartMeta: {},
          // Chart zoom state
          chartZoom: null, // { minFreq, maxFreq } or null for full range
          chartDrag: { active: false, startX: 0, startFreq: 0 },
          chartPan: { active: false, startX: 0, startMin: 0, startMax: 0 },
          handleChartHover(e) {
            if (!this.sweepData || this.sweepData.length === 0) return;
            const container = document.getElementById('charts-container');
            const crosshair = document.getElementById('chart-crosshair');
            const tooltip = document.getElementById('chart-tooltip');
            if (!container || !crosshair || !tooltip) return;

            // Handle middle-button panning
            if (this.chartPan.active) {
              const meta = this._chartMeta['chart-disp'];
              if (!meta) return;
              const fullMaxFreq = Math.max(...this.sweepData.map(d => d.freq)) || 12000;
              const dx = e.clientX - this.chartPan.startX;
              const freqDelta = -dx / meta.plotW * (this.chartPan.startMax - this.chartPan.startMin);
              let newMin = this.chartPan.startMin + freqDelta;
              let newMax = this.chartPan.startMax + freqDelta;
              // Clamp
              if (newMin < 0) { newMax -= newMin; newMin = 0; }
              if (newMax > fullMaxFreq) { newMin -= (newMax - fullMaxFreq); newMax = fullMaxFreq; }
              newMin = Math.max(0, newMin);
              newMax = Math.min(fullMaxFreq, newMax);
              if (newMax > newMin) {
                this.chartZoom = { minFreq: newMin, maxFreq: newMax };
                this.drawAllCharts();
              }
              return;
            }

            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;

            // Get first canvas for reference
            const canvas = document.getElementById('chart-disp');
            if (!canvas) return;
            const canvasRect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - canvasRect.left;
            const meta = this._chartMeta['chart-disp'];
            if (!meta) return;

            // Check if within chart area
            if (canvasX < meta.padL || canvasX > canvasRect.width - 5) {
              crosshair.classList.add('hidden');
              tooltip.classList.add('hidden');
              return;
            }

            // Calculate frequency from x position using zoom-aware range
            const zoomMin = this.chartZoom?.minFreq ?? 0;
            const zoomMax = this.chartZoom?.maxFreq ?? meta.maxFreq;
            const freq = zoomMin + ((canvasX - meta.padL) / meta.plotW) * (zoomMax - zoomMin);

            // Find closest data point
            const data = this.sweepData;
            let closest = data[0], minDist = Infinity;
            data.forEach(d => { const dist = Math.abs(d.freq - freq); if (dist < minDist) { minDist = dist; closest = d; } });

            // Get values for selected node using proper directional helper
            const selIdx = this.selectedSweepNode;
            const dir = this.selectedSweepDir || 'Z';
            const disp = this._getDirectionalDisp(closest.nodeDisp, selIdx, dir) * 1e6;
            const omega = (closest.freq / 60) * 2 * Math.PI;
            const vel = disp * omega / 1000;
            const acc = disp * omega * omega / 1e6;

            // Handle drag selection highlight
            if (this.chartDrag.active) {
              const dragBox = document.getElementById('chart-drag-box');
              if (dragBox) {
                const left = Math.min(this.chartDrag.startX, x);
                const width = Math.abs(x - this.chartDrag.startX);
                dragBox.style.left = left + 'px';
                dragBox.style.width = width + 'px';
                dragBox.classList.remove('hidden');
              }
            }

            // Position crosshair
            crosshair.style.left = x + 'px';
            crosshair.classList.remove('hidden');

            // Position tooltip with direction label and smart number formatting
            const fmtVal = (v) => Math.abs(v) < 0.001 && v !== 0 ? v.toExponential(2) : v.toFixed(4);
            const dirLabel = dir === 'Z' ? 'Vertical' : dir === 'X' ? 'Horiz-X' : dir === 'Y' ? 'Horiz-Y' : 'Resultant';
            const nodeLabel = selIdx === 'ALL' ? 'Envelope' : (closest.nodeDisp?.[selIdx]?.name || `Node ${selIdx}`);
            tooltip.innerHTML = `<b>${closest.freq.toFixed(0)} RPM</b> (${(closest.freq / 60).toFixed(2)}Hz)<br><span class="text-slate-400">${nodeLabel} | ${dirLabel}</span><br>D: ${fmtVal(disp)} μm<br>V: ${fmtVal(vel)} mm/s<br>A: ${fmtVal(acc)} m/s²`;
            tooltip.style.left = (x + 10) + 'px';
            tooltip.style.top = '10px';
            tooltip.classList.remove('hidden');
          },
          handleChartMouseDown(e) {
            const container = document.getElementById('charts-container');
            if (!container) return;
            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const meta = this._chartMeta['chart-disp'];
            if (!meta) return;

            const zoomMin = this.chartZoom?.minFreq ?? 0;
            const zoomMax = this.chartZoom?.maxFreq ?? meta.maxFreq;
            const freq = zoomMin + ((x - meta.padL) / meta.plotW) * (zoomMax - zoomMin);

            if (e.button === 1) {
              // Middle button: start panning
              e.preventDefault();
              this.chartPan = { active: true, startX: e.clientX, startMin: zoomMin, startMax: zoomMax };
            } else if (e.button === 0) {
              // Left button: zoom selection
              this.chartDrag = { active: true, startX: x, startFreq: freq };
            }
          },
          handleChartMouseUp(e) {
            // Always reset pan state on any mouse up
            this.chartPan.active = false;
            if (!this.chartDrag.active) return;
            const container = document.getElementById('charts-container');
            if (!container) return;
            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const meta = this._chartMeta['chart-disp'];
            if (!meta) return;

            const zoomMin = this.chartZoom?.minFreq ?? 0;
            const zoomMax = this.chartZoom?.maxFreq ?? meta.maxFreq;
            const endFreq = zoomMin + ((x - meta.padL) / meta.plotW) * (zoomMax - zoomMin);

            // Check if drag distance is significant (> 20px)
            if (Math.abs(x - this.chartDrag.startX) > 20) {
              const minFreq = Math.max(0, Math.min(this.chartDrag.startFreq, endFreq));
              const maxFreq = Math.max(this.chartDrag.startFreq, endFreq);
              this.chartZoom = { minFreq, maxFreq };
              this.drawAllCharts();
            }

            this.chartDrag.active = false;
            this.chartPan.active = false;
            const dragBox = document.getElementById('chart-drag-box');
            if (dragBox) dragBox.classList.add('hidden');
          },
          handleChartDoubleClick() {
            // Reset zoom
            this.chartZoom = null;
            this.drawAllCharts();
          },
          handleChartWheel(e) {
            // Disabled - allow normal page scrolling
            // (Chart panning via scroll was removed per user request)
          },
          hideChartCrosshair() {
            const crosshair = document.getElementById('chart-crosshair');
            const tooltip = document.getElementById('chart-tooltip');
            const dragBox = document.getElementById('chart-drag-box');
            if (crosshair) crosshair.classList.add('hidden');
            if (tooltip) tooltip.classList.add('hidden');
            if (dragBox) dragBox.classList.add('hidden');
            if (this.chartDrag.active) {
              this.chartDrag.active = false;
            }
          },
          openCalSettings() {
            // Populate from current params
            document.getElementById('cal-dampZ').value = App.State.params.dampingZ || 0.25;
            document.getElementById('cal-dampX').value = App.State.params.dampingX || 0.25;
            document.getElementById('cal-dampRock').value = App.State.params.dampingRock || 0.25;
            document.getElementById('cal-dampTor').value = App.State.params.dampingTor || 0.25;
            document.getElementById('calSettingsPopup').classList.remove('hidden');
          },
          applyCalSettings() {
            App.State.params.dampingZ = parseFloat(document.getElementById('cal-dampZ').value) || 0.25;
            App.State.params.dampingX = parseFloat(document.getElementById('cal-dampX').value) || 0.25;
            App.State.params.dampingRock = parseFloat(document.getElementById('cal-dampRock').value) || 0.25;
            App.State.params.dampingTor = parseFloat(document.getElementById('cal-dampTor').value) || 0.25;
            document.getElementById('calSettingsPopup').classList.add('hidden');
            // Run sweep with new settings and switch to graphs tab
            this.runFrequencySweep();
            this.switchResTab('graphs');
            this.renderResults();
          },
          // === CHECK SETTINGS POPUP ===
          openCheckSettings() {
            const params = App.State.params;
            const $ = id => document.getElementById(id);
            // Populate from state
            $('check-iso-class').value = params.isoClass || 'II';
            $('check-iso-vel').value = params.limits?.velocity || 4.5;
            $('check-iso-disp').value = params.limits?.displacement || 25;
            $('check-iso-acc').value = params.limits?.acceleration || 0.5;
            $('check-din-zone').value = params.dinZonePercent || 20;
            $('check-din-2x').checked = params.din2xHarmonic || false;
            $('check-aci-mass').value = params.massRatioMin || 3;
            $('check-aci-ecc').value = params.eccentricityLimit || 5;
            $('check-pile-comp').value = params.pileCapacity?.compression || 2500;
            $('check-pile-tens').value = params.pileCapacity?.tension || 500;
            $('check-pile-lat').value = params.pileCapacity?.lateral || 100;
            $('checkSettingsPopup').classList.remove('hidden');
          },
          applyCheckSettings() {
            const $ = id => document.getElementById(id);
            const params = App.State.params;
            // ISO 10816
            params.isoClass = $('check-iso-class').value;
            params.limits = {
              velocity: parseFloat($('check-iso-vel').value) || 4.5,
              displacement: parseFloat($('check-iso-disp').value) || 25,
              acceleration: parseFloat($('check-iso-acc').value) || 0.5
            };
            // DIN 4024
            params.dinZonePercent = parseFloat($('check-din-zone').value) || 20;
            params.din2xHarmonic = $('check-din-2x').checked;
            // ACI 351.3R
            params.massRatioMin = parseFloat($('check-aci-mass').value) || 3;
            params.eccentricityLimit = parseFloat($('check-aci-ecc').value) || 5;
            // Pile Capacity
            params.pileCapacity = {
              compression: parseFloat($('check-pile-comp').value) || 2500,
              tension: parseFloat($('check-pile-tens').value) || 500,
              lateral: parseFloat($('check-pile-lat').value) || 100
            };
            // Sync Piles tab inputs
            if (document.getElementById('pile-cap-comp')) {
              document.getElementById('pile-cap-comp').value = params.pileCapacity.compression;
              document.getElementById('pile-cap-tens').value = params.pileCapacity.tension;
              document.getElementById('pile-cap-lat').value = params.pileCapacity.lateral;
            }
            $('checkSettingsPopup').classList.add('hidden');
            App.State.notify();
            App.UI.showCanvasMsg('Check settings saved!');
          },
          exportReport() {
            // Export full WCVL-format report as .LIS file
            const container = document.getElementById('report-text-container');
            if (!container) {
              // Switch to report tab first to generate report
              this.switchResTab('report');
              setTimeout(() => this.exportReport(), 100);
              return;
            }
            const text = container.innerText || container.textContent;
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const jobName = App.State.projectInfo?.jobName || document.getElementById('header-jobName')?.value || 'report';
            // Sanitize filename
            const safeName = jobName.replace(/[\\/:*?"<>|]/g, '_');
            a.download = safeName + '.LIS';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            App.UI.showCanvasMsg('Exported to .LIS');
          },
          copyReportToClipboard() {
            // Auto-copy report content to clipboard
            const container = document.getElementById('report-text-container');
            if (!container) {
              // Switch to report tab first if not already there
              this.switchResTab('report');
              setTimeout(() => this.copyReportToClipboard(), 100);
              return;
            }
            const text = container.innerText || container.textContent;
            navigator.clipboard.writeText(text).then(() => {
              App.UI.showCanvasMsg('Copied to clipboard!');
            }).catch(err => {
              // Fallback for older browsers
              const range = document.createRange();
              range.selectNodeContents(container);
              const sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
              document.execCommand('copy');
              sel.removeAllRanges();
              App.UI.showCanvasMsg('Copied to clipboard!');
            });
          },
          showCanvasMsg(msg, duration = 2000) {
            // Display temporary message on canvas overlay
            let overlay = document.getElementById('canvas-msg-overlay');
            if (!overlay) {
              overlay = document.createElement('div');
              overlay.id = 'canvas-msg-overlay';
              overlay.className = 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-black/70 text-white px-4 py-2 rounded-lg text-sm font-bold z-50 pointer-events-none transition-opacity';
              document.getElementById('mainCanvas').parentElement.appendChild(overlay);
            }
            overlay.innerText = msg;
            overlay.style.opacity = '1';
            setTimeout(() => { overlay.style.opacity = '0'; }, duration);
          },
          // Drag panel functionality
          _dragPanel: { active: false, panelId: null, startX: 0, startY: 0, origLeft: 0, origTop: 0 },
          startDragPanel(e, panelId) {
            const panel = document.getElementById(panelId);
            if (!panel) return;
            e.preventDefault();

            // Get current position
            const rect = panel.getBoundingClientRect();
            const parentRect = panel.parentElement.getBoundingClientRect();

            // Remove transform classes and set explicit position
            panel.classList.remove('-translate-x-1/2');
            panel.style.transform = 'none';
            panel.style.left = (rect.left - parentRect.left) + 'px';
            panel.style.top = (rect.top - parentRect.top) + 'px';
            panel.style.bottom = 'auto';

            this._dragPanel = {
              active: true,
              panelId,
              startX: e.clientX,
              startY: e.clientY,
              origLeft: rect.left - parentRect.left,
              origTop: rect.top - parentRect.top
            };

            const onMove = (ev) => {
              if (!this._dragPanel.active) return;
              const dx = ev.clientX - this._dragPanel.startX;
              const dy = ev.clientY - this._dragPanel.startY;
              panel.style.left = (this._dragPanel.origLeft + dx) + 'px';
              panel.style.top = (this._dragPanel.origTop + dy) + 'px';
            };

            const onUp = () => {
              this._dragPanel.active = false;
              document.removeEventListener('mousemove', onMove);
              document.removeEventListener('mouseup', onUp);
            };

            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
          },
          render() {
            // Update Block List
            document.getElementById('list-blocks').innerHTML = App.State.blocks.map((b, i) => `
            <tr class="border-b cursor-pointer ${App.State.isSelected('block', b.id) ? 'bg-amber-50' : 'hover:bg-slate-50'}"
                onclick="App.State.handleListClick('block', ${i}, event, '${b.id}')"
                ondblclick="App.UI.openEdit(App.State.blocks.find(x=>x.id==='${b.id}'))">
              <td class="p-1 text-center text-slate-400">${i + 1}</td>
              <td class="p-1 font-bold">${b.name}</td>
              <td class="p-1 text-[10px] text-slate-500 font-mono">${b.X.toFixed(2)},${b.Y.toFixed(2)}</td>
              <td class="p-1 text-[10px] text-slate-500">${b.L.toFixed(1)}x${b.W.toFixed(1)}</td>
              <td class="p-1 text-[10px] text-slate-500">${b.H.toFixed(2)}</td>
              <td class="p-1 text-center text-[10px] text-slate-500">${b.op === -1 ? '<i class="fa-solid fa-check text-slate-600"></i>' : ''}</td>
              <td class="text-center"><button onclick="event.stopPropagation();App.Actions.deleteSelected()" class="text-slate-300 hover:text-red-500"><i class="fa-solid fa-times"></i></button></td>
            </tr>
          `).join('');

            // Update Points List - Table format matching Piles
            document.getElementById('list-points').innerHTML = App.State.points.map((p, i) => `
                        <tr class="border-b ${App.State.isSelected('point', p.id) ? 'bg-slate-100' : ''} cursor-pointer hover:bg-slate-50"
                            onclick="App.State.handleListClick('point', ${i}, event, '${p.id}')"
                            ondblclick="App.UI.openPointEdit(App.State.points.find(x=>x.id==='${p.id}'))">
                            <td class="text-center text-slate-400">${i + 1}</td>
                            <td class="text-xs font-medium">${p.name || 'Point'}</td>
                            <td class="text-[10px] text-slate-500 font-mono">${p.X.toFixed(2)},${p.Y.toFixed(2)}</td>
                            <td class="text-[10px] text-slate-400">${p.hostType ? (p.hostType === 'block' ? 'B' : 'P') : '-'}</td>
                            <td class="text-center"><button onclick="event.stopPropagation();App.Actions.deletePoint('${p.id}')"><i class="fa-solid fa-times text-slate-300 hover:text-red-500"></i></button></td>
                        </tr>
                    `).join('');

            // Update Pile List (UPDATED)
            document.getElementById('list-piles').innerHTML = App.State.piles.map((p, i) => `
                        <tr class="border-b ${App.State.isSelected('pile', p.id) ? 'bg-green-50' : ''} cursor-pointer hover:bg-green-50"
                            onclick="App.State.handleListClick('pile', ${i}, event, '${p.id}')"
                            ondblclick="App.UI.openPileEdit(App.State.piles.find(x=>x.id==='${p.id}'))">
                            <td class="text-center text-slate-400">${i + 1}</td>
                            <td class="font-medium text-[10px]">${p.name || 'P' + (i + 1)}</td>
                            <td class="text-[10px] text-slate-500 font-mono">${p.X.toFixed(2)},${p.Y.toFixed(2)},${(p.Z || 0).toFixed(2)}</td>
                            <td class="text-[10px] text-slate-500">${p.shape === 'round' ? 'O' : '[]'} ${p.size}</td>
                            <td class="text-[10px] text-slate-500">${p.length}m</td>
                            <td class="text-center"><button onclick="event.stopPropagation();App.Actions.deletePile('${p.id}')"><i class="fa-solid fa-times text-slate-300 hover:text-red-500"></i></button></td>
                        </tr>
                    `).join('');

            // Update Machines List (with I values in 2nd row)
            document.getElementById('list-machines').innerHTML = App.State.machines.map((m, i) => `
            <tr class="border-b hover:bg-purple-50 cursor-pointer ${App.State.isSelected('machine', m.id) ? 'bg-purple-100' : ''}"
                onclick="App.State.handleListClick('machine', ${i}, event, '${m.id}')"
                ondblclick="App.UI.openMachineEdit(App.State.machines.find(x=>x.id==='${m.id}'))">
              <td class="p-1 text-center text-slate-400" rowspan="2">${i + 1}</td>
              <td class="p-1 font-medium" rowspan="2">${m.name}</td>
              <td class="p-1">${m.W.toFixed(1)}</td>
              <td class="p-1 text-xs text-slate-500">${m.X.toFixed(2)},${m.Y.toFixed(2)},${m.Z.toFixed(2)}</td>
              <td class="p-1 text-xs" rowspan="2">${(m.rotation || 0)}°</td>
              <td class="text-center" rowspan="2"><button onclick="event.stopPropagation();App.Actions.deleteMachine('${m.id}')"><i class="fa-solid fa-times text-slate-300 hover:text-red-500"></i></button></td>
            </tr>
            <tr class="border-b hover:bg-purple-50 cursor-pointer ${App.State.isSelected('machine', m.id) ? 'bg-purple-100' : ''}"
                onclick="App.State.handleListClick('machine', ${i}, event, '${m.id}')"
                ondblclick="App.UI.openMachineEdit(App.State.machines.find(x=>x.id==='${m.id}'))">
              <td class="p-1 text-[11px] text-blue-500 italic">I:</td>
              <td class="p-1 text-[11px] text-blue-400 font-mono">${(m.Ix || 0).toFixed(3)},${(m.Iy || 0).toFixed(3)},${(m.Iz || 0).toFixed(3)}</td>
            </tr>
          `).join('');

            // Update Assemblies List
            const asmList = document.getElementById('list-assemblies');
            if (asmList) {
              asmList.innerHTML = App.State.assemblies.map((a, i) => `
              <tr class="border-b hover:bg-purple-50 cursor-pointer ${App.State.isSelected('assembly', a.id) ? 'bg-purple-100' : ''}"
                  onclick="App.State.handleListClick('assembly', ${i}, event, '${a.id}')"
                  ondblclick="App.Assembly.openWizard(App.State.assemblies.find(x=>x.id==='${a.id}'))">
                <td class="p-1 text-center text-slate-400">${i + 1}</td>
                <td class="p-1 font-medium text-purple-600">${a.name}</td>
                <td class="p-1 text-xs text-slate-500">${a.X.toFixed(1)},${a.Y.toFixed(1)}</td>
                <td class="p-1 text-xs text-slate-400">${a.components.length}</td>
                <td class="text-center"><button onclick="event.stopPropagation();App.Assembly.deleteAssembly('${a.id}')"><i class="fa-solid fa-times text-slate-300 hover:text-red-500"></i></button></td>
              </tr>
            `).join('');
            }
            // Update asm-count
            const asmCount = document.getElementById('asm-count');
            if (asmCount) asmCount.innerText = App.State.assemblies.length + ' assemblies';

            // Update LoadPoints List
            document.getElementById('list-loadPoints').innerHTML = App.State.loadPoints.map((lp, i) => `
            <tr class="border-b hover:bg-red-50 cursor-pointer ${App.State.isSelected('load', lp.id) ? 'bg-red-100' : ''}"
                onclick="App.State.handleListClick('load', ${i}, event, '${lp.id}')"
                ondblclick="App.UI.openLoadEdit(App.State.loadPoints.find(x=>x.id==='${lp.id}'))">
              <td class="p-1 text-center text-slate-400">${i + 1}</td>
              <td class="p-1 font-medium text-xs">${lp.name || 'Load'}</td>
              <td class="p-1 text-[10px] text-slate-500 font-mono">${lp.X.toFixed(2)},${lp.Y.toFixed(2)},${lp.Z.toFixed(2)}</td>
              <td class="p-1 text-[10px] text-slate-400">${lp.hostType ? (lp.hostType === 'machine' ? 'M' : 'B') : '-'}</td>
              <td class="p-1 text-[10px]"><span class="text-red-500">${lp.Fx || 0}</span> <span class="text-green-500">${lp.Fy || 0}</span> <span class="text-blue-500">${lp.Fz || 0}</span></td>
              <td class="text-center"><button onclick="event.stopPropagation();App.Actions.deleteLoad('${lp.id}')"><i class="fa-solid fa-times text-slate-300 hover:text-red-500"></i></button></td>
            </tr>
          `).join('');

            // --- UPDATE NEW PANELS ---

            // 1. Element List Panel (Left)
            const listContent = document.getElementById('element-list-content');
            const totalEl = App.State.blocks.length + App.State.piles.length + App.State.machines.length + App.State.points.length + App.State.loadPoints.length;
            const elCountDiv = document.getElementById('element-count');
            if (elCountDiv) elCountDiv.innerText = totalEl;

            // Update assembly count
            const asmCountDiv = document.getElementById('asm-count');
            if (asmCountDiv) asmCountDiv.innerText = `${App.State.assemblies.length} assembl${App.State.assemblies.length === 1 ? 'y' : 'ies'}`;
            const asmToggle = document.getElementById('toggle-assemblies');
            if (asmToggle) asmToggle.checked = App.State.showAssemblies;

            if (listContent) {
              let listHTML = '';
              // Loads (NEW)
              if (App.State.loadPoints.length > 0) {
                listHTML += `<div class="font-bold text-red-500 px-2 py-1 bg-red-50 sticky top-0">Loads (${App.State.loadPoints.length})</div>`;
                App.State.loadPoints.forEach((lp, i) => {
                  const sel = App.State.isSelected('load', lp.id);
                  listHTML += `<div class="px-2 py-0.5 cursor-pointer flex justify-between items-center ${sel ? 'bg-red-100 text-red-700' : 'hover:bg-red-50'}"
                  onclick="App.State.handleListClick('load', ${i}, event, '${lp.id}')">
                  <span><i class="fa-solid fa-bullseye text-[8px] mr-1 opacity-50"></i>${lp.name || 'Load'}</span>
                </div>`;
                });
              }
              // Points
              if (App.State.points.length > 0) {
                listHTML += `<div class="font-bold text-slate-500 px-2 py-1 bg-slate-50 sticky top-0">Points (${App.State.points.length})</div>`;
                App.State.points.forEach((p, i) => {
                  const sel = App.State.isSelected('point', p.id);
                  listHTML += `<div class="px-2 py-0.5 cursor-pointer flex justify-between items-center ${sel ? 'bg-red-100 text-red-700' : 'hover:bg-slate-50'}"
                  onclick="App.State.handleListClick('point', ${i}, event, '${p.id}')">
                  <span><i class="fa-solid fa-crosshairs text-[8px] mr-1 opacity-50"></i>${p.name}</span>
                </div>`;
                });
              }
              // Blocks
              if (App.State.blocks.length > 0) {
                listHTML += `<div class="font-bold text-slate-500 px-2 py-1 bg-slate-50 border-t sticky top-0">Blocks (${App.State.blocks.length})</div>`;
                App.State.blocks.forEach((b, i) => {
                  const sel = App.State.isSelected('block', b.id);
                  listHTML += `<div class="px-2 py-0.5 cursor-pointer flex justify-between items-center ${sel ? 'bg-blue-100 text-blue-700' : 'hover:bg-slate-50'}"
                  onclick="App.State.handleListClick('block', ${i}, event, '${b.id}')">
                  <span><i class="fa-solid fa-cube text-[8px] mr-1 opacity-50"></i>${b.name}</span>
                </div>`;
                });
              }
              // Machines
              if (App.State.machines.length > 0) {
                listHTML += `<div class="font-bold text-slate-500 px-2 py-1 bg-slate-50 border-t sticky top-0">Machines (${App.State.machines.length})</div>`;
                App.State.machines.forEach((m, i) => {
                  const sel = App.State.isSelected('machine', m.id);
                  listHTML += `<div class="px-2 py-0.5 cursor-pointer flex justify-between items-center ${sel ? 'bg-purple-100 text-purple-700' : 'hover:bg-slate-50'}"
                  onclick="App.State.handleListClick('machine', ${i}, event, '${m.id}')">
                  <span><i class="fa-solid fa-cog text-[8px] mr-1 opacity-50"></i>${m.name || 'Machine'}</span>
                </div>`;
                });
              }
              // Piles
              if (App.State.piles.length > 0) {
                listHTML += `<div class="font-bold text-slate-500 px-2 py-1 bg-slate-50 border-t sticky top-0">Piles (${App.State.piles.length})</div>`;
                App.State.piles.forEach((p, i) => {
                  const sel = App.State.isSelected('pile', p.id);
                  listHTML += `<div class="px-2 py-0.5 cursor-pointer flex justify-between items-center ${sel ? 'bg-green-100 text-green-700' : 'hover:bg-slate-50'}"
                  onclick="App.State.handleListClick('pile', ${i}, event, '${p.id}')">
                  <span><i class="fa-solid fa-circle text-[8px] mr-1 opacity-50"></i>${p.name || 'P' + (i + 1)}</span>
                </div>`;
                });
              }
              // Assemblies
              if (App.State.assemblies.length > 0) {
                listHTML += `<div class="font-bold text-purple-600 px-2 py-1 bg-purple-50 border-t sticky top-0">Assemblies (${App.State.assemblies.length})</div>`;
                App.State.assemblies.forEach((a, i) => {
                  const sel = App.State.isSelected('assembly', a.id);
                  listHTML += `<div class="px-2 py-0.5 cursor-pointer flex justify-between items-center ${sel ? 'bg-purple-100 text-purple-700' : 'hover:bg-purple-50'}"
                  onclick="App.State.handleListClick('assembly', ${i}, event, '${a.id}')"
                  ondblclick="App.Assembly.openWizard(App.State.assemblies.find(x=>x.id==='${a.id}'))">
                  <span><i class="fa-solid fa-layer-group text-[8px] mr-1 opacity-50"></i>${a.name}</span>
                </div>`;
                });
              }
              listContent.innerHTML = listHTML;
            }

            // 2. Selected Elements Panel (Bottom)
            const selPanel = document.getElementById('selection-panel');
            if (selPanel) {
              const selCount = App.State.selectedIds.length;
              document.getElementById('selected-count').innerText = selCount;

              if (selCount > 0) {
                selPanel.classList.remove('hidden');
                let selHTML = '';
                App.State.selectedIds.forEach(s => {
                  let icon = 'fa-question', col = 'text-slate-500', name = s.id;
                  if (s.type === 'block') { icon = 'fa-cube'; col = 'text-blue-500'; const b = App.State.blocks.find(x => x.id === s.id); if (b) name = b.name; }
                  if (s.type === 'pile') { icon = 'fa-circle'; col = 'text-green-500'; const p = App.State.piles.find(x => x.id === s.id); if (p) name = p.name || 'P' + (App.State.piles.indexOf(p) + 1); }
                  if (s.type === 'machine') { icon = 'fa-cog'; col = 'text-purple-500'; const m = App.State.machines.find(x => x.id === s.id); if (m) name = m.name; }
                  if (s.type === 'point') { icon = 'fa-crosshairs'; col = 'text-slate-600'; const p = App.State.points.find(x => x.id === s.id); if (p) name = p.name; }
                  if (s.type === 'load') { icon = 'fa-bullseye'; col = 'text-red-500'; const lp = App.State.loadPoints.find(x => x.id === s.id); if (lp) name = lp.name || 'Load'; }
                  if (s.type === 'assembly') { icon = 'fa-layer-group'; col = 'text-purple-600'; const a = App.State.assemblies.find(x => x.id === s.id); if (a) name = a.name; }

                  selHTML += `<div class="px-1.5 py-0.5 rounded border border-slate-200 bg-slate-50 text-[10px] flex items-center space-x-1 shrink-0">
                  <i class="fa-solid ${icon} ${col}"></i><span>${name}</span>
                  <button onclick="App.State.toggleSelection('${s.type}','${s.id}',true)" class="hover:text-red-500"><i class="fa-solid fa-times"></i></button>
                </div>`;
                });
                document.getElementById('selected-list-content').innerHTML = selHTML;
              } else {
                selPanel.classList.add('hidden');
              }
            }

            // Update Audit Panels
            const auditResult = App.Audit.run();
            // Left panel (next to view buttons)
            const errorsLeftEl = document.getElementById('audit-errors-left');
            const warningsLeftEl = document.getElementById('audit-warnings-left');
            if (errorsLeftEl) errorsLeftEl.innerText = auditResult.errors.length > 0 ? 'Error: ' + auditResult.errors.join(', ') : '';
            if (warningsLeftEl) warningsLeftEl.innerText = auditResult.warnings.length > 0 ? 'Warning: ' + auditResult.warnings.join(', ') : '';

            // Calc
            const sys = App.Physics.calcSystem(App.State.blocks, App.State.machines, App.State.params);
            const stiff = App.Physics.calcStiffness(App.State.piles, sys.cg);
            // Aggregate loads from loadPoints for physics
            const firstLP = App.State.loadPoints[0] || { X: 0, Y: 0, Z: 0 };
            const aggregatedLoads = {
              Fx: 0, Fy: 0, Fz: 0, Mx: 0, My: 0, Mz: 0,
              freq: App.State.loadsConfig.freq || 3000,
              X: firstLP.X, Y: firstLP.Y, Z: firstLP.Z
            };
            App.State.loadPoints.forEach(lp => {
              aggregatedLoads.Fx += lp.Fx || 0;
              aggregatedLoads.Fy += lp.Fy || 0;
              aggregatedLoads.Fz += lp.Fz || 0;
              aggregatedLoads.Mx += lp.Mx || 0;
              aggregatedLoads.My += lp.My || 0;
              aggregatedLoads.Mz += lp.Mz || 0;
            });
            const res = App.Physics.solve(sys, stiff, aggregatedLoads, App.State.params);

            document.getElementById('res-mass').innerText = sys.mass.toFixed(2);
            document.getElementById('res-cg').innerText = `${sys.cg.x.toFixed(1)},${sys.cg.y.toFixed(1)},${sys.cg.z.toFixed(1)}`;
            const elFnz = document.getElementById('res-fnz'); if (elFnz) elFnz.innerText = Math.round(res.fn_z);
            const elFnc = document.getElementById('res-fnc'); if (elFnc) elFnc.innerText = Math.round(res.fn_coupled);
            const elAmpZ = document.getElementById('bar-amp-z'); if (elAmpZ) elAmpZ.style.height = Math.min(res.amp_z * 1e9, 100) + "%";

            // Legacy load inputs are now removed - loadPoints are managed via Loads tab
            document.getElementById('set-pileDraw').value = App.State.params.pileDrawMode || 'representative';

            // Sync Header Job Name
            const headerJobName = document.getElementById('header-jobName');
            if (headerJobName && App.State.projectInfo) {
              headerJobName.value = App.State.projectInfo.jobName || '';
            }

            // Sync Machine settings
            const machineFreq = document.getElementById('machine-freq');
            if (machineFreq) machineFreq.value = App.State.loadsConfig.freq || 3000;
            const machineType = document.getElementById('machine-type');
            if (machineType && App.State.projectInfo) machineType.value = App.State.projectInfo.machineType || 'C';
          },
          updatePropsPanel() {
            const panel = document.getElementById('props-panel');
            const content = document.getElementById('props-content');
            const typeLabel = document.getElementById('props-type');

            if (!App.State.selectedIds || App.State.selectedIds.length === 0) {
              panel.classList.add('hidden');
              return;
            }

            panel.classList.remove('hidden');
            const types = [...new Set(App.State.selectedIds.map(s => s.type))];
            const count = App.State.selectedIds.length;

            if (types.length > 1) {
              typeLabel.innerText = `Mixed (${count})`;
              content.innerHTML = `<div class="text-slate-400 italic text-center py-4">Cannot edit mixed types</div>`;
              return;
            }

            const type = types[0];
            typeLabel.innerText = `${type.charAt(0).toUpperCase() + type.slice(1)} (${count})`;

            // Helper to get common value or <VARIABLE>
            const getVal = (prop) => {
              let val = undefined;
              for (let s of App.State.selectedIds) {
                let obj = null;
                if (type === 'block') obj = App.State.blocks.find(x => x.id === s.id);
                if (type === 'pile') obj = App.State.piles.find(x => x.id === s.id);
                if (type === 'machine') obj = App.State.machines.find(x => x.id === s.id);
                if (type === 'point') obj = App.State.points.find(x => x.id === s.id);
                if (type === 'load') obj = App.State.loadPoints.find(x => x.id === s.id);
                if (type === 'assembly') obj = App.State.assemblies.find(x => x.id === s.id);

                if (!obj) continue;
                if (val === undefined) val = obj[prop];
                else if (val !== obj[prop]) return '<VARIABLE>';
              }
              return val;
            };

            // Helper to get ID# (sequential index) - shows list for multi-select
            const getID = () => {
              if (App.State.selectedIds.length > 1) {
                // Show list of IDs for multi-select
                let arr = [];
                if (type === 'block') arr = App.State.blocks;
                if (type === 'pile') arr = App.State.piles;
                if (type === 'machine') arr = App.State.machines;
                if (type === 'point') arr = App.State.points;
                if (type === 'load') arr = App.State.loadPoints;
                if (type === 'assembly') arr = App.State.assemblies;
                return App.State.selectedIds.map(s => {
                  const idx = arr.findIndex(x => x.id === s.id);
                  return idx >= 0 ? `#${idx + 1}` : '#?';
                }).join(', ');
              }
              const s = App.State.selectedIds[0];
              let arr = [];
              if (type === 'block') arr = App.State.blocks;
              if (type === 'pile') arr = App.State.piles;
              if (type === 'machine') arr = App.State.machines;
              if (type === 'point') arr = App.State.points;
              if (type === 'load') arr = App.State.loadPoints;
              if (type === 'assembly') arr = App.State.assemblies;
              const idx = arr.findIndex(x => x.id === s.id);
              return idx >= 0 ? `#${idx + 1}` : '#?';
            };

            const input = (lbl, prop, step = 0.1, min = null) => {
              const val = getVal(prop);
              const disabled = val === '<VARIABLE>';
              return `
              <div class="grid grid-cols-3 gap-1 items-center">
                <label class="text-slate-500 text-right pr-1">${lbl}</label>
                <input class="col-span-2 border rounded px-1 py-0.5 ${disabled ? 'text-slate-300 italic' : ''}"
                  type="${typeof val === 'string' && prop !== 'shape' ? 'text' : 'number'}"
                  step="${step}" ${min !== null ? 'min="' + min + '"' : ''}
                  value="${disabled ? '<VARIABLE>' : (val === undefined ? '' : val)}"
                  ${disabled ? 'disabled' : ''}
                  oninput="App.UI.updateProp('${prop}', this.value)">
              </div>`;
            };

            const idDisplay = () => {
              const id = getID();
              return `<div class="grid grid-cols-3 gap-1 items-center bg-slate-100 p-1 rounded">
              <label class="text-slate-700 text-right pr-1 font-bold">ID</label>
              <div class="col-span-2 text-blue-600 font-bold">${id}</div>
            </div>`;
            };

            let html = '';
            if (type === 'block') {
              html += idDisplay();
              html += input('Name', 'name');
              const opVal = getVal('op');
              html += `<div class="grid grid-cols-3 gap-1 items-center">
              <label class="text-slate-500 text-right pr-1">Subtract</label>
              <input class="col-span-2" type="checkbox"
                ${opVal === -1 ? 'checked' : ''} ${opVal === '<VARIABLE>' ? 'disabled' : ''}
                onchange="App.UI.updateProp('op', this.checked ? -1 : 1)">
            </div>`;
              html += input('L (m)', 'L', 0.1, 0.1);
              html += input('W (m)', 'W', 0.1, 0.1);
              html += input('H (m)', 'H', 0.1, 0.1);
              html += '<hr class="my-1">';
              html += input('X (m)', 'X');
              html += input('Y (m)', 'Y');
              html += input('Z (m)', 'Z');
            } else if (type === 'pile') {
              html += idDisplay();
              // Custom Name input for Pile to handle default P{index}
              const pVal = getVal('name');
              const pIdx = getID().replace('#', ''); // Get ID number string
              const pDisplay = (pVal === undefined || pVal === '') ? ('P' + pIdx) : pVal;
              const pDis = pVal === '<VARIABLE>';
              html += `<div class="grid grid-cols-3 gap-1 items-center">
                 <label class="text-slate-500 text-right pr-1">Name</label>
                 <input class="col-span-2 border rounded px-1 py-0.5 ${pDis ? 'text-slate-300 italic' : ''}"
                   type="text"
                   value="${pDisplay}"
                   ${pDis ? 'disabled' : ''}
                   oninput="App.UI.updateProp('name', this.value)">
               </div>`;
              html += '<hr class="my-1">';
              html += input('X (m)', 'X');
              html += input('Y (m)', 'Y');
              html += input('Z (m)', 'Z');
              html += '<hr class="my-1 border-dashed">';
              // Adding Shape/Size props
              const shapeVal = getVal('shape');
              const shapeDis = shapeVal === '<VARIABLE>';
              html += `<div class="grid grid-cols-3 gap-1 items-center">
                <label class="text-slate-500 text-right pr-1">Shape</label>
                <select class="col-span-2 border rounded px-1 py-0.5 ${shapeDis ? 'text-slate-300 italic' : ''}"
                   ${shapeDis ? 'disabled' : ''} onchange="App.UI.updateProp('shape', this.value)">
                   <option value="round" ${shapeVal === 'round' ? 'selected' : ''}>Round</option>
                   <option value="square" ${shapeVal === 'square' ? 'selected' : ''}>Square</option>
                </select>
            </div>`;
              html += input('Size', 'size', 0.05);
              html += input('Length', 'length', 0.1);
              html += '<hr class="my-1">';
              html += input('Kv', 'Kv', 1000);
              html += input('Kh', 'Kh', 1000);
            } else if (type === 'machine') {
              html += idDisplay();
              html += input('Name', 'name');
              html += input('Weight', 'W', 0.1);
              html += '<hr class="my-1">';
              html += input('X (m)', 'X');
              html += input('Y (m)', 'Y');
              html += input('Z (m)', 'Z');
              html += input('Rot (°)', 'rotation', 15);
              html += '<hr class="my-1 border-purple-200">';
              html += '<div class="text-purple-600 font-bold text-[10px] mb-1">Inertia (kN·m·s²)</div>';
              html += input('Ix', 'Ix', 0.001);
              html += input('Iy', 'Iy', 0.001);
              html += input('Iz', 'Iz', 0.001);
            } else if (type === 'point') {
              html += idDisplay();
              html += input('Name', 'name');
              html += '<hr class="my-1">';
              html += input('X (m)', 'X');
              html += input('Y (m)', 'Y');
              html += input('Z (m)', 'Z');
            } else if (type === 'load') {
              html += idDisplay();
              html += input('Name', 'name');
              html += '<hr class="my-1">';
              html += input('X (m)', 'X');
              html += input('Y (m)', 'Y');
              html += input('Z (m)', 'Z');
              html += '<hr class="my-1 border-red-200">';
              const typeVal = getVal('type') || 'C';
              const typeDis = typeVal === '<VARIABLE>';
              html += `<div class="grid grid-cols-3 gap-1 items-center">
              <label class="text-slate-500 text-right pr-1">Type</label>
              <select class="col-span-2 border rounded px-1 py-0.5 ${typeDis ? 'text-slate-300 italic' : ''}"
                 ${typeDis ? 'disabled' : ''} onchange="App.UI.updateProp('type', this.value)">
                 <option value="C" ${typeVal === 'C' ? 'selected' : ''}>C (Centrifugal)</option>
                 <option value="R" ${typeVal === 'R' ? 'selected' : ''}>R (Reciprocating)</option>
              </select>
            </div>`;
              html += '<hr class="my-1 border-red-200">';
              html += '<div class="text-red-600 font-bold text-[10px] mb-1">Primary Forces</div>';
              html += input('Fx (kN)', 'Fx', 0.1);
              html += input('Fy (kN)', 'Fy', 0.1);
              html += input('Fz (kN)', 'Fz', 0.1);
              html += input('Mx (kNm)', 'Mx', 0.1);
              html += input('My (kNm)', 'My', 0.1);
              html += input('Mz (kNm)', 'Mz', 0.1);
              if (typeVal === 'R') {
                html += '<hr class="my-1 border-orange-200">';
                html += '<div class="text-orange-600 font-bold text-[10px] mb-1">Secondary Forces (Type R)</div>';
                html += input('Fx2 (kN)', 'Fx2', 0.1);
                html += input('Fy2 (kN)', 'Fy2', 0.1);
                html += input('Fz2 (kN)', 'Fz2', 0.1);
                html += input('Mx2 (kNm)', 'Mx2', 0.1);
                html += input('My2 (kNm)', 'My2', 0.1);
                html += input('Mz2 (kNm)', 'Mz2', 0.1);
              }
            } else if (type === 'assembly') {
              html += idDisplay();
              html += input('Name', 'name');
              html += '<hr class="my-1">';
              html += input('X (m)', 'X');
              html += input('Y (m)', 'Y');
              html += input('Z (m)', 'Z');
              html += input('Rot (°)', 'rotation', 15);

              // Get assembly for detailed info
              const asm = App.State.assemblies.find(a => a.id === App.State.selectedIds[0].id);
              if (asm) {
                const g = App.State.params.gravity || 9.81;
                const rot = (asm.rotation || 0) * Math.PI / 180;
                let totalIx = 0, totalIy = 0, totalIz = 0;

                // Calculate total I at anchor
                (asm.components || []).forEach(comp => {
                  if (!comp.considerI) return;
                  const dxRot = comp.dx * Math.cos(rot) - comp.dy * Math.sin(rot);
                  const dyRot = comp.dx * Math.sin(rot) + comp.dy * Math.cos(rot);
                  const dzRot = comp.dz || 0;
                  const mass = (comp.W || 0) / g;
                  const distYZ_sq = dyRot * dyRot + dzRot * dzRot;
                  const distXZ_sq = dxRot * dxRot + dzRot * dzRot;
                  const distXY_sq = dxRot * dxRot + dyRot * dyRot;

                  if (comp.lockI) {
                    // User's local I values - add parallel axis
                    let Ix_local = comp.Ix || 0, Iy_local = comp.Iy || 0, Iz_local = comp.Iz || 0;
                    totalIx += Ix_local + mass * distYZ_sq;
                    totalIy += Iy_local + mass * distXZ_sq;
                    totalIz += Iz_local + mass * distXY_sq;
                  } else {
                    // Auto-calc: comp.Ix already contains parallel axis
                    totalIx += comp.Ix || 0;
                    totalIy += comp.Iy || 0;
                    totalIz += comp.Iz || 0;
                  }
                });

                html += '<hr class="my-1 border-purple-200">';
                html += `<div class="text-purple-600 font-bold text-[10px] mb-1">Components: ${asm.components?.length || 0}</div>`;
                html += '<hr class="my-1 border-blue-200">';
                html += `<div class="text-blue-600 font-bold text-[10px] mb-1">ΣI at Anchor (kN·m·s²)</div>`;
                html += `<div class="grid grid-cols-3 gap-1 text-[9px] font-mono bg-blue-50 rounded p-1">
                  <div class="text-center"><span class="text-blue-400">Ix:</span> ${totalIx.toFixed(4)}</div>
                  <div class="text-center"><span class="text-blue-400">Iy:</span> ${totalIy.toFixed(4)}</div>
                  <div class="text-center"><span class="text-blue-400">Iz:</span> ${totalIz.toFixed(4)}</div>
                </div>`;

                // Component list
                html += '<hr class="my-1">';
                html += '<div class="text-[9px] text-slate-500 font-bold mb-1">Component Details:</div>';
                html += '<div class="max-h-24 overflow-y-auto text-[9px]">';
                (asm.components || []).forEach((c, i) => {
                  const iStatus = c.considerI ? (c.lockI ? '🔒' : '✓') : '✗';
                  html += `<div class="flex justify-between border-b border-slate-100 py-0.5">
                    <span class="font-medium">${i + 1}. ${c.name || 'Part'}</span>
                    <span class="text-slate-400">W:${c.W?.toFixed(1)} d:(${c.dx?.toFixed(1)},${c.dy?.toFixed(1)},${c.dz?.toFixed(1)}) ${iStatus}</span>
                  </div>`;
                });
                html += '</div>';
              }
            }
            content.innerHTML = html;
          },
          updateProp(prop, val) {
            const type = App.State.selectedIds[0].type;
            App.State.selectedIds.forEach(s => {
              let obj = null;
              if (s.type === 'block') obj = App.State.blocks.find(x => x.id === s.id);
              if (s.type === 'pile') obj = App.State.piles.find(x => x.id === s.id);
              if (s.type === 'machine') obj = App.State.machines.find(x => x.id === s.id);
              if (s.type === 'point') obj = App.State.points.find(x => x.id === s.id);
              if (s.type === 'load') obj = App.State.loadPoints.find(x => x.id === s.id);
              if (s.type === 'assembly') obj = App.State.assemblies.find(x => x.id === s.id);

              if (obj) {
                if (['name', 'shape'].includes(prop)) obj[prop] = val;
                else obj[prop] = parseFloat(val);
              }
            });
            App.State.notify(false); // No history for real-time update
          },
          switchTab(t) {
            ['blocks', 'points', 'piles', 'machines', 'loads', 'settings'].forEach(x => {
              document.getElementById(`panel-${x}`).className = x === t ? '' : 'hidden';
              document.getElementById(`tab-${x}`).className = x === t ? 'tab-btn active px-4 py-2 font-bold border-b-2 text-xs flex-none' : 'tab-btn px-4 py-2 font-bold border-b-2 text-xs flex-none';
            });
            // Scroll selected tab into view
            const tabEl = document.getElementById(`tab-${t}`);
            if (tabEl) tabEl.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
          },
          toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const btn = document.getElementById('sidebar-toggle-btn');
            const icon = document.getElementById('collapse-icon');
            const uiElements = [
              document.getElementById('ui-view-tools'),
              document.getElementById('element-list-panel'),
              document.getElementById('ui-cursor-info')
            ];

            if (sidebar.style.left === '-320px') {
              sidebar.style.left = '0';
              icon.className = 'fa-solid fa-chevron-left text-xs text-slate-600';
              uiElements.forEach(el => { if (el) el.style.left = '330px'; });
            } else {
              sidebar.style.left = '-320px';
              icon.className = 'fa-solid fa-chevron-right text-xs text-slate-600';
              uiElements.forEach(el => { if (el) el.style.left = '10px'; });
            }
            btn.style.transform = 'translateY(-50%)';
          },
          openEdit(b) {
            document.getElementById('editId').value = b.id; document.getElementById('editName').value = b.name;
            ['L', 'W', 'H', 'X', 'Y', 'Z'].forEach(k => document.getElementById('edit' + k).value = b[k]);
            document.getElementById('editDensity').value = b.density;
            document.getElementById('editOp').checked = b.op === -1;
            document.getElementById('editModal').classList.remove('opacity-0', 'pointer-events-none');
          },
          closeModal() { document.getElementById('editModal').classList.add('opacity-0', 'pointer-events-none'); },
          openMachineEdit(m) {
            if (!m) return;
            document.getElementById('editMachineId').value = m.id;
            document.getElementById('editMachineName').value = m.name;
            document.getElementById('editMachineW').value = m.W;
            document.getElementById('editMachineX').value = m.X;
            document.getElementById('editMachineY').value = m.Y;
            document.getElementById('editMachineZ').value = m.Z;
            document.getElementById('editMachineRot').value = m.rotation || 0;
            document.getElementById('editMachineIx').value = m.Ix || 0;
            document.getElementById('editMachineIy').value = m.Iy || 0;
            document.getElementById('editMachineIz').value = m.Iz || 0;
            document.getElementById('machineModal').classList.remove('opacity-0', 'pointer-events-none');
          },
          closeMachineModal() { document.getElementById('machineModal').classList.add('opacity-0', 'pointer-events-none'); },
          openPileEdit(p) {
            if (!p) return;
            document.getElementById('editPileId').value = p.id;
            const idx = App.State.piles.indexOf(p);
            document.getElementById('editPileName').value = p.name || 'P' + (idx + 1); // Fix name default in modal
            document.getElementById('editPileX').value = p.X;
            document.getElementById('editPileY').value = p.Y;
            document.getElementById('editPileZ').value = p.Z || 0;
            document.getElementById('editPileKv').value = p.Kv;
            document.getElementById('editPileKh').value = p.Kh;
            // New props
            document.getElementById('editPileShape').value = p.shape || 'round';
            document.getElementById('editPileSize').value = p.size || 0.4;
            document.getElementById('editPileLen').value = p.length || 10;

            document.getElementById('pileModal').classList.remove('opacity-0', 'pointer-events-none');
          },
          closePileModal() { document.getElementById('pileModal').classList.add('opacity-0', 'pointer-events-none'); },
          openPointEdit(p) {
            if (!p) return;
            document.getElementById('editPointId').value = p.id;
            document.getElementById('editPointName').value = p.name || 'Point';
            document.getElementById('editPointX').value = p.X;
            document.getElementById('editPointY').value = p.Y;
            // Host props
            document.getElementById('editPointHostType').value = p.hostType || '';
            document.getElementById('editPointHostId').value = p.hostId || '';

            document.getElementById('pointModal').classList.remove('opacity-0', 'pointer-events-none');
          },
          closePointModal() { document.getElementById('pointModal').classList.add('opacity-0', 'pointer-events-none'); },
          openLoadEdit(lp) {
            if (!lp) return;
            document.getElementById('editLoadId').value = lp.id;
            document.getElementById('editLoadName').value = lp.name || 'Load';
            document.getElementById('editLoadX').value = lp.X;
            document.getElementById('editLoadY').value = lp.Y;
            document.getElementById('editLoadZ').value = lp.Z;
            document.getElementById('editLoadType').value = lp.type || 'C';
            document.getElementById('editLoadFx').value = lp.Fx || 0;
            document.getElementById('editLoadFy').value = lp.Fy || 0;
            document.getElementById('editLoadFz').value = lp.Fz || 0;
            document.getElementById('editLoadMx').value = lp.Mx || 0;
            document.getElementById('editLoadMy').value = lp.My || 0;
            document.getElementById('editLoadMz').value = lp.Mz || 0;
            document.getElementById('editLoadFx2').value = lp.Fx2 || 0;
            document.getElementById('editLoadFy2').value = lp.Fy2 || 0;
            document.getElementById('editLoadFz2').value = lp.Fz2 || 0;
            document.getElementById('editLoadMx2').value = lp.Mx2 || 0;
            document.getElementById('editLoadMy2').value = lp.My2 || 0;
            document.getElementById('editLoadMz2').value = lp.Mz2 || 0;
            document.getElementById('editLoadHostType').value = lp.hostType || '';

            // Convert hostId (internal ID) to ID# (sequential number)
            let hostIdNum = '';
            if (lp.hostType && lp.hostId) {
              let arr = lp.hostType === 'block' ? App.State.blocks :
                lp.hostType === 'machine' ? App.State.machines : [];
              const idx = arr.findIndex(x => x.id === lp.hostId);
              if (idx >= 0) hostIdNum = idx + 1;
            }
            document.getElementById('editLoadHostId').value = hostIdNum;

            // Show/hide secondary section based on THIS load's type
            const isTypeR = (lp.type || 'C') === 'R';
            document.getElementById('loadSecondarySection').classList.toggle('hidden', !isTypeR);
            document.getElementById('loadModal').classList.remove('opacity-0', 'pointer-events-none');
          },
          closeLoadModal() { document.getElementById('loadModal').classList.add('opacity-0', 'pointer-events-none'); },
          getSliderStep(idx) {
            return [0, 0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5][idx];
          }
        },

        // Machine Assembly Module - for defining machine groups with local coordinates
        Assembly: {
          _editingId: null, // null = new, otherwise = editing existing

          // Called by button onclick - just init form, modal is shown by onclick
          initWizard(existingAsm = null) {
            this._editingId = existingAsm?.id || null;
            const $ = id => document.getElementById(id);
            const nameEl = $('asm-name');
            if (nameEl) nameEl.value = existingAsm?.name || 'Assembly ' + (App.State.assemblies.length + 1);
            const xEl = $('asm-X'); if (xEl) xEl.value = existingAsm?.X ?? 0;
            const yEl = $('asm-Y'); if (yEl) yEl.value = existingAsm?.Y ?? 0;
            const zEl = $('asm-Z'); if (zEl) zEl.value = existingAsm?.Z ?? 1.125;
            const rotEl = $('asm-rotation'); if (rotEl) rotEl.value = existingAsm?.rotation ?? 0;

            const tbody = $('asm-components');
            if (tbody) {
              tbody.innerHTML = '';
              const components = existingAsm?.components || [
                { name: 'Motor', W: 34.335, dx: 0, dy: 0, dz: 0, Ix: 0, Iy: 0, Iz: 0, considerI: true, lockI: false },
                { name: 'Pump', W: 11.772, dx: 1.5, dy: 0, dz: 0, Ix: 0, Iy: 0, Iz: 0, considerI: true, lockI: false },
                { name: 'Base', W: 9.025, dx: 0, dy: 1.2, dz: -0.3, Ix: 0, Iy: 0, Iz: 0, considerI: true, lockI: false }
              ];
              components.forEach((c, i) => this.addComponentRow(c, i));
            }
            // Update preview and calculate I values for all components
            setTimeout(() => {
              this.onRotationChange(); // This recalculates all I values
            }, 100);
          },

          // Called by double-click on assembly - init and show modal
          openWizard(existingAsm = null) {
            console.log('openWizard function called', existingAsm);
            try {
              this._editingId = existingAsm?.id || null;
              const $ = id => document.getElementById(id);

              // Check if modal exists
              const modal = $('assemblyWizard');
              if (!modal) { console.error('Assembly wizard modal not found!'); return; }

              // Reset or populate form (with null checks)
              const nameEl = $('asm-name');
              if (nameEl) nameEl.value = existingAsm?.name || 'Assembly ' + (App.State.assemblies.length + 1);
              const xEl = $('asm-X'); if (xEl) xEl.value = existingAsm?.X ?? 0;
              const yEl = $('asm-Y'); if (yEl) yEl.value = existingAsm?.Y ?? 0;
              const zEl = $('asm-Z'); if (zEl) zEl.value = existingAsm?.Z ?? 1.125;
              const rotEl = $('asm-rotation'); if (rotEl) rotEl.value = existingAsm?.rotation ?? 0;

              // Populate component table
              const tbody = $('asm-components');
              if (tbody) {
                tbody.innerHTML = '';
                const components = existingAsm?.components || [
                  { name: 'Motor', W: 34.335, dx: 0, dy: 0, dz: 0, Ix: 0, Iy: 0, Iz: 0, considerI: true, lockI: false },
                  { name: 'Pump', W: 11.772, dx: 1.5, dy: 0, dz: 0, Ix: 0, Iy: 0, Iz: 0, considerI: true, lockI: false },
                  { name: 'Base', W: 9.025, dx: 0, dy: 1.2, dz: -0.3, Ix: 0, Iy: 0, Iz: 0, considerI: true, lockI: false }
                ];
                components.forEach((c, i) => this.addComponentRow(c, i));
              }

              // Show modal - simple hidden class pattern
              modal.classList.remove('hidden');

              // Calculate I values for all components after wizard is visible
              setTimeout(() => this.onRotationChange(), 100);
            } catch (e) {
              console.error('Error opening assembly wizard:', e);
            }
          },

          closeWizard() {
            document.getElementById('assemblyWizard')?.classList.add('hidden');
          },

          // Draw XY preview showing anchor and components
          updatePreview() {
            const canvas = document.getElementById('asm-preview-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            const $ = id => document.getElementById(id);
            const X = parseFloat($('asm-X')?.value) || 0;
            const Y = parseFloat($('asm-Y')?.value) || 0;
            const rot = (parseFloat($('asm-rotation')?.value) || 0) * Math.PI / 180;

            // Get component offsets from form blocks
            const blocks = document.querySelectorAll('#asm-components .asm-comp-block');
            const components = [];
            blocks.forEach(block => {
              const dx = parseFloat(block.querySelector('.asm-comp-dx')?.value) || 0;
              const dy = parseFloat(block.querySelector('.asm-comp-dy')?.value) || 0;
              const name = block.querySelector('.asm-comp-name')?.value || '';
              if (name || dx !== 0 || dy !== 0) components.push({ dx, dy, name });
            });

            // Calculate bounds for auto-scaling
            let minX = X, maxX = X, minY = Y, maxY = Y;
            components.forEach(c => {
              const gx = X + c.dx * Math.cos(rot) - c.dy * Math.sin(rot);
              const gy = Y + c.dx * Math.sin(rot) + c.dy * Math.cos(rot);
              minX = Math.min(minX, gx); maxX = Math.max(maxX, gx);
              minY = Math.min(minY, gy); maxY = Math.max(maxY, gy);
            });

            const rangeX = Math.max(maxX - minX, 4), rangeY = Math.max(maxY - minY, 4);
            const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
            const scale = Math.min(canvas.width / (rangeX + 2), canvas.height / (rangeY + 2));

            // Transform: screen coords from world coords
            const toScreen = (wx, wy) => [
              canvas.width / 2 + (wx - cx) * scale,
              canvas.height / 2 - (wy - cy) * scale
            ];

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 0.5;
            const gridStep = 1;
            for (let gx = Math.floor(minX - 1); gx <= Math.ceil(maxX + 1); gx += gridStep) {
              const [sx, _] = toScreen(gx, 0);
              ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, canvas.height); ctx.stroke();
            }
            for (let gy = Math.floor(minY - 1); gy <= Math.ceil(maxY + 1); gy += gridStep) {
              const [_, sy] = toScreen(0, gy);
              ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(canvas.width, sy); ctx.stroke();
            }

            // Draw anchor point
            const [ax, ay] = toScreen(X, Y);
            ctx.fillStyle = '#9333ea';
            ctx.beginPath(); ctx.arc(ax, ay, 6, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#9333ea'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(ax - 10, ay); ctx.lineTo(ax + 10, ay); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(ax, ay - 10); ctx.lineTo(ax, ay + 10); ctx.stroke();

            // Draw components
            components.forEach((c, i) => {
              const gx = X + c.dx * Math.cos(rot) - c.dy * Math.sin(rot);
              const gy = Y + c.dx * Math.sin(rot) + c.dy * Math.cos(rot);
              const [sx, sy] = toScreen(gx, gy);

              // Dashed line from anchor
              ctx.setLineDash([3, 3]);
              ctx.strokeStyle = '#c084fc';
              ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(sx, sy); ctx.stroke();
              ctx.setLineDash([]);

              // Component dot
              ctx.fillStyle = '#d946ef';
              ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI * 2); ctx.fill();
              ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
              ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI * 2); ctx.stroke();

              // Label
              if (c.name) {
                ctx.fillStyle = '#64748b';
                ctx.font = '9px sans-serif';
                ctx.fillText(c.name, sx + 6, sy + 3);
              }
            });

            // Calculate and display total I at anchor
            const g = App.State.params.gravity;
            let totalIx = 0, totalIy = 0, totalIz = 0;

            blocks.forEach(block => {
              const considerI = block.querySelector('.asm-comp-considerI')?.checked;
              if (!considerI) return; // Skip components with considerI off

              const W = parseFloat(block.querySelector('.asm-comp-W')?.value) || 0;
              const dx = parseFloat(block.querySelector('.asm-comp-dx')?.value) || 0;
              const dy = parseFloat(block.querySelector('.asm-comp-dy')?.value) || 0;
              const dz = parseFloat(block.querySelector('.asm-comp-dz')?.value) || 0;
              const compIx = parseFloat(block.querySelector('.asm-comp-Ix')?.value) || 0;
              const compIy = parseFloat(block.querySelector('.asm-comp-Iy')?.value) || 0;
              const compIz = parseFloat(block.querySelector('.asm-comp-Iz')?.value) || 0;

              const lockI = block.querySelector('.asm-comp-lockI')?.checked;

              // Rotated offsets
              const dxRot = dx * Math.cos(rot) - dy * Math.sin(rot);
              const dyRot = dx * Math.sin(rot) + dy * Math.cos(rot);
              const dzRot = dz;

              // Distance squared for parallel axis
              const distXY_sq = dxRot * dxRot + dyRot * dyRot;
              const distXZ_sq = dxRot * dxRot + dzRot * dzRot;
              const distYZ_sq = dyRot * dyRot + dzRot * dzRot;

              const mass = W / g;

              if (lockI) {
                // User's local I values - need to add parallel axis theorem
                let Ix_local = compIx, Iy_local = compIy, Iz_local = compIz;
                // Rotate local I if needed (optional, for now keep as-is)
                totalIx += Ix_local + mass * distYZ_sq;
                totalIy += Iy_local + mass * distXZ_sq;
                totalIz += Iz_local + mass * distXY_sq;
              } else {
                // Auto-calc mode: input values already contain parallel axis (I = m*d²)
                // Just sum them directly - NO additional parallel axis!
                totalIx += compIx;
                totalIy += compIy;
                totalIz += compIz;
              }
            });

            // Update display
            const totalIxEl = $('asm-total-Ix');
            const totalIyEl = $('asm-total-Iy');
            const totalIzEl = $('asm-total-Iz');
            if (totalIxEl) totalIxEl.innerText = totalIx.toFixed(4);
            if (totalIyEl) totalIyEl.innerText = totalIy.toFixed(4);
            if (totalIzEl) totalIzEl.innerText = totalIz.toFixed(4);
          },

          // Handle rotation change - update all components I and show warnings for lockI
          onRotationChange() {
            const rot = (parseFloat(document.getElementById('asm-rotation')?.value) || 0) * Math.PI / 180;
            const cosR = Math.cos(rot), sinR = Math.sin(rot);
            const g = App.State.params.gravity;

            const blocks = document.getElementById('asm-components').querySelectorAll('.asm-comp-block');
            blocks.forEach((block, compIndex) => {
              const considerI = block.querySelector('.asm-comp-considerI')?.checked;
              const lockI = block.querySelector('.asm-comp-lockI')?.checked;

              const W = parseFloat(block.querySelector('.asm-comp-W')?.value) || 0;
              const dx = parseFloat(block.querySelector('.asm-comp-dx')?.value) || 0;
              const dy = parseFloat(block.querySelector('.asm-comp-dy')?.value) || 0;
              const dz = parseFloat(block.querySelector('.asm-comp-dz')?.value) || 0;

              // Rotated offsets
              const dxRot = dx * cosR - dy * sinR;
              const dyRot = dx * sinR + dy * cosR;
              const dzRot = dz;

              // Distance squared for parallel axis
              const distXY_sq = dxRot * dxRot + dyRot * dyRot;
              const distXZ_sq = dxRot * dxRot + dzRot * dzRot;
              const distYZ_sq = dyRot * dyRot + dzRot * dzRot;
              const mass = W / g;

              // Calculate suggested I values
              const sugIx = mass * distYZ_sq;
              const sugIy = mass * distXZ_sq;
              const sugIz = mass * distXY_sq;

              const IxEl = block.querySelector('.asm-comp-Ix');
              const IyEl = block.querySelector('.asm-comp-Iy');
              const IzEl = block.querySelector('.asm-comp-Iz');

              if (considerI && !lockI) {
                // Auto-update I values
                if (IxEl) IxEl.value = sugIx.toFixed(4);
                if (IyEl) IyEl.value = sugIy.toFixed(4);
                if (IzEl) IzEl.value = sugIz.toFixed(4);
                // Remove warning class if any
                if (IxEl) IxEl.classList.remove('border-yellow-500', 'bg-yellow-50');
                if (IyEl) IyEl.classList.remove('border-yellow-500', 'bg-yellow-50');
                if (IzEl) IzEl.classList.remove('border-yellow-500', 'bg-yellow-50');
                // Remove warning icon if exists
                block.querySelectorAll('.rotation-warning').forEach(w => w.remove());
              } else if (considerI && lockI) {
                // Show warning - rotation changed but I is locked
                if (IxEl) { IxEl.classList.add('border-yellow-500', 'bg-yellow-50'); IxEl.title = `⚠ Rotation changed! Suggested: ${sugIx.toFixed(4)}`; }
                if (IyEl) { IyEl.classList.add('border-yellow-500', 'bg-yellow-50'); IyEl.title = `⚠ Rotation changed! Suggested: ${sugIy.toFixed(4)}`; }
                if (IzEl) { IzEl.classList.add('border-yellow-500', 'bg-yellow-50'); IzEl.title = `⚠ Rotation changed! Suggested: ${sugIz.toFixed(4)}`; }
                // Add warning icon if not exists
                if (inertiaRow && !inertiaRow.querySelector('.rotation-warning')) {
                  const warnDiv = document.createElement('div');
                  // Position relative to "I:" label - put it to the left or replace content?
                  // User said "đưa nó ra chỗ label I"
                  warnDiv.className = 'rotation-warning absolute -left-3 -top-1 text-yellow-600 text-[10px]';
                  warnDiv.innerHTML = '<i class="fa-solid fa-triangle-exclamation" title="Rotation changed - I values may need recalculation"></i>';

                  // Target the I: label container
                  const labelDiv = inertiaRow.querySelector('.label-i-container');
                  if (labelDiv) {
                    // labelDiv is relative, so absolute positioning works inside it
                    labelDiv.appendChild(warnDiv);
                  }
                }
              }

              // Sync to existing machine if editing
              if (this._editingId && considerI && !lockI) {
                const machineId = 'm_gen_' + this._editingId + '_' + compIndex;
                const m = App.State.machines.find(x => x.id === machineId);
                if (m) {
                  m.Ix = sugIx;
                  m.Iy = sugIy;
                  m.Iz = sugIz;
                }
              }
            });

            this.updatePreview();
          },

          // Realtime I calculation using parallel axis theorem
          updateComponentI(inputEl) {
            const block = inputEl.closest('.asm-comp-block');
            if (!block) return;

            // Check if considerI is checked - if not, set I=0
            const considerI = block.querySelector('.asm-comp-considerI')?.checked;
            if (!considerI) {
              // Set all I values to 0 when ConsiderI is off
              const IxEl = block.querySelector('.asm-comp-Ix');
              const IyEl = block.querySelector('.asm-comp-Iy');
              const IzEl = block.querySelector('.asm-comp-Iz');
              if (IxEl) IxEl.value = '0';
              if (IyEl) IyEl.value = '0';
              if (IzEl) IzEl.value = '0';

              // Also sync zero to existing machine if editing assembly
              if (this._editingId) {
                const blocks = document.getElementById('asm-components').querySelectorAll('.asm-comp-block');
                const compIndex = Array.from(blocks).indexOf(block);
                const machineId = 'm_gen_' + this._editingId + '_' + compIndex;
                const m = App.State.machines.find(x => x.id === machineId);
                if (m) {
                  m.Ix = 0;
                  m.Iy = 0;
                  m.Iz = 0;
                }
              }
              this.updatePreview();
              return;
            }

            // Check if lockI is checked - if so, don't auto-calculate
            const lockI = block.querySelector('.asm-comp-lockI')?.checked;
            if (lockI) {
              this.updatePreview();
              return;
            }

            // Get component values
            const W = parseFloat(block.querySelector('.asm-comp-W')?.value) || 0;
            const dx = parseFloat(block.querySelector('.asm-comp-dx')?.value) || 0;
            const dy = parseFloat(block.querySelector('.asm-comp-dy')?.value) || 0;
            const dz = parseFloat(block.querySelector('.asm-comp-dz')?.value) || 0;

            // Get rotation from wizard
            const rot = (parseFloat(document.getElementById('asm-rotation')?.value) || 0) * Math.PI / 180;
            const cosR = Math.cos(rot), sinR = Math.sin(rot);

            // Rotated offsets
            const dxRot = dx * cosR - dy * sinR;
            const dyRot = dx * sinR + dy * cosR;
            const dzRot = dz;

            // Distance squared for parallel axis
            const distXY_sq = dxRot * dxRot + dyRot * dyRot; // for Iz
            const distXZ_sq = dxRot * dxRot + dzRot * dzRot; // for Iy
            const distYZ_sq = dyRot * dyRot + dzRot * dzRot; // for Ix

            // Mass from weight
            const g = App.State.params.gravity;
            const mass = W / g;

            // Parallel axis: I = m * d²
            const Ix = mass * distYZ_sq;
            const Iy = mass * distXZ_sq;
            const Iz = mass * distXY_sq;

            // Update I input fields
            const IxEl = block.querySelector('.asm-comp-Ix');
            const IyEl = block.querySelector('.asm-comp-Iy');
            const IzEl = block.querySelector('.asm-comp-Iz');
            if (IxEl) IxEl.value = Ix.toFixed(4);
            if (IyEl) IyEl.value = Iy.toFixed(4);
            if (IzEl) IzEl.value = Iz.toFixed(4);

            // Sync to existing machine if editing assembly
            if (this._editingId) {
              const blocks = document.getElementById('asm-components').querySelectorAll('.asm-comp-block');
              const compIndex = Array.from(blocks).indexOf(block);
              const machineId = 'm_gen_' + this._editingId + '_' + compIndex;
              const m = App.State.machines.find(x => x.id === machineId);
              if (m) {
                m.Ix = Ix;
                m.Iy = Iy;
                m.Iz = Iz;
              }
            }
            this.updatePreview();
          },

          addComponentRow(comp = { name: '', W: 0, dx: 0, dy: 0, dz: 0, Ix: 0, Iy: 0, Iz: 0 }, idx = null) {
            const container = document.getElementById('asm-components');
            const i = idx !== null ? idx : container.children.length;
            const block = document.createElement('div');
            // Alternating colors: even = white, odd = purple-50
            const bgColor = i % 2 === 0 ? 'bg-white' : 'bg-purple-50';
            block.className = `asm-comp-block border-b border-slate-200 py-1 px-1 ${bgColor}`;
            block.innerHTML = `
              <div class="grid gap-0.5" style="grid-template-columns: 20px 96px 56px 50px 50px 50px 22px;">
                <!-- Row 1: Expand toggle + Name, W, dx, dy, dz, delete -->
                <button type="button" onclick="this.closest('.asm-comp-block').querySelector('.inertia-row').classList.toggle('hidden'); this.querySelector('i').classList.toggle('fa-chevron-right'); this.querySelector('i').classList.toggle('fa-chevron-down');"
                  class="text-purple-400 hover:text-purple-600 text-[12px] flex items-center justify-center" title="Show/Hide Inertia">
                  <i class="fa-solid fa-chevron-right"></i>
                </button>
                <input type="text" value="${comp.name || 'Part ' + (i + 1)}"
                  class="border rounded px-1 py-0.5 text-[12px] asm-comp-name bg-white" oninput="App.Assembly.updatePreview()">
                <input type="number" value="${comp.W || 0}" step="0.001"
                  class="border rounded px-0.5 py-0.5 text-[12px] text-center asm-comp-W bg-white" oninput="App.Assembly.updateComponentI(this)" title="Weight (kN)">
                <input type="number" value="${comp.dx || 0}" step="0.01"
                  class="border rounded px-0.5 py-0.5 text-[12px] text-center asm-comp-dx bg-white" oninput="App.Assembly.updatePreview(); App.Assembly.updateComponentI(this);" title="dx offset">
                <input type="number" value="${comp.dy || 0}" step="0.01"
                  class="border rounded px-0.5 py-0.5 text-[12px] text-center asm-comp-dy bg-white" oninput="App.Assembly.updatePreview(); App.Assembly.updateComponentI(this);" title="dy offset">
                <input type="number" value="${comp.dz || 0}" step="0.01"
                  class="border rounded px-0.5 py-0.5 text-[12px] text-center asm-comp-dz bg-white" oninput="App.Assembly.updateComponentI(this);" title="dz offset">
                <button onclick="this.closest('.asm-comp-block').remove(); App.Assembly.updatePreview();"
                  class="text-red-400 hover:text-red-600 text-[12px]">✕</button>
              </div>
              <!-- Row 2: Inertia (hidden by default) - same grid as row 1 for alignment -->
              <div class="inertia-row hidden mt-0.5 grid gap-0.5" style="grid-template-columns: 20px 96px 56px 50px 50px 50px 22px;">
                <div></div>
                <div class="text-[10px] text-purple-400 italic flex items-center gap-1">
                  <input type="checkbox" ${comp.considerI ? 'checked' : ''}
                    class="asm-comp-considerI w-3 h-3 accent-green-500" title="Consider I - when ON, calculate and sync I values" onchange="App.Assembly.updateIInputStates(this); App.Assembly.updateComponentI(this)">
                  <span class="text-green-500">ConsiderI</span>
                  <input type="checkbox" ${comp.lockI ? 'checked' : ''}
                    class="asm-comp-lockI w-3 h-3 accent-purple-500 ml-1" title="Keep Manual I - skip auto-calculation" onchange="App.Assembly.updateIInputStates(this)">
                  <span>UserI</span>
                </div>
                <!-- Label I: darker, bold, right aligned to be closer to input -->
                <div class="text-[11px] text-slate-600 font-bold text-right pr-1 flex items-center justify-end relative label-i-container">I:</div>
                <input type="number" value="${comp.Ix || 0}" step="0.001"
                  class="border rounded px-0.5 py-0.5 text-[12px] text-center asm-comp-Ix ${comp.considerI && comp.lockI ? 'bg-white' : comp.considerI ? 'bg-slate-100 text-slate-400' : 'bg-slate-100 text-slate-400'}" title="Ix" ${comp.considerI && comp.lockI ? '' : 'readonly'}>
                <input type="number" value="${comp.Iy || 0}" step="0.001"
                  class="border rounded px-0.5 py-0.5 text-[12px] text-center asm-comp-Iy ${comp.considerI && comp.lockI ? 'bg-white' : comp.considerI ? 'bg-slate-100 text-slate-400' : 'bg-slate-100 text-slate-400'}" title="Iy" ${comp.considerI && comp.lockI ? '' : 'readonly'}>
                <input type="number" value="${comp.Iz || 0}" step="0.001"
                  class="border rounded px-0.5 py-0.5 text-[12px] text-center asm-comp-Iz ${comp.considerI && comp.lockI ? 'bg-white' : comp.considerI ? 'bg-slate-100 text-slate-400' : 'bg-slate-100 text-slate-400'}" title="Iz" ${comp.considerI && comp.lockI ? '' : 'readonly'}>
                <div></div>
              </div>
            `;
            container.appendChild(block);
            setTimeout(() => this.updatePreview(), 50);
          },

          // Update I input states based on considerI/lockI checkboxes
          updateIInputStates(el) {
            const block = el.closest('.asm-comp-block');
            if (!block) return;

            const considerI = block.querySelector('.asm-comp-considerI')?.checked;
            const lockI = block.querySelector('.asm-comp-lockI')?.checked;
            const IxEl = block.querySelector('.asm-comp-Ix');
            const IyEl = block.querySelector('.asm-comp-Iy');
            const IzEl = block.querySelector('.asm-comp-Iz');

            [IxEl, IyEl, IzEl].forEach(inp => {
              if (!inp) return;
              // Remove all state classes first
              inp.classList.remove('bg-white', 'bg-blue-50', 'text-blue-600', 'bg-slate-100', 'text-slate-400');

              if (considerI && lockI) {
                // Editable - bright white
                inp.classList.add('bg-white');
                inp.removeAttribute('readonly');
              } else if (considerI) {
                // Auto-calc - readonly gray (user preference)
                inp.classList.add('bg-slate-100', 'text-slate-400');
                inp.setAttribute('readonly', 'true');
              } else {
                // Disabled - gray
                inp.classList.add('bg-slate-100', 'text-slate-400');
                inp.setAttribute('readonly', 'true');
                inp.value = '0';
              }
            });
          },

          createAssembly() {
            const $ = id => document.getElementById(id);
            const components = [];
            const blocks = $('asm-components').querySelectorAll('.asm-comp-block');
            blocks.forEach(block => {
              components.push({
                name: block.querySelector('.asm-comp-name')?.value || '',
                W: parseFloat(block.querySelector('.asm-comp-W')?.value) || 0,
                dx: parseFloat(block.querySelector('.asm-comp-dx')?.value) || 0,
                dy: parseFloat(block.querySelector('.asm-comp-dy')?.value) || 0,
                dz: parseFloat(block.querySelector('.asm-comp-dz')?.value) || 0,
                Ix: parseFloat(block.querySelector('.asm-comp-Ix')?.value) || 0,
                Iy: parseFloat(block.querySelector('.asm-comp-Iy')?.value) || 0,
                Iz: parseFloat(block.querySelector('.asm-comp-Iz')?.value) || 0,
                considerI: block.querySelector('.asm-comp-considerI')?.checked || false,
                lockI: block.querySelector('.asm-comp-lockI')?.checked || false
              });
            });

            if (components.length === 0) {
              alert('Please add at least one component');
              return;
            }

            const asm = {
              id: this._editingId || ('asm_' + Date.now()),
              name: $('asm-name').value,
              X: parseFloat($('asm-X').value) || 0,
              Y: parseFloat($('asm-Y').value) || 0,
              Z: parseFloat($('asm-Z').value) || 0,
              rotation: parseFloat($('asm-rotation').value) || 0,
              components
            };

            // Update or add
            if (this._editingId) {
              const idx = App.State.assemblies.findIndex(a => a.id === this._editingId);
              if (idx >= 0) {
                App.State.assemblies[idx] = asm;
                // Sync to existing machines if they were already generated
                const existingMachines = App.State.machines.filter(m => m.sourceId === this._editingId);
                if (existingMachines.length > 0) {
                  this.syncAssemblyToMachines(asm);
                }
              }
            } else {
              App.State.assemblies.push(asm);
            }

            App.State.notify();
            this.closeWizard();
          },

          syncAssemblyToMachines(asm) {
            // Step 1: Cleanup - remove existing generated machines
            App.State.machines = App.State.machines.filter(m => m.sourceId !== asm.id);

            // Step 2: Transform and create machines at ANCHOR position
            const rad = (asm.rotation || 0) * Math.PI / 180;
            const cosR = Math.cos(rad), sinR = Math.sin(rad);
            const g = App.State.params.gravity;

            asm.components.forEach((comp, i) => {
              // Calculate rotated offset for parallel axis distance
              const dxRot = comp.dx * cosR - comp.dy * sinR;
              const dyRot = comp.dx * sinR + comp.dy * cosR;
              const dzRot = comp.dz || 0;

              // Distance squared from component to anchor (for parallel axis theorem)
              const distXY_sq = dxRot * dxRot + dyRot * dyRot; // for Iz
              const distXZ_sq = dxRot * dxRot + dzRot * dzRot; // for Iy
              const distYZ_sq = dyRot * dyRot + dzRot * dzRot; // for Ix

              // Mass from weight: m = W / g
              const mass = (comp.W || 0) / g;

              // Inertia with parallel axis theorem: I_anchor = I_local_rotated + m * d²
              let Ix_anchor = 0, Iy_anchor = 0, Iz_anchor = 0;

              // Only calculate I if considerI is true
              if (comp.considerI) {
                if (comp.lockI) {
                  // User-entered local I values - need to add parallel axis
                  let Ix_local = comp.Ix || 0;
                  let Iy_local = comp.Iy || 0;
                  let Iz_local = comp.Iz || 0;
                  Ix_anchor = Ix_local + mass * distYZ_sq;
                  Iy_anchor = Iy_local + mass * distXZ_sq;
                  Iz_anchor = Iz_local + mass * distXY_sq;
                } else {
                  // Auto-calc mode: comp.Ix already contains parallel axis (calculated by updateComponentI)
                  // Use directly, NO additional parallel axis!
                  Ix_anchor = comp.Ix || 0;
                  Iy_anchor = comp.Iy || 0;
                  Iz_anchor = comp.Iz || 0;
                }
              }
              // If considerI is false, I values stay at 0

              // Create machine at ANCHOR position (not at offset)
              App.State.machines.push({
                id: 'm_gen_' + asm.id + '_' + i,
                name: comp.name,
                W: comp.W,
                X: asm.X, Y: asm.Y, Z: asm.Z, // ALL at anchor
                rotation: asm.rotation,
                Ix: Ix_anchor, Iy: Iy_anchor, Iz: Iz_anchor,
                isGenerated: true,
                sourceId: asm.id,
                componentIndex: i,
                // Store original offset for reference
                _offsetDx: dxRot, _offsetDy: dyRot, _offsetDz: dzRot
              });
            });
          },

          generateAll() {
            if (App.State.assemblies.length === 0) {
              App.UI?.showCanvasMsg?.('No assemblies defined');
              return;
            }
            App.State.assemblies.forEach(asm => this.syncAssemblyToMachines(asm));
            App.State.notify();
            App.UI?.showCanvasMsg?.(`Generated machines from ${App.State.assemblies.length} assemblies`);
          },

          deleteAssembly(id) {
            App.State.assemblies = App.State.assemblies.filter(a => a.id !== id);
            App.State.machines = App.State.machines.filter(m => m.sourceId !== id);
            App.State.notify();
          },

          // Move anchor when generated machine is moved, then resync all at new anchor
          onMachineMove(machine, newX, newY, newZ) {
            if (!machine.isGenerated || !machine.sourceId) return false;

            const asm = App.State.assemblies.find(a => a.id === machine.sourceId);
            if (!asm) return false;

            // Update anchor position to new location
            asm.X = newX; asm.Y = newY; asm.Z = newZ;

            // Resync all machines from this assembly to new anchor with recalculated I
            const rad = (asm.rotation || 0) * Math.PI / 180;
            const cosR = Math.cos(rad), sinR = Math.sin(rad);
            const g = App.State.params.gravity;

            App.State.machines.forEach(m => {
              if (m.isGenerated && m.sourceId === asm.id && m.componentIndex !== undefined) {
                const comp = asm.components[m.componentIndex];
                if (comp) {
                  // Keep at anchor
                  m.X = asm.X; m.Y = asm.Y; m.Z = asm.Z;

                  // Only recalculate I if considerI is true
                  if (comp.considerI) {
                    // Recalculate I with parallel axis theorem
                    const dxRot = comp.dx * cosR - comp.dy * sinR;
                    const dyRot = comp.dx * sinR + comp.dy * cosR;
                    const dzRot = comp.dz || 0;
                    const mass = (comp.W || 0) / g;

                    const distYZ_sq = dyRot * dyRot + dzRot * dzRot;
                    const distXZ_sq = dxRot * dxRot + dzRot * dzRot;
                    const distXY_sq = dxRot * dxRot + dyRot * dyRot;

                    if (comp.lockI) {
                      // User's local I - add parallel axis
                      m.Ix = (comp.Ix || 0) + mass * distYZ_sq;
                      m.Iy = (comp.Iy || 0) + mass * distXZ_sq;
                      m.Iz = (comp.Iz || 0) + mass * distXY_sq;
                    } else {
                      // Auto-calc: comp.Ix already has parallel axis, use directly
                      m.Ix = comp.Ix || 0;
                      m.Iy = comp.Iy || 0;
                      m.Iz = comp.Iz || 0;
                    }
                  }
                  // If considerI is false, keep existing I values (no change)
                }
              }
            });

            return true; // Sync handled
          }
        }
      };

      window.onload = () => {
        App.Renderer.init();
        App.UI.init();
        // Initialize lock button visuals to match default enabled state
        App.State.updateLockButtons();
        // Assembly button event listeners
        const btnDefine = document.getElementById('btn-define-assembly');
        if (btnDefine) btnDefine.addEventListener('click', () => App.Assembly.openWizard());
        const btnGenerate = document.getElementById('btn-generate-machines');
        if (btnGenerate) btnGenerate.addEventListener('click', () => App.Assembly.generateAll());
        // Trigger initial audit on page load (false = no history push)
        App.State.notify(false);
      };
    </script>
</body>

</html>